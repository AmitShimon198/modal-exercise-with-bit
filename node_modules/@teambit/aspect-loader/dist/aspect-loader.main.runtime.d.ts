import { Component, ComponentID } from '@teambit/component';
import { ExtensionManifest, Harmony, Aspect, SlotRegistry } from '@teambit/harmony';
import type { LoggerMain } from '@teambit/logger';
import { Logger } from '@teambit/logger';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { EnvsMain } from '@teambit/envs';
import { AspectDefinition, AspectDefinitionProps } from './aspect-definition';
export declare type AspectDescriptor = {
    id: string;
    icon?: string;
};
export declare type AspectResolver = (component: Component) => Promise<ResolvedAspect>;
export declare type ResolvedAspect = {
    aspectPath: string;
    runtimePath: string | null;
};
declare type OnAspectLoadError = (err: Error, id: ComponentID) => Promise<boolean>;
export declare type OnAspectLoadErrorSlot = SlotRegistry<OnAspectLoadError>;
export declare type OnLoadRequireableExtension = (requireableExtension: RequireableComponent, manifest: ExtensionManifest | Aspect) => Promise<ExtensionManifest | Aspect>;
export declare type OnLoadRequireableExtensionSlot = SlotRegistry<OnLoadRequireableExtension>;
export declare type MainAspect = {
    path: string;
    version: string | undefined;
    packageName: string | undefined;
    aspect: Aspect;
    name: string;
    id: string;
};
export declare class AspectLoaderMain {
    private logger;
    private envs;
    private harmony;
    private onAspectLoadErrorSlot;
    private onLoadRequireableExtensionSlot;
    constructor(logger: Logger, envs: EnvsMain, harmony: Harmony, onAspectLoadErrorSlot: OnAspectLoadErrorSlot, onLoadRequireableExtensionSlot: OnLoadRequireableExtensionSlot);
    private getCompiler;
    registerOnAspectLoadErrorSlot(onAspectLoadError: OnAspectLoadError): void;
    registerOnLoadRequireableExtensionSlot(onLoadRequireableExtension: OnLoadRequireableExtension): void;
    triggerOnAspectLoadError(err: Error, component: Component): Promise<boolean>;
    getRuntimePath(component: Component, modulePath: string, runtime: string): Promise<string | null>;
    isAspectLoaded(id: string): unknown;
    getDescriptor(id: string): AspectDescriptor;
    getNotLoadedConfiguredExtensions(): string[];
    loadDefinition(props: AspectDefinitionProps): AspectDefinition;
    private _coreAspects;
    get coreAspects(): Aspect[];
    isCoreAspect(id: string): boolean;
    setCoreAspects(aspects: Aspect[]): this;
    getCoreAspectIds(): string[];
    private _reserved;
    getUserAspects(): string[];
    getCoreAspectDefs(runtimeName?: string): Promise<AspectDefinition[]>;
    resolveAspects(components: Component[], resolver: AspectResolver): Promise<AspectDefinition[]>;
    private _mainAspect;
    get mainAspect(): MainAspect;
    setMainAspect(mainAspect: MainAspect): this;
    private failedLoadAspect;
    get failedAspects(): string[];
    private addFailure;
    doRequire(requireableExtension: RequireableComponent): Promise<ExtensionManifest | Aspect>;
    loadRequireableExtensions(requireableExtensions: RequireableComponent[], throwOnError?: boolean): Promise<void>;
    handleExtensionLoadingError(error: Error, idStr: string, throwOnError: boolean): void;
    runOnLoadRequireableExtensionSubscribers(requireableExtension: RequireableComponent, manifest: ExtensionManifest | Aspect): Promise<ExtensionManifest | Aspect>;
    isAspect(manifest: any): boolean;
    loadAspectsFromGlobalScope(aspectIds: string[]): Promise<Component[]>;
    private prepareManifests;
    loadExtensionsByManifests(extensionsManifests: Array<ExtensionManifest | Aspect>, throwOnError?: boolean): Promise<void>;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static slots: (((registerFn: () => string) => SlotRegistry<OnAspectLoadError>) | ((registerFn: () => string) => SlotRegistry<OnLoadRequireableExtension>))[];
    static provider([loggerExt, envs]: [LoggerMain, EnvsMain], config: any, [onAspectLoadErrorSlot, onLoadRequireableExtensionSlot]: [OnAspectLoadErrorSlot, OnLoadRequireableExtensionSlot], harmony: Harmony): Promise<AspectLoaderMain>;
}
export {};
