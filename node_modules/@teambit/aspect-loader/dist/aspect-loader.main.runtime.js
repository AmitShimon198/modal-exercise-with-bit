"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AspectLoaderMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/scope"));

  _scope = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _bit() {
  const data = require("@teambit/bit");

  _bit = function () {
    return data;
  };

  return data;
}

function _scope2() {
  const data = require("@teambit/scope");

  _scope2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _aspectDefinition() {
  const data = require("./aspect-definition");

  _aspectDefinition = function () {
    return data;
  };

  return data;
}

function _aspectLoader() {
  const data = require("./aspect-loader.aspect");

  _aspectLoader = function () {
    return data;
  };

  return data;
}

function _constants2() {
  const data = require("./constants");

  _constants2 = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _coreAspects() {
  const data = require("./core-aspects");

  _coreAspects = function () {
    return data;
  };

  return data;
}

class AspectLoaderMain {
  constructor(logger, envs, harmony, onAspectLoadErrorSlot, onLoadRequireableExtensionSlot) {
    this.logger = logger;
    this.envs = envs;
    this.harmony = harmony;
    this.onAspectLoadErrorSlot = onAspectLoadErrorSlot;
    this.onLoadRequireableExtensionSlot = onLoadRequireableExtensionSlot;
    (0, _defineProperty2().default)(this, "_coreAspects", []);
    (0, _defineProperty2().default)(this, "_reserved", ['teambit.harmony/bit', 'teambit.harmony/config']);
    (0, _defineProperty2().default)(this, "_mainAspect", void 0);
    (0, _defineProperty2().default)(this, "failedLoadAspect", []);
  }

  getCompiler(component) {
    var _this$envs$getEnv;

    const env = (_this$envs$getEnv = this.envs.getEnv(component)) === null || _this$envs$getEnv === void 0 ? void 0 : _this$envs$getEnv.env;
    return env === null || env === void 0 ? void 0 : env.getCompiler();
  }

  registerOnAspectLoadErrorSlot(onAspectLoadError) {
    this.onAspectLoadErrorSlot.register(onAspectLoadError);
  }

  registerOnLoadRequireableExtensionSlot(onLoadRequireableExtension) {
    this.onLoadRequireableExtensionSlot.register(onLoadRequireableExtension);
  }
  /**
   * returns whether the aspect-load issue has been fixed.
   */


  async triggerOnAspectLoadError(err, component) {
    const entries = this.onAspectLoadErrorSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onAspectLoadError] ] ]

    let isFixed = false;
    await (0, _pMapSeries().default)(entries, async ([, onAspectFailFunc]) => {
      const result = await onAspectFailFunc(err, component.id);
      if (result) isFixed = true;
    });
    return isFixed;
  }

  async getRuntimePath(component, modulePath, runtime) {
    const runtimeFile = component.filesystem.files.find(file => {
      return file.relative.includes(`.${runtime}.runtime`);
    }); // @david we should add a compiler api for this.

    if (!runtimeFile) return null;
    const compiler = this.getCompiler(component);

    if (!compiler) {
      return (0, _path().join)(modulePath, runtimeFile.relative);
    }

    const dist = compiler.getDistPathBySrcPath(runtimeFile.relative);
    return (0, _path().join)(modulePath, dist);
  }

  isAspectLoaded(id) {
    if (this.failedAspects.includes(id)) return true;

    try {
      return this.harmony.get(id);
    } catch (err) {
      return false;
    }
  }

  getDescriptor(id) {
    const instance = this.harmony.get(id);
    const iconFn = instance.icon;
    const icon = iconFn ? iconFn.apply(instance) : undefined;
    return {
      id,
      icon
    };
  }

  getNotLoadedConfiguredExtensions() {
    const configuredAspects = Array.from(this.harmony.config.raw.keys());
    const loadedExtensions = this.harmony.extensionsIds;
    const extensionsToLoad = (0, _lodash().difference)(configuredAspects, loadedExtensions);
    return extensionsToLoad;
  }

  loadDefinition(props) {
    return _aspectDefinition().AspectDefinition.from(props);
  }

  get coreAspects() {
    return this._coreAspects;
  }

  isCoreAspect(id) {
    const ids = this.getCoreAspectIds();
    return ids.includes(id);
  }

  setCoreAspects(aspects) {
    this._coreAspects = aspects;
    return this;
  }

  getCoreAspectIds() {
    const ids = this.coreAspects.map(aspect => aspect.id);
    return ids.concat(this._reserved);
  }

  getUserAspects() {
    const coreAspectIds = this.getCoreAspectIds();
    return (0, _lodash().difference)(this.harmony.extensionsIds, coreAspectIds);
  }

  async getCoreAspectDefs(runtimeName) {
    const defs = await Promise.all(this.coreAspects.map(async aspect => {
      const id = aspect.id;
      const rawDef = await (0, _coreAspects().getAspectDef)(id, runtimeName);
      return this.loadDefinition(rawDef);
    }));
    return defs.filter(def => def.runtimePath);
  }

  async resolveAspects(components, resolver) {
    const promises = components.map(async component => {
      const resolvedAspect = await resolver(component);
      return new (_aspectDefinition().AspectDefinition)(resolvedAspect.aspectPath, resolvedAspect.runtimePath, component);
    });
    const aspectDefs = await Promise.all(promises); // return aspectDefs.filter((def) => def.runtimePath);

    return aspectDefs;
  }

  get mainAspect() {
    return this._mainAspect;
  }

  setMainAspect(mainAspect) {
    this._mainAspect = mainAspect;
    return this;
  }

  get failedAspects() {
    return this.failedLoadAspect;
  }

  addFailure(id) {
    if (this.failedAspects.includes(id)) return;
    this.failedLoadAspect.push(id);
  }
  /**
   * run "require" of the component code to get the manifest
   */


  async doRequire(requireableExtension) {
    const idStr = requireableExtension.component.id.toString();
    const aspect = await requireableExtension.require();
    const manifest = aspect.default || aspect;
    manifest.id = idStr;
    const newManifest = await this.runOnLoadRequireableExtensionSubscribers(requireableExtension, manifest);
    return newManifest;
  }
  /**
   * in case the extension failed to load, prefer to throw an error, unless `throwOnError` param
   * passed as `false`.
   * there are cases when throwing an error blocks the user from doing anything else. for example,
   * when a user develops an extension and deletes the node-modules, the extension on the workspace
   * cannot be loaded anymore until "bit compile" is running. however, if this function throws an
   * error, it'll throw for "bit compile" as well, which blocks the user.
   * for the CI, it is important to throw an error because errors on console can be ignored.
   * for now, when loading the extension from the workspace the throwOnError is passed as false.
   * when loading from the scope (CI) it should be true.
   *
   * the console printing here is done directly by "console.error" and not by the logger. the reason
   * is that the logger.console only prints when the loader started (which, btw, happens after
   * entering this function, so it can't work) and here we want it to be printed regardless of the
   * rules of starting the loader. e.g. if by mistake the CI got it as throwOnError=false, it's ok
   * to break the output by the console.error.
   *
   * @todo: this is not the final word however about throwing/non throwing errors here.
   * in some cases, such as "bit tag", it's better not to tag if an extension changes the model.
   */


  async loadRequireableExtensions(requireableExtensions, throwOnError = false) {
    const manifestsP = (0, _pMapSeries().default)(requireableExtensions, async requireableExtension => {
      if (!requireableExtensions) return undefined;
      const idStr = requireableExtension.component.id.toString();

      try {
        return await this.doRequire(requireableExtension);
      } catch (e) {
        this.addFailure(idStr);
        const errorMsg = (0, _constants2().UNABLE_TO_LOAD_EXTENSION)(idStr);
        this.logger.error(errorMsg, e);
        const isFixed = await this.triggerOnAspectLoadError(e, requireableExtension.component);
        let errAfterReLoad;

        if (isFixed) {
          this.logger.info(`the loading issue has been fixed, re-loading ${idStr}`);

          try {
            return await this.doRequire(requireableExtension);
          } catch (err) {
            this.logger.error('re-load of the aspect failed as well', err);
            errAfterReLoad = err;
          }
        }

        const error = errAfterReLoad || e;
        this.handleExtensionLoadingError(error, idStr, throwOnError);
      }

      return undefined;
    });
    const manifests = await manifestsP; // Remove empty manifests as a result of loading issue

    const filteredManifests = (0, _lodash().compact)(manifests);
    return this.loadExtensionsByManifests(filteredManifests, throwOnError);
  }

  handleExtensionLoadingError(error, idStr, throwOnError) {
    const errorMsg = (0, _constants2().UNABLE_TO_LOAD_EXTENSION)(idStr);

    if (throwOnError) {
      // @ts-ignore
      this.logger.console(error);
      throw new (_exceptions().CannotLoadExtension)(idStr, error);
    }

    if (this.logger.isLoaderStarted) {
      this.logger.consoleFailure(errorMsg);
    } else {
      this.logger.console(errorMsg);
      this.logger.console(error.message);
    }
  }

  async runOnLoadRequireableExtensionSubscribers(requireableExtension, manifest) {
    let updatedManifest = manifest;
    const entries = this.onLoadRequireableExtensionSlot.toArray();
    await (0, _pMapSeries().default)(entries, async ([, onLoadRequireableExtensionFunc]) => {
      updatedManifest = await onLoadRequireableExtensionFunc(requireableExtension, updatedManifest);
    });
    return updatedManifest;
  }

  isAspect(manifest) {
    return !!(manifest.addRuntime && manifest.getRuntime);
  }
  /**
   * get or create a global scope, import the non-core aspects, load bit from that scope, create
   * capsules for the aspects and load them from the capsules.
   */


  async loadAspectsFromGlobalScope(aspectIds) {
    const globalScope = await _scope().default.ensure(_constants().GLOBAL_SCOPE, 'global-scope');
    await globalScope.ensureDir();
    const globalScopeHarmony = await (0, _bit().loadBit)(globalScope.path);
    const scope = globalScopeHarmony.get(_scope2().ScopeAspect.id); // @todo: Gilad make this work
    // const ids = await scope.resolveMultipleComponentIds(aspectIds);

    const ids = aspectIds.map(id => _component().ComponentID.fromLegacy(_legacyBitId().BitId.parse(id, true)));
    const hasVersions = ids.every(id => id.hasVersion());
    const useCache = hasVersions; // if all components has versions, try to use the cached aspects

    const components = await scope.import(ids, useCache, true); // don't use `await scope.loadAspectsFromCapsules(components, true);`
    // it won't work for globalScope because `this !== scope.aspectLoader` (this instance
    // is not the same as the aspectLoader instance Scope has)

    const resolvedAspects = await scope.getResolvedAspects(components);

    try {
      await this.loadRequireableExtensions(resolvedAspects, true);
    } catch (err) {
      if ((err === null || err === void 0 ? void 0 : err.error.code) === 'MODULE_NOT_FOUND') {
        const resolvedAspectsAgain = await scope.getResolvedAspects(components, {
          skipIfExists: false
        });
        await this.loadRequireableExtensions(resolvedAspectsAgain, true);
      } else {
        throw err;
      }
    }

    return components;
  }

  prepareManifests(manifests) {
    return manifests.map(manifest => {
      if (this.isAspect(manifest)) return manifest;
      manifest.runtime = _cli().MainRuntime;
      if (!manifest.id) throw new Error('manifest must have static id');

      const aspect = _harmony().Aspect.create({
        id: manifest.id
      });

      aspect.addRuntime(manifest);
      return aspect;
    });
  } // TODO: change to use the new logger, see more info at loadExtensions function in the workspace


  async loadExtensionsByManifests(extensionsManifests, throwOnError = true) {
    try {
      const manifests = extensionsManifests.filter(manifest => {
        // @ts-ignore TODO: fix this
        const isValid = this.isAspect(manifest) || manifest.provider;
        if (!isValid) this.logger.warn(`${manifest.id} is invalid. please make sure the extension is valid.`);
        return isValid;
      });
      const preparedManifests = this.prepareManifests(manifests); // @ts-ignore TODO: fix this

      await this.harmony.load(preparedManifests);
    } catch (e) {
      const ids = extensionsManifests.map(manifest => manifest.id || 'unknown'); // TODO: improve texts

      const warning = (0, _constants2().UNABLE_TO_LOAD_EXTENSION_FROM_LIST)(ids);
      this.logger.warn(warning, e);

      if (this.logger.isLoaderStarted) {
        this.logger.consoleFailure(warning);
      } else {
        this.logger.console(warning);
        this.logger.console(e);
      }

      if (throwOnError) {
        throw e;
      }
    }
  }

  static async provider([loggerExt, envs], config, [onAspectLoadErrorSlot, onLoadRequireableExtensionSlot], harmony) {
    const logger = loggerExt.createLogger(_aspectLoader().AspectLoaderAspect.id);
    const aspectLoader = new AspectLoaderMain(logger, envs, harmony, onAspectLoadErrorSlot, onLoadRequireableExtensionSlot);
    return aspectLoader;
  }

}

exports.AspectLoaderMain = AspectLoaderMain;
(0, _defineProperty2().default)(AspectLoaderMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(AspectLoaderMain, "dependencies", [_logger().LoggerAspect, _envs().EnvsAspect]);
(0, _defineProperty2().default)(AspectLoaderMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);

_aspectLoader().AspectLoaderAspect.addRuntime(AspectLoaderMain);

//# sourceMappingURL=aspect-loader.main.runtime.js.map