{"version":3,"sources":["aspect-loader.main.runtime.ts"],"names":["AspectLoaderMain","constructor","logger","envs","harmony","onAspectLoadErrorSlot","onLoadRequireableExtensionSlot","getCompiler","component","env","getEnv","registerOnAspectLoadErrorSlot","onAspectLoadError","register","registerOnLoadRequireableExtensionSlot","onLoadRequireableExtension","triggerOnAspectLoadError","err","entries","toArray","isFixed","onAspectFailFunc","result","id","getRuntimePath","modulePath","runtime","runtimeFile","filesystem","files","find","file","relative","includes","compiler","dist","getDistPathBySrcPath","isAspectLoaded","failedAspects","get","getDescriptor","instance","iconFn","icon","apply","undefined","getNotLoadedConfiguredExtensions","configuredAspects","Array","from","config","raw","keys","loadedExtensions","extensionsIds","extensionsToLoad","loadDefinition","props","AspectDefinition","coreAspects","_coreAspects","isCoreAspect","ids","getCoreAspectIds","setCoreAspects","aspects","map","aspect","concat","_reserved","getUserAspects","coreAspectIds","getCoreAspectDefs","runtimeName","defs","Promise","all","rawDef","filter","def","runtimePath","resolveAspects","components","resolver","promises","resolvedAspect","aspectPath","aspectDefs","mainAspect","_mainAspect","setMainAspect","failedLoadAspect","addFailure","push","doRequire","requireableExtension","idStr","toString","require","manifest","default","newManifest","runOnLoadRequireableExtensionSubscribers","loadRequireableExtensions","requireableExtensions","throwOnError","manifestsP","e","errorMsg","error","errAfterReLoad","info","handleExtensionLoadingError","manifests","filteredManifests","loadExtensionsByManifests","console","CannotLoadExtension","isLoaderStarted","consoleFailure","message","updatedManifest","onLoadRequireableExtensionFunc","isAspect","addRuntime","getRuntime","loadAspectsFromGlobalScope","aspectIds","globalScope","LegacyScope","ensure","GLOBAL_SCOPE","ensureDir","globalScopeHarmony","path","scope","ScopeAspect","ComponentID","fromLegacy","BitId","parse","hasVersions","every","hasVersion","useCache","import","resolvedAspects","getResolvedAspects","code","resolvedAspectsAgain","skipIfExists","prepareManifests","MainRuntime","Error","Aspect","create","extensionsManifests","isValid","provider","warn","preparedManifests","load","warning","loggerExt","createLogger","AspectLoaderAspect","aspectLoader","LoggerAspect","EnvsAspect","Slot","withType"],"mappings":"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","sourcesContent":["import { join } from 'path';\nimport { BitId } from '@teambit/legacy-bit-id';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport { GLOBAL_SCOPE } from '@teambit/legacy/dist/constants';\nimport { MainRuntime } from '@teambit/cli';\nimport { Component, ComponentID } from '@teambit/component';\nimport { ExtensionManifest, Harmony, Aspect, SlotRegistry, Slot } from '@teambit/harmony';\nimport type { LoggerMain } from '@teambit/logger';\nimport { Logger, LoggerAspect } from '@teambit/logger';\nimport { RequireableComponent } from '@teambit/harmony.modules.requireable-component';\nimport { EnvsAspect, EnvsMain } from '@teambit/envs';\nimport { loadBit } from '@teambit/bit';\nimport { ScopeAspect, ScopeMain } from '@teambit/scope';\nimport mapSeries from 'p-map-series';\nimport { difference, compact } from 'lodash';\nimport { AspectDefinition, AspectDefinitionProps } from './aspect-definition';\nimport { AspectLoaderAspect } from './aspect-loader.aspect';\nimport { UNABLE_TO_LOAD_EXTENSION, UNABLE_TO_LOAD_EXTENSION_FROM_LIST } from './constants';\nimport { CannotLoadExtension } from './exceptions';\nimport { getAspectDef } from './core-aspects';\n\nexport type AspectDescriptor = {\n  /**\n   * name of the extension.\n   */\n  id: string;\n\n  /**\n   * icon of the extension.\n   */\n  icon?: string;\n};\n\nexport type AspectResolver = (component: Component) => Promise<ResolvedAspect>;\n\nexport type ResolvedAspect = {\n  aspectPath: string;\n  runtimePath: string | null;\n};\n\ntype OnAspectLoadError = (err: Error, id: ComponentID) => Promise<boolean>;\nexport type OnAspectLoadErrorSlot = SlotRegistry<OnAspectLoadError>;\n\nexport type OnLoadRequireableExtension = (\n  requireableExtension: RequireableComponent,\n  manifest: ExtensionManifest | Aspect\n) => Promise<ExtensionManifest | Aspect>;\n/**\n * A slot which run during loading the requirable extension (after first manifest calculation)\n */\nexport type OnLoadRequireableExtensionSlot = SlotRegistry<OnLoadRequireableExtension>;\n\nexport type MainAspect = {\n  /**\n   * path to the main aspect.\n   */\n  path: string;\n\n  /**\n   * version of the aspect.\n   */\n  version: string | undefined;\n\n  /**\n   * package name of the aspect\n   */\n  packageName: string | undefined;\n\n  /**\n   * reference to aspect manifest.\n   */\n  aspect: Aspect;\n\n  /**\n   * The name of the aspect (without the scope prefix)\n   */\n  name: string;\n\n  /**\n   * The name of the aspect\n   */\n  id: string;\n};\n\nexport class AspectLoaderMain {\n  constructor(\n    private logger: Logger,\n    private envs: EnvsMain,\n    private harmony: Harmony,\n    private onAspectLoadErrorSlot: OnAspectLoadErrorSlot,\n    private onLoadRequireableExtensionSlot: OnLoadRequireableExtensionSlot\n  ) {}\n\n  private getCompiler(component: Component) {\n    const env = this.envs.getEnv(component)?.env;\n    return env?.getCompiler();\n  }\n\n  registerOnAspectLoadErrorSlot(onAspectLoadError: OnAspectLoadError) {\n    this.onAspectLoadErrorSlot.register(onAspectLoadError);\n  }\n\n  registerOnLoadRequireableExtensionSlot(onLoadRequireableExtension: OnLoadRequireableExtension) {\n    this.onLoadRequireableExtensionSlot.register(onLoadRequireableExtension);\n  }\n\n  /**\n   * returns whether the aspect-load issue has been fixed.\n   */\n  async triggerOnAspectLoadError(err: Error, component: Component): Promise<boolean> {\n    const entries = this.onAspectLoadErrorSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onAspectLoadError] ] ]\n    let isFixed = false;\n    await mapSeries(entries, async ([, onAspectFailFunc]) => {\n      const result = await onAspectFailFunc(err, component.id);\n      if (result) isFixed = true;\n    });\n\n    return isFixed;\n  }\n\n  async getRuntimePath(component: Component, modulePath: string, runtime: string): Promise<string | null> {\n    const runtimeFile = component.filesystem.files.find((file: any) => {\n      return file.relative.includes(`.${runtime}.runtime`);\n    });\n\n    // @david we should add a compiler api for this.\n    if (!runtimeFile) return null;\n\n    const compiler = this.getCompiler(component);\n\n    if (!compiler) {\n      return join(modulePath, runtimeFile.relative);\n    }\n\n    const dist = compiler.getDistPathBySrcPath(runtimeFile.relative);\n    return join(modulePath, dist);\n  }\n\n  isAspectLoaded(id: string) {\n    if (this.failedAspects.includes(id)) return true;\n    try {\n      return this.harmony.get(id);\n    } catch (err: any) {\n      return false;\n    }\n  }\n\n  getDescriptor(id: string): AspectDescriptor {\n    const instance = this.harmony.get<any>(id);\n    const iconFn = instance.icon;\n\n    const icon = iconFn ? iconFn.apply(instance) : undefined;\n\n    return {\n      id,\n      icon,\n    };\n  }\n\n  getNotLoadedConfiguredExtensions() {\n    const configuredAspects = Array.from(this.harmony.config.raw.keys());\n    const loadedExtensions = this.harmony.extensionsIds;\n    const extensionsToLoad = difference(configuredAspects, loadedExtensions);\n    return extensionsToLoad;\n  }\n\n  loadDefinition(props: AspectDefinitionProps): AspectDefinition {\n    return AspectDefinition.from(props);\n  }\n\n  private _coreAspects: Aspect[] = [];\n\n  get coreAspects() {\n    return this._coreAspects;\n  }\n\n  isCoreAspect(id: string) {\n    const ids = this.getCoreAspectIds();\n    return ids.includes(id);\n  }\n\n  setCoreAspects(aspects: Aspect[]) {\n    this._coreAspects = aspects;\n    return this;\n  }\n\n  getCoreAspectIds() {\n    const ids = this.coreAspects.map((aspect) => aspect.id);\n    return ids.concat(this._reserved);\n  }\n\n  private _reserved = ['teambit.harmony/bit', 'teambit.harmony/config'];\n\n  getUserAspects(): string[] {\n    const coreAspectIds = this.getCoreAspectIds();\n    return difference(this.harmony.extensionsIds, coreAspectIds);\n  }\n\n  async getCoreAspectDefs(runtimeName?: string) {\n    const defs = await Promise.all(\n      this.coreAspects.map(async (aspect) => {\n        const id = aspect.id;\n        const rawDef = await getAspectDef(id, runtimeName);\n        return this.loadDefinition(rawDef);\n      })\n    );\n\n    return defs.filter((def) => def.runtimePath);\n  }\n\n  async resolveAspects(components: Component[], resolver: AspectResolver): Promise<AspectDefinition[]> {\n    const promises = components.map(async (component) => {\n      const resolvedAspect = await resolver(component);\n      return new AspectDefinition(resolvedAspect.aspectPath, resolvedAspect.runtimePath, component);\n    });\n\n    const aspectDefs = await Promise.all(promises);\n    // return aspectDefs.filter((def) => def.runtimePath);\n    return aspectDefs;\n  }\n\n  private _mainAspect: MainAspect;\n\n  get mainAspect() {\n    return this._mainAspect;\n  }\n\n  setMainAspect(mainAspect: MainAspect) {\n    this._mainAspect = mainAspect;\n    return this;\n  }\n\n  private failedLoadAspect: string[] = [];\n\n  get failedAspects() {\n    return this.failedLoadAspect;\n  }\n\n  private addFailure(id: string): void {\n    if (this.failedAspects.includes(id)) return;\n    this.failedLoadAspect.push(id);\n  }\n\n  /**\n   * run \"require\" of the component code to get the manifest\n   */\n  async doRequire(requireableExtension: RequireableComponent): Promise<ExtensionManifest | Aspect> {\n    const idStr = requireableExtension.component.id.toString();\n    const aspect = await requireableExtension.require();\n    const manifest = aspect.default || aspect;\n    manifest.id = idStr;\n    const newManifest = await this.runOnLoadRequireableExtensionSubscribers(requireableExtension, manifest);\n    return newManifest;\n  }\n\n  /**\n   * in case the extension failed to load, prefer to throw an error, unless `throwOnError` param\n   * passed as `false`.\n   * there are cases when throwing an error blocks the user from doing anything else. for example,\n   * when a user develops an extension and deletes the node-modules, the extension on the workspace\n   * cannot be loaded anymore until \"bit compile\" is running. however, if this function throws an\n   * error, it'll throw for \"bit compile\" as well, which blocks the user.\n   * for the CI, it is important to throw an error because errors on console can be ignored.\n   * for now, when loading the extension from the workspace the throwOnError is passed as false.\n   * when loading from the scope (CI) it should be true.\n   *\n   * the console printing here is done directly by \"console.error\" and not by the logger. the reason\n   * is that the logger.console only prints when the loader started (which, btw, happens after\n   * entering this function, so it can't work) and here we want it to be printed regardless of the\n   * rules of starting the loader. e.g. if by mistake the CI got it as throwOnError=false, it's ok\n   * to break the output by the console.error.\n   *\n   * @todo: this is not the final word however about throwing/non throwing errors here.\n   * in some cases, such as \"bit tag\", it's better not to tag if an extension changes the model.\n   */\n  async loadRequireableExtensions(requireableExtensions: RequireableComponent[], throwOnError = false): Promise<void> {\n    const manifestsP = mapSeries(requireableExtensions, async (requireableExtension) => {\n      if (!requireableExtensions) return undefined;\n      const idStr = requireableExtension.component.id.toString();\n      try {\n        return await this.doRequire(requireableExtension);\n      } catch (e: any) {\n        this.addFailure(idStr);\n        const errorMsg = UNABLE_TO_LOAD_EXTENSION(idStr);\n        this.logger.error(errorMsg, e);\n        const isFixed = await this.triggerOnAspectLoadError(e, requireableExtension.component);\n        let errAfterReLoad;\n        if (isFixed) {\n          this.logger.info(`the loading issue has been fixed, re-loading ${idStr}`);\n          try {\n            return await this.doRequire(requireableExtension);\n          } catch (err: any) {\n            this.logger.error('re-load of the aspect failed as well', err);\n            errAfterReLoad = err;\n          }\n        }\n        const error = errAfterReLoad || e;\n        this.handleExtensionLoadingError(error, idStr, throwOnError);\n      }\n      return undefined;\n    });\n    const manifests = await manifestsP;\n\n    // Remove empty manifests as a result of loading issue\n    const filteredManifests = compact(manifests);\n    return this.loadExtensionsByManifests(filteredManifests, throwOnError);\n  }\n\n  handleExtensionLoadingError(error: Error, idStr: string, throwOnError: boolean) {\n    const errorMsg = UNABLE_TO_LOAD_EXTENSION(idStr);\n    if (throwOnError) {\n      // @ts-ignore\n      this.logger.console(error);\n      throw new CannotLoadExtension(idStr, error);\n    }\n    if (this.logger.isLoaderStarted) {\n      this.logger.consoleFailure(errorMsg);\n    } else {\n      this.logger.console(errorMsg);\n      this.logger.console(error.message);\n    }\n  }\n\n  async runOnLoadRequireableExtensionSubscribers(\n    requireableExtension: RequireableComponent,\n    manifest: ExtensionManifest | Aspect\n  ): Promise<ExtensionManifest | Aspect> {\n    let updatedManifest = manifest;\n    const entries = this.onLoadRequireableExtensionSlot.toArray();\n    await mapSeries(entries, async ([, onLoadRequireableExtensionFunc]) => {\n      updatedManifest = await onLoadRequireableExtensionFunc(requireableExtension, updatedManifest);\n    });\n    return updatedManifest;\n  }\n\n  isAspect(manifest: any) {\n    return !!(manifest.addRuntime && manifest.getRuntime);\n  }\n\n  /**\n   * get or create a global scope, import the non-core aspects, load bit from that scope, create\n   * capsules for the aspects and load them from the capsules.\n   */\n  async loadAspectsFromGlobalScope(aspectIds: string[]): Promise<Component[]> {\n    const globalScope = await LegacyScope.ensure(GLOBAL_SCOPE, 'global-scope');\n    await globalScope.ensureDir();\n    const globalScopeHarmony = await loadBit(globalScope.path);\n    const scope = globalScopeHarmony.get<ScopeMain>(ScopeAspect.id);\n    // @todo: Gilad make this work\n    // const ids = await scope.resolveMultipleComponentIds(aspectIds);\n    const ids = aspectIds.map((id) => ComponentID.fromLegacy(BitId.parse(id, true)));\n    const hasVersions = ids.every((id) => id.hasVersion());\n    const useCache = hasVersions; // if all components has versions, try to use the cached aspects\n    const components = await scope.import(ids, useCache, true);\n\n    // don't use `await scope.loadAspectsFromCapsules(components, true);`\n    // it won't work for globalScope because `this !== scope.aspectLoader` (this instance\n    // is not the same as the aspectLoader instance Scope has)\n    const resolvedAspects = await scope.getResolvedAspects(components);\n    try {\n      await this.loadRequireableExtensions(resolvedAspects, true);\n    } catch (err: any) {\n      if (err?.error.code === 'MODULE_NOT_FOUND') {\n        const resolvedAspectsAgain = await scope.getResolvedAspects(components, { skipIfExists: false });\n        await this.loadRequireableExtensions(resolvedAspectsAgain, true);\n      } else {\n        throw err;\n      }\n    }\n\n    return components;\n  }\n\n  private prepareManifests(manifests: Array<ExtensionManifest | Aspect>): Aspect[] {\n    return manifests.map((manifest: any) => {\n      if (this.isAspect(manifest)) return manifest as Aspect;\n      manifest.runtime = MainRuntime;\n      if (!manifest.id) throw new Error('manifest must have static id');\n      const aspect = Aspect.create({\n        id: manifest.id,\n      });\n      aspect.addRuntime(manifest);\n      return aspect;\n    });\n  }\n\n  // TODO: change to use the new logger, see more info at loadExtensions function in the workspace\n  async loadExtensionsByManifests(extensionsManifests: Array<ExtensionManifest | Aspect>, throwOnError = true) {\n    try {\n      const manifests = extensionsManifests.filter((manifest) => {\n        // @ts-ignore TODO: fix this\n        const isValid = this.isAspect(manifest) || manifest.provider;\n        if (!isValid) this.logger.warn(`${manifest.id} is invalid. please make sure the extension is valid.`);\n        return isValid;\n      });\n      const preparedManifests = this.prepareManifests(manifests);\n      // @ts-ignore TODO: fix this\n      await this.harmony.load(preparedManifests);\n    } catch (e: any) {\n      const ids = extensionsManifests.map((manifest) => manifest.id || 'unknown');\n      // TODO: improve texts\n      const warning = UNABLE_TO_LOAD_EXTENSION_FROM_LIST(ids);\n      this.logger.warn(warning, e);\n      if (this.logger.isLoaderStarted) {\n        this.logger.consoleFailure(warning);\n      } else {\n        this.logger.console(warning);\n        this.logger.console(e);\n      }\n      if (throwOnError) {\n        throw e;\n      }\n    }\n  }\n\n  static runtime = MainRuntime;\n  static dependencies = [LoggerAspect, EnvsAspect];\n  static slots = [Slot.withType<OnAspectLoadError>(), Slot.withType<OnLoadRequireableExtension>()];\n\n  static async provider(\n    [loggerExt, envs]: [LoggerMain, EnvsMain],\n    config,\n    [onAspectLoadErrorSlot, onLoadRequireableExtensionSlot]: [OnAspectLoadErrorSlot, OnLoadRequireableExtensionSlot],\n    harmony: Harmony\n  ) {\n    const logger = loggerExt.createLogger(AspectLoaderAspect.id);\n    const aspectLoader = new AspectLoaderMain(\n      logger,\n      envs,\n      harmony,\n      onAspectLoadErrorSlot,\n      onLoadRequireableExtensionSlot\n    );\n    return aspectLoader;\n  }\n}\n\nAspectLoaderAspect.addRuntime(AspectLoaderMain);\n"]}