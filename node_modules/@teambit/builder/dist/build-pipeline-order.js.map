{"version":3,"sources":["build-pipeline-order.ts"],"names":["calculatePipelineOrder","taskSlot","envs","pipeNameOnEnv","tasks","skipTests","graphs","locations","forEach","location","push","graph","Graph","pipelineEnvs","envDefinition","env","getPipe","Error","id","pipeline","getPipelineForEnv","flattenedPipeline","map","pipelineEnv","flat","task","addDependenciesToGraph","dataPerLocation","pipelineEnvsPerLocation","filter","tasksQueue","TasksQueue","addTasksToGraph","length","includes","name","aspectId","TesterAspect","data","find","d","sorted","toposort","taskNode","BuildTaskHelper","deserializeId","attr","taskIndex","findIndex","pipelineTask","splice","dependencies","taskId","serializeId","dependency","dependencyTasks","dependencyTask","getLocation","graphLocation","g","dependencyId","setNode","setEdge","taskLocation","dependencyLocation","isDependencyAhead","isDependencyEqual","buildTasks","slotsTasks","values","tasksAtStart","tasksAtEnd","mergedTasks"],"mappings":"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","sourcesContent":["import { Graph } from 'cleargraph';\nimport TesterAspect from '@teambit/tester';\nimport { EnvDefinition, Environment } from '@teambit/envs';\nimport { BuildTask, BuildTaskHelper } from './build-task';\nimport type { TaskSlot } from './builder.main.runtime';\nimport { TasksQueue } from './tasks-queue';\n\ntype TaskDependenciesGraph = Graph<string, string>;\ntype Location = 'start' | 'middle' | 'end';\ntype TasksLocationGraph = { location: Location; graph: TaskDependenciesGraph };\ntype PipelineEnv = { env: EnvDefinition; pipeline: BuildTask[] };\ntype DataPerLocation = { location: Location; graph: TaskDependenciesGraph; pipelineEnvs: PipelineEnv[] };\n\n/**\n * there are two ways how to add tasks to build pipeline.\n * 1. `getBuildPipe()` method of the env.\n * 2. registering to the `builder.registerBuildTask()`.\n *\n * in the option #1, it's possible to determine the order. e.g. `getBuildPipe() { return [taskA, taskB, taskC]; }`\n * in the option #2, the register happens once the extension is loaded, so there is no way to put\n * one task before/after another task.\n *\n * To be able to determine the order, you can do the following\n * 1. \"task.location\", it has two options \"start\" and \"end\". the rest are \"middle\".\n * 2. \"task.dependencies\", the dependencies must be completed for all envs before this task starts.\n * the dependencies are applicable inside a location and not across locations. see getLocation()\n * or/and continue reading for more info about this.\n *\n * to determine the final order of the tasks, the following is done:\n * 1. split all tasks to three groups: start, middle and end.\n * 2. for each group define a dependencies graph for the tasks with \"dependencies\" prop and the pipeline.\n * 3. start with the first group \"start\", toposort the dependencies graph and push the found tasks\n * to a queue. once completed, iterate the pipeline and add all tasks to the queue.\n * 4. do the same for the \"middle\" and \"end\" groups.\n *\n * the reason for splitting the tasks to the three groups and not using the \"dependencies\" field\n * alone to determine the order is that the \"start\" and \"end\" groups are mostly core and \"middle\"\n * is mostly the user entering tasks to the pipeline and we as the core don't know about the users\n * tasks. For example, a core task \"PublishComponent\" must happen after the compiler, however, a\n * user might have an env without a compiler. if we determine the order only by the dependencies\n * field, the \"PublishComponent\" would have a dependency \"compiler\" and because in this case there\n * is no compiler task, it would throw an error about missing dependencies.\n */\nexport function calculatePipelineOrder(\n  taskSlot: TaskSlot,\n  envs: EnvDefinition[],\n  pipeNameOnEnv = 'getBuildPipe',\n  tasks: string[] = [],\n  skipTests = false\n): TasksQueue {\n  const graphs: TasksLocationGraph[] = [];\n  const locations: Location[] = ['start', 'middle', 'end']; // the order is important here!\n  locations.forEach((location) => {\n    graphs.push({ location, graph: new Graph<string, string>() });\n  });\n  const pipelineEnvs: PipelineEnv[] = [];\n  envs.forEach((envDefinition) => {\n    if (envDefinition.env.getPipe) {\n      // @todo: remove once this confusion is over\n      throw new Error(\n        `Fatal: a breaking API has introduced. Please change \"getPipe()\" method on \"${envDefinition.id}\" to \"getBuildPipe()\"`\n      );\n    }\n    const pipeline = getPipelineForEnv(taskSlot, envDefinition.env, pipeNameOnEnv);\n    pipelineEnvs.push({ env: envDefinition, pipeline });\n  });\n\n  const flattenedPipeline: BuildTask[] = pipelineEnvs.map((pipelineEnv) => pipelineEnv.pipeline).flat();\n  flattenedPipeline.forEach((task) => addDependenciesToGraph(graphs, flattenedPipeline, task));\n\n  const dataPerLocation: DataPerLocation[] = graphs.map(({ location, graph }) => {\n    const pipelineEnvsPerLocation: PipelineEnv[] = pipelineEnvs.map(({ env, pipeline }) => {\n      return { env, pipeline: pipeline.filter((task) => (task.location || 'middle') === location) };\n    });\n    return { location, graph, pipelineEnvs: pipelineEnvsPerLocation };\n  });\n\n  const tasksQueue = new TasksQueue();\n  locations.forEach((location) => addTasksToGraph(tasksQueue, dataPerLocation, location));\n  if (tasks.length) {\n    return new TasksQueue(\n      ...tasksQueue.filter(({ task }) => tasks.includes(task.name) || tasks.includes(task.aspectId))\n    );\n  }\n  if (skipTests) {\n    return new TasksQueue(...tasksQueue.filter(({ task }) => task.aspectId !== TesterAspect.id));\n  }\n  return tasksQueue;\n}\n\nfunction addTasksToGraph(tasksQueue: TasksQueue, dataPerLocation: DataPerLocation[], location: Location) {\n  const data = dataPerLocation.find((d) => d.location === location);\n  if (!data) return;\n  const sorted = data.graph.toposort();\n  sorted.forEach((taskNode) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeId(taskNode.attr);\n    data.pipelineEnvs.forEach(({ env, pipeline }) => {\n      const taskIndex = pipeline.findIndex(\n        (pipelineTask) => pipelineTask.aspectId === aspectId && pipelineTask.name === name\n      );\n      if (taskIndex < 0) return;\n      const task = pipeline[taskIndex];\n      tasksQueue.push({ env, task });\n      pipeline.splice(taskIndex, 1); // delete the task from the pipeline\n    });\n  });\n  data.pipelineEnvs.forEach(({ env, pipeline }) => {\n    pipeline.forEach((task) => tasksQueue.push({ env, task }));\n  });\n}\n\nfunction addDependenciesToGraph(graphs: TasksLocationGraph[], pipeline: BuildTask[], task: BuildTask) {\n  if (!task.dependencies || !task.dependencies.length) return;\n  const taskId = BuildTaskHelper.serializeId(task);\n  task.dependencies.forEach((dependency) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeId(dependency);\n    const dependencyTasks = pipeline.filter((pipelineTask) => {\n      if (pipelineTask.aspectId !== aspectId) return false;\n      return name ? name === pipelineTask.name : true;\n    });\n    if (dependencyTasks.length === 0) {\n      throw new Error(\n        `unable to find dependency \"${dependency}\" of \"${BuildTaskHelper.serializeId(task)}\" in the pipeline`\n      );\n    }\n    dependencyTasks.forEach((dependencyTask) => {\n      const location = getLocation(task, dependencyTask);\n      if (!location) {\n        // the dependency is behind and will be in the correct order regardless the graph.\n        return;\n      }\n      const graphLocation = graphs.find((g) => g.location === location);\n      if (!graphLocation) throw new Error(`unable to find graph for location ${location}`);\n      const dependencyId = BuildTaskHelper.serializeId(dependencyTask);\n      const graph = graphLocation.graph;\n      graph.setNode(taskId, taskId);\n      graph.setNode(dependencyId, dependencyId);\n      graph.setEdge(dependencyId, taskId, 'dependency');\n    });\n  });\n}\n\n/**\n * since the task execution is happening per group: \"start\", \"middle\" and \"end\", the dependencies\n * need to be inside the same group.\n * e.g. if a dependency located at \"end\" group and the task located at \"start\", it's impossible to\n * complete the dependency before the task, there it throws an error.\n * it's ok to have the dependency located earlier, e.g. \"start\" and the task at \"end\", and in this\n * case, it will not be part of the graph because there is no need to do any special calculation.\n */\nfunction getLocation(task: BuildTask, dependencyTask: BuildTask): Location | null {\n  const taskLocation = task.location || 'middle';\n  const dependencyLocation = dependencyTask.location || 'middle';\n\n  const isDependencyAhead =\n    (taskLocation === 'start' && dependencyLocation !== 'start') ||\n    (taskLocation === 'middle' && dependencyLocation === 'end');\n\n  const isDependencyEqual = taskLocation === dependencyLocation;\n\n  if (isDependencyAhead) {\n    throw new Error(`a task \"${BuildTaskHelper.serializeId(task)}\" located at ${taskLocation}\nhas a dependency \"${BuildTaskHelper.serializeId(dependencyTask)} located at ${dependencyLocation},\nwhich is invalid. the dependency must be located earlier or in the same location as the task\"`);\n  }\n\n  if (isDependencyEqual) {\n    return taskLocation;\n  }\n\n  // dependency is behind. e.g. task is \"end\" and dependency is \"start\". no need to enter to the\n  // graph as it's going to be executed in the right order regardless the graph.\n  return null;\n}\n\nfunction getPipelineForEnv(taskSlot: TaskSlot, env: Environment, pipeNameOnEnv: string): BuildTask[] {\n  const buildTasks: BuildTask[] = env[pipeNameOnEnv] ? env[pipeNameOnEnv]() : [];\n  const slotsTasks = taskSlot.values().flat();\n  const tasksAtStart: BuildTask[] = [];\n  const tasksAtEnd: BuildTask[] = [];\n  slotsTasks.forEach((task) => {\n    if (task.location === 'start') {\n      tasksAtStart.push(task);\n      return;\n    }\n    if (task.location === 'end') {\n      tasksAtEnd.push(task);\n      return;\n    }\n    tasksAtStart.push(task);\n  });\n\n  // merge with extension registered tasks.\n  const mergedTasks = [...tasksAtStart, ...buildTasks, ...tasksAtEnd];\n\n  return mergedTasks;\n}\n"]}