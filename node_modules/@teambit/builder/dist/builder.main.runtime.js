"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat-map.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat-map.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuilderMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _aspectLoader() {
  const data = require("@teambit/aspect-loader");

  _aspectLoader = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = require("@teambit/graphql");

  _graphql = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("@teambit/scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = require("@teambit/workspace");

  _workspace = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = require("@teambit/isolator");

  _isolator = function () {
    return data;
  };

  return data;
}

function _artifactFactory() {
  const data = require("./artifact/artifact-factory");

  _artifactFactory = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("./builder.aspect");

  _builder = function () {
    return data;
  };

  return data;
}

function _builder2() {
  const data = require("./builder.graphql");

  _builder2 = function () {
    return data;
  };

  return data;
}

function _builder3() {
  const data = require("./builder.service");

  _builder3 = function () {
    return data;
  };

  return data;
}

function _build() {
  const data = require("./build.cmd");

  _build = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _buildPipelineResultList() {
  const data = require("./build-pipeline-result-list");

  _buildPipelineResultList = function () {
    return data;
  };

  return data;
}

function _artifacts() {
  const data = require("./artifact/artifacts.cmd");

  _artifacts = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class BuilderMain {
  constructor(envs, workspace, buildService, tagService, snapService, scope, isolator, aspectLoader, buildTaskSlot, tagTaskSlot, snapTaskSlot, storageResolversSlot) {
    this.envs = envs;
    this.workspace = workspace;
    this.buildService = buildService;
    this.tagService = tagService;
    this.snapService = snapService;
    this.scope = scope;
    this.isolator = isolator;
    this.aspectLoader = aspectLoader;
    this.buildTaskSlot = buildTaskSlot;
    this.tagTaskSlot = tagTaskSlot;
    this.snapTaskSlot = snapTaskSlot;
    this.storageResolversSlot = storageResolversSlot;
  }

  async storeArtifacts(tasksResults) {
    const artifacts = tasksResults.flatMap(t => t.artifacts ? [t.artifacts] : []);
    const storeP = artifacts.map(async artifactMap => {
      return Promise.all(artifactMap.toArray().map(async ([component, artifactList]) => {
        try {
          return await artifactList.store(component);
        } catch (err) {
          throw new (_exceptions().ArtifactStorageError)(err, component);
        }
      }));
    });
    await Promise.all(storeP);
  }

  pipelineResultsToBuilderData(components, buildPipelineResults) {
    const buildPipelineResultList = new (_buildPipelineResultList().BuildPipelineResultList)(buildPipelineResults, components);
    return _component().ComponentMap.as(components, component => {
      const aspectsData = buildPipelineResultList.getDataOfComponent(component.id);
      const pipelineReport = buildPipelineResultList.getPipelineReportOfComponent(component.id);
      const artifactsData = buildPipelineResultList.getArtifactsDataOfComponent(component.id);
      return {
        pipeline: pipelineReport,
        artifacts: artifactsData,
        aspectsData
      };
    });
  }

  async tagListener(components, options = {}, isolateOptions = {}) {
    const pipeResults = [];
    const {
      throwOnError,
      forceDeploy,
      disableTagAndSnapPipelines,
      isSnap
    } = options;
    const envsExecutionResults = await this.build(components, _objectSpread({
      emptyRootDir: true
    }, isolateOptions), {
      skipTests: options.skipTests
    });
    if (throwOnError && !forceDeploy) envsExecutionResults.throwErrorsIfExist();
    const allTasksResults = [...envsExecutionResults.tasksResults];
    pipeResults.push(envsExecutionResults);

    if (forceDeploy || !disableTagAndSnapPipelines && !envsExecutionResults.hasErrors()) {
      const deployEnvsExecutionResults = isSnap ? await this.runSnapTasks(components, isolateOptions) : await this.runTagTasks(components, isolateOptions);
      if (throwOnError) deployEnvsExecutionResults.throwErrorsIfExist();
      allTasksResults.push(...deployEnvsExecutionResults.tasksResults);
      pipeResults.push(deployEnvsExecutionResults);
    }

    await this.storeArtifacts(allTasksResults);
    const builderDataMap = this.pipelineResultsToBuilderData(components, allTasksResults);
    return {
      builderDataMap,
      pipeResults
    };
  }
  /**
   * register a new storage resolver.
   */


  registerStorageResolver(storageResolver) {
    this.storageResolversSlot.register(storageResolver);
    return this;
  }
  /**
   * get storage resolver by name. otherwise, returns default.
   */


  getStorageResolver(name) {
    return this.storageResolversSlot.values().find(storageResolver => storageResolver.name === name);
  } // TODO: merge with getArtifactsVinylByExtensionAndName by getting aspect name and name as object with optional props


  async getArtifactsVinylByExtension(component, aspectName) {
    const artifactsObjects = this.getArtifactsByExtension(component, aspectName);
    const vinyls = await Promise.all((artifactsObjects || []).map(artifactObject => artifactObject.files.getVinylsAndImportIfMissing(component.id.scope, this.scope.legacyScope)));
    return (0, _lodash().flatten)(vinyls);
  }

  async getArtifactsVinylByExtensionAndName(component, aspectName, name) {
    const artifactsObjects = this.getArtifactsByExtensionAndName(component, aspectName, name);
    const vinyls = await Promise.all((artifactsObjects || []).map(artifactObject => artifactObject.files.getVinylsAndImportIfMissing(component.id.scope, this.scope.legacyScope)));
    return (0, _lodash().flatten)(vinyls);
  }

  getArtifactsByName(component, name) {
    const artifacts = this.getArtifacts(component);
    return artifacts === null || artifacts === void 0 ? void 0 : artifacts.filter(artifact => artifact.name === name);
  }

  getArtifactsByExtension(component, aspectName) {
    const artifacts = this.getArtifacts(component);
    return artifacts === null || artifacts === void 0 ? void 0 : artifacts.filter(artifact => artifact.task.id === aspectName);
  }

  getArtifactsByExtensionAndName(component, aspectName, name) {
    const artifacts = this.getArtifacts(component);
    return artifacts === null || artifacts === void 0 ? void 0 : artifacts.filter(artifact => artifact.task.id === aspectName && artifact.name === name);
  }

  getDataByAspect(component, aspectName) {
    var _this$getBuilderData;

    const aspectsData = (_this$getBuilderData = this.getBuilderData(component)) === null || _this$getBuilderData === void 0 ? void 0 : _this$getBuilderData.aspectsData;
    const data = aspectsData === null || aspectsData === void 0 ? void 0 : aspectsData.find(aspectData => aspectData.aspectId === aspectName);
    return data === null || data === void 0 ? void 0 : data.data;
  }

  getArtifacts(component) {
    var _this$getBuilderData2;

    return (_this$getBuilderData2 = this.getBuilderData(component)) === null || _this$getBuilderData2 === void 0 ? void 0 : _this$getBuilderData2.artifacts;
  }

  getBuilderData(component) {
    var _component$state$aspe;

    return (_component$state$aspe = component.state.aspects.get(_builder().BuilderAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.data;
  }
  /**
   * build given components for release.
   * for each one of the envs it runs a series of tasks.
   * in case of an error in a task, it stops the execution of that env and continue to the next
   * env. at the end, the results contain the data and errors per env.
   */


  async build(components, isolateOptions, builderOptions) {
    const ids = components.map(c => c.id);
    const network = await this.isolator.isolateComponents(ids, isolateOptions);
    const envs = await this.envs.createEnvironment(network.graphCapsules.getAllComponents());

    const builderServiceOptions = _objectSpread({
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly
    }, builderOptions || {});

    const buildResult = await envs.runOnce(this.buildService, builderServiceOptions);
    return buildResult;
  }

  async runTagTasks(components, isolateOptions) {
    const envs = await this.envs.createEnvironment(components);
    const buildResult = await envs.runOnce(this.tagService, {
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly
    });
    return buildResult;
  }

  async runSnapTasks(components, isolateOptions) {
    const envs = await this.envs.createEnvironment(components);
    const buildResult = await envs.runOnce(this.snapService, {
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly
    });
    return buildResult;
  }

  listTasks(component) {
    const compEnv = this.envs.getEnv(component);
    const buildTasks = this.buildService.getDescriptor(compEnv).tasks;
    const tagTasks = this.tagService.getDescriptor(compEnv).tasks;
    const snapTasks = this.snapService.getDescriptor(compEnv).tasks;
    return {
      id: component.id,
      envId: compEnv.id,
      buildTasks,
      tagTasks,
      snapTasks
    };
  }
  /**
   * register a build task to apply on all component build pipelines.
   * build happens on `bit build` and as part of `bit tag --persist`.
   */


  registerBuildTasks(tasks) {
    this.buildTaskSlot.register(tasks);
    return this;
  }
  /**
   * @deprecated use registerTagTasks or registerSnapTasks
   */


  registerDeployTasks(tasks) {
    this.tagTaskSlot.register(tasks);
    return this;
  }
  /**
   * tag tasks that don't get executed on `bit build`, only on `bit tag'.
   * this pipeline is running once the build-pipeline has completed.
   */


  registerTagTasks(tasks) {
    this.tagTaskSlot.register(tasks);
    return this;
  }
  /**
   * tag tasks that don't get executed on `bit build`, only on `bit snap'.
   * this pipeline is running once the build-pipeline has completed.
   */


  registerSnapTasks(tasks) {
    this.snapTaskSlot.register(tasks);
    return this;
  }

  static async provider([cli, envs, workspace, scope, isolator, loggerExt, aspectLoader, graphql], config, [buildTaskSlot, storageResolversSlot, tagTaskSlot, snapTaskSlot]) {
    const artifactFactory = new (_artifactFactory().ArtifactFactory)(storageResolversSlot);
    const logger = loggerExt.createLogger(_builder().BuilderAspect.id);
    const buildService = new (_builder3().BuilderService)(isolator, logger, buildTaskSlot, 'getBuildPipe', 'build', artifactFactory, scope);
    envs.registerService(buildService);
    const tagService = new (_builder3().BuilderService)(isolator, logger, tagTaskSlot, 'getTagPipe', 'tag', artifactFactory, scope);
    const snapService = new (_builder3().BuilderService)(isolator, logger, snapTaskSlot, 'getSnapPipe', 'snap', artifactFactory, scope);
    const builder = new BuilderMain(envs, workspace, buildService, tagService, snapService, scope, isolator, aspectLoader, buildTaskSlot, tagTaskSlot, snapTaskSlot, storageResolversSlot);
    graphql.register((0, _builder2().builderSchema)(builder));
    const func = builder.tagListener.bind(builder);
    if (scope) scope.onTag(func);

    if (workspace && !workspace.consumer.isLegacy) {
      const commands = [new (_build().BuilderCmd)(builder, workspace, logger), new (_artifacts().ArtifactsCmd)(builder, scope)];
      cli.unregister('build');
      cli.register(...commands);
    }

    return builder;
  }

}

exports.BuilderMain = BuilderMain;
(0, _defineProperty2().default)(BuilderMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(BuilderMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(BuilderMain, "dependencies", [_cli().CLIAspect, _envs().EnvsAspect, _workspace().WorkspaceAspect, _scope().ScopeAspect, _isolator().IsolatorAspect, _logger().LoggerAspect, _aspectLoader().AspectLoaderAspect, _graphql().GraphqlAspect, _component().ComponentAspect]);

_builder().BuilderAspect.addRuntime(BuilderMain);

//# sourceMappingURL=builder.main.runtime.js.map