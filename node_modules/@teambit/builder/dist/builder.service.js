"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuilderService = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function () {
    return data;
  };

  return data;
}

function _ink() {
  const data = require("ink");

  _ink = function () {
    return data;
  };

  return data;
}

function _buildPipe() {
  const data = require("./build-pipe");

  _buildPipe = function () {
    return data;
  };

  return data;
}

function _buildTask() {
  const data = require("./build-task");

  _buildTask = function () {
    return data;
  };

  return data;
}

function _buildPipelineOrder() {
  const data = require("./build-pipeline-order");

  _buildPipelineOrder = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("./builder.aspect");

  _builder = function () {
    return data;
  };

  return data;
}

class BuilderService {
  constructor(
  /**
   * isolator extension.
   */
  isolator,
  /**
   * logger extension.
   */
  logger,
  /**
   * task slot (e.g tasks registered by other extensions.).
   */
  taskSlot,
  /**
   * a method with such name should be implemented on the env in order to run the pipe tasks.
   */
  pipeNameOnEnv,
  /**
   * pipe name to display on the console during the execution
   */
  displayPipeName, artifactFactory, scope) {
    this.isolator = isolator;
    this.logger = logger;
    this.taskSlot = taskSlot;
    this.pipeNameOnEnv = pipeNameOnEnv;
    this.displayPipeName = displayPipeName;
    this.artifactFactory = artifactFactory;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'builder');
  }
  /**
   * runs all tasks for all envs
   */


  async runOnce(envsExecutionContext, options) {
    const envs = envsExecutionContext.map(executionContext => executionContext.envDefinition);
    const tasksQueue = (0, _buildPipelineOrder().calculatePipelineOrder)(this.taskSlot, envs, this.pipeNameOnEnv, options.tasks, options.skipTests);
    tasksQueue.validate();
    this.logger.info(`going to run tasks in the following order:\n${tasksQueue.toString()}`);
    const title = `running ${this.displayPipeName} pipe for ${envs.length} environments, total ${tasksQueue.length} tasks`;
    const longProcessLogger = this.logger.createLongProcessLogger(title);
    this.logger.consoleTitle(title);
    const envsBuildContext = {};
    await Promise.all(envsExecutionContext.map(async executionContext => {
      const componentIds = executionContext.components.map(component => component.id);
      const capsuleNetwork = await this.isolator.isolateComponents(componentIds, {
        getExistingAsIs: true,
        seedersOnly: options.seedersOnly
      });
      this.logger.console(`generated graph for env "${executionContext.id}", seeders total: ${capsuleNetwork.seedersCapsules.length}, graph total: ${capsuleNetwork.graphCapsules.length}`);
      const buildContext = Object.assign(executionContext, {
        capsuleNetwork,
        previousTasksResults: []
      });
      envsBuildContext[executionContext.id] = buildContext;
    }));

    const buildPipe = _buildPipe().BuildPipe.from(tasksQueue, envsBuildContext, this.logger, this.artifactFactory);

    const buildResults = await buildPipe.execute();
    longProcessLogger.end();
    buildResults.hasErrors() ? this.logger.consoleFailure() : this.logger.consoleSuccess();
    return buildResults;
  }

  render(env) {
    const tasksQueue = this.getDescriptor(env);
    return /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: _builder().BuilderAspect.id
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, {
      color: "cyan"
    }, "total ", tasksQueue.tasks.length, " tasks are configured to be executed in the following order"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), tasksQueue.tasks.map((task, index) => /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: index
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, null, index + 1, ". ", task), /*#__PURE__*/_react().default.createElement(_ink().Newline, null))), /*#__PURE__*/_react().default.createElement(_ink().Newline, null));
  }

  getDescriptor(env) {
    const tasksQueue = (0, _buildPipelineOrder().calculatePipelineOrder)(this.taskSlot, [env], this.pipeNameOnEnv);
    return {
      tasks: tasksQueue.map(({
        task
      }) => _buildTask().BuildTaskHelper.serializeId(task))
    };
  }

}

exports.BuilderService = BuilderService;

//# sourceMappingURL=builder.service.js.map