{"version":3,"sources":["builder.service.tsx"],"names":["BuilderService","constructor","isolator","logger","taskSlot","pipeNameOnEnv","displayPipeName","artifactFactory","scope","runOnce","envsExecutionContext","options","envs","map","executionContext","envDefinition","tasksQueue","tasks","skipTests","validate","info","toString","title","length","longProcessLogger","createLongProcessLogger","consoleTitle","envsBuildContext","Promise","all","componentIds","components","component","id","capsuleNetwork","isolateComponents","getExistingAsIs","seedersOnly","console","seedersCapsules","graphCapsules","buildContext","Object","assign","previousTasksResults","buildPipe","BuildPipe","from","buildResults","execute","end","hasErrors","consoleFailure","consoleSuccess","render","env","getDescriptor","BuilderAspect","task","index","BuildTaskHelper","serializeId"],"mappings":"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","sourcesContent":["import { EnvDefinition, EnvService, ExecutionContext } from '@teambit/envs';\nimport React from 'react';\nimport { ScopeMain } from '@teambit/scope';\nimport { Text, Newline } from 'ink';\nimport { Logger } from '@teambit/logger';\nimport { IsolatorMain } from '@teambit/isolator';\nimport { Component } from '@teambit/component';\nimport { BuildPipe } from './build-pipe';\nimport { TaskResultsList } from './task-results-list';\nimport { TaskSlot } from './builder.main.runtime';\nimport { BuildContext, BuildTaskHelper } from './build-task';\nimport { ArtifactFactory } from './artifact';\nimport { calculatePipelineOrder } from './build-pipeline-order';\nimport { BuilderAspect } from './builder.aspect';\n\nexport type BuildServiceResults = {\n  id: string;\n  buildResults: TaskResultsList;\n  components: Component[];\n  errors?: [];\n};\n\nexport type BuilderServiceOptions = { seedersOnly?: boolean; tasks?: string[]; skipTests?: boolean };\n\nexport type BuilderDescriptor = { tasks: string[] };\n\nexport type EnvsBuildContext = { [envId: string]: BuildContext };\n\nexport class BuilderService implements EnvService<BuildServiceResults, BuilderDescriptor> {\n  name = 'builder';\n\n  constructor(\n    /**\n     * isolator extension.\n     */\n    private isolator: IsolatorMain,\n\n    /**\n     * logger extension.\n     */\n    private logger: Logger,\n\n    /**\n     * task slot (e.g tasks registered by other extensions.).\n     */\n    private taskSlot: TaskSlot,\n\n    /**\n     * a method with such name should be implemented on the env in order to run the pipe tasks.\n     */\n    private pipeNameOnEnv: 'getBuildPipe' | 'getTagPipe' | 'getSnapPipe',\n\n    /**\n     * pipe name to display on the console during the execution\n     */\n    private displayPipeName: string,\n    private artifactFactory: ArtifactFactory,\n    private scope: ScopeMain\n  ) {}\n\n  /**\n   * runs all tasks for all envs\n   */\n  async runOnce(envsExecutionContext: ExecutionContext[], options: BuilderServiceOptions): Promise<TaskResultsList> {\n    const envs = envsExecutionContext.map((executionContext) => executionContext.envDefinition);\n    const tasksQueue = calculatePipelineOrder(\n      this.taskSlot,\n      envs,\n      this.pipeNameOnEnv,\n      options.tasks,\n      options.skipTests\n    );\n    tasksQueue.validate();\n    this.logger.info(`going to run tasks in the following order:\\n${tasksQueue.toString()}`);\n    const title = `running ${this.displayPipeName} pipe for ${envs.length} environments, total ${tasksQueue.length} tasks`;\n    const longProcessLogger = this.logger.createLongProcessLogger(title);\n    this.logger.consoleTitle(title);\n    const envsBuildContext: EnvsBuildContext = {};\n    await Promise.all(\n      envsExecutionContext.map(async (executionContext) => {\n        const componentIds = executionContext.components.map((component) => component.id);\n        const capsuleNetwork = await this.isolator.isolateComponents(componentIds, {\n          getExistingAsIs: true,\n          seedersOnly: options.seedersOnly,\n        });\n        this.logger.console(\n          `generated graph for env \"${executionContext.id}\", seeders total: ${capsuleNetwork.seedersCapsules.length}, graph total: ${capsuleNetwork.graphCapsules.length}`\n        );\n        const buildContext = Object.assign(executionContext, {\n          capsuleNetwork,\n          previousTasksResults: [],\n        });\n        envsBuildContext[executionContext.id] = buildContext;\n      })\n    );\n    const buildPipe = BuildPipe.from(tasksQueue, envsBuildContext, this.logger, this.artifactFactory);\n    const buildResults = await buildPipe.execute();\n    longProcessLogger.end();\n    buildResults.hasErrors() ? this.logger.consoleFailure() : this.logger.consoleSuccess();\n\n    return buildResults;\n  }\n\n  render(env: EnvDefinition) {\n    const tasksQueue = this.getDescriptor(env);\n\n    return (\n      <Text key={BuilderAspect.id}>\n        <Text color=\"cyan\">\n          total {tasksQueue.tasks.length} tasks are configured to be executed in the following order\n        </Text>\n        <Newline />\n        {tasksQueue.tasks.map((task, index) => (\n          <Text key={index}>\n            <Text>\n              {index + 1}. {task}\n            </Text>\n            <Newline />\n          </Text>\n        ))}\n        <Newline />\n      </Text>\n    );\n  }\n\n  getDescriptor(env: EnvDefinition) {\n    const tasksQueue = calculatePipelineOrder(this.taskSlot, [env], this.pipeNameOnEnv);\n    return { tasks: tasksQueue.map(({ task }) => BuildTaskHelper.serializeId(task)) };\n  }\n}\n"]}