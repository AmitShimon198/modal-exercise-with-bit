"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DevServerService = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _componentServer() {
  const data = require("./component-server");

  _componentServer = function () {
    return data;
  };

  return data;
}

function _dedupEnvs() {
  const data = require("./dedup-envs");

  _dedupEnvs = function () {
    return data;
  };

  return data;
}

function _getEntry() {
  const data = require("./get-entry");

  _getEntry = function () {
    return data;
  };

  return data;
}

class DevServerService {
  constructor(
  /**
   * browser runtime slot
   */
  pubsub,
  /**
   * browser runtime slot
   */
  runtimeSlot) {
    this.pubsub = pubsub;
    this.runtimeSlot = runtimeSlot;
    (0, _defineProperty2().default)(this, "name", 'dev server');
  } // async run(context: ExecutionContext): Promise<ComponentServer[]> {
  //   const devServerContext = await this.buildContext(context);
  //   const devServer: DevServer = context.env.getDevServer(devServerContext);
  //   const port = await selectPort();
  //   // TODO: refactor to replace with a component server instance.
  //   return new ComponentServer(this.pubsub, context, port, devServer);
  // }


  async runOnce(contexts, {
    dedicatedEnvDevServers
  }) {
    const groupedEnvs = (0, _dedupEnvs().dedupEnvs)(contexts, dedicatedEnvDevServers);
    const servers = await Promise.all(Object.entries(groupedEnvs).map(async ([id, contextList]) => {
      const mainContext = contextList.find(context => context.envDefinition.id === id) || contextList[0];
      const additionalContexts = contextList.filter(context => context.envDefinition.id !== id);
      const devServerContext = await this.buildContext(mainContext, additionalContexts);
      const devServer = await devServerContext.envRuntime.env.getDevServer(devServerContext);
      return new (_componentServer().ComponentServer)(this.pubsub, devServerContext, [3300, 3400], devServer);
    }));
    return servers;
  }

  mergeContext() {}

  getComponentsFromContexts(contexts) {
    return (0, _lodash().flatten)(contexts.map(context => {
      return context.components;
    }));
  }
  /**
   * builds the execution context for the dev server.
   */


  async buildContext(context, additionalContexts = []) {
    context.relatedContexts = additionalContexts.map(ctx => ctx.envDefinition.id);
    context.components = context.components.concat(this.getComponentsFromContexts(additionalContexts));
    return Object.assign(context, {
      entry: await (0, _getEntry().getEntry)(context, this.runtimeSlot),
      // don't start with a leading "/" because it generates errors on Windows
      rootPath: `preview/${context.envRuntime.id}`,
      publicPath: `/public`
    });
  }

}

exports.DevServerService = DevServerService;

//# sourceMappingURL=dev-server.service.js.map