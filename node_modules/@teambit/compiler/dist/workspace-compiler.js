"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceCompiler = exports.ComponentCompiler = void 0;

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _compiler() {
  const data = require("./compiler.aspect");

  _compiler = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("./events");

  _events = function () {
    return data;
  };

  return data;
}

/* eslint-disable max-classes-per-file */
class ComponentCompiler {
  constructor(pubsub, workspace, component, compilerInstance, compilerId, dists = [], compileErrors = []) {
    this.pubsub = pubsub;
    this.workspace = workspace;
    this.component = component;
    this.compilerInstance = compilerInstance;
    this.compilerId = compilerId;
    this.dists = dists;
    this.compileErrors = compileErrors;
  }

  async compile(noThrow = true, options) {
    let dataToPersist; // delete dist folder before transpilation (because some compilers (like ngPackagr) can generate files there during the compilation process)

    if (options.deleteDistDir) {
      dataToPersist = new (_dataToPersist().default)();
      dataToPersist.removePath(new (_removePath().default)(this.distDir));
      dataToPersist.addBasePath(this.workspace.path);
      await dataToPersist.persistAllToFS();
    }

    if (this.compilerInstance.transpileFile) {
      await Promise.all(this.component.files.map(file => this.compileOneFileWithNewCompiler(file)));
    } else if (this.compilerInstance.transpileComponent) {
      await this.compileAllFilesWithNewCompiler(this.component);
    } else {
      throw new Error(`compiler ${this.compilerId.toString()} doesn't implement either "transpileFile" or "transpileComponent" methods`);
    }

    this.throwOnCompileErrors(noThrow); // writing the dists with `component.setDists(dists); component.dists.writeDists` is tricky
    // as it uses other base-paths and doesn't respect the new node-modules base path.

    dataToPersist = new (_dataToPersist().default)();
    dataToPersist.addManyFiles(this.dists);
    dataToPersist.addBasePath(this.workspace.path);
    await dataToPersist.persistAllToFS();
    const buildResults = this.dists.map(distFile => distFile.path);
    if (this.component.compiler) _loader().default.succeed();
    this.pubsub.pub(_compiler().CompilerAspect.id, new (_events().ComponentCompilationOnDoneEvent)(this.compileErrors, this.component, buildResults));
    return {
      component: this.component.id.toString(),
      buildResults
    };
  }

  throwOnCompileErrors(noThrow = true) {
    if (this.compileErrors.length) {
      this.compileErrors.forEach(errorItem => {
        _logger().default.error(`compilation error at ${errorItem.path}`, errorItem.error);
      });

      const formatError = errorItem => `${errorItem.path}\n${errorItem.error}`;

      const err = new Error(`compilation failed. see the following errors from the compiler
${this.compileErrors.map(formatError).join('\n')}`);
      this.pubsub.pub(_compiler().CompilerAspect.id, new (_events().CompilerErrorEvent)(err));

      if (!noThrow) {
        throw err;
      }

      _logger().default.console(err.message);
    }
  }

  get distDir() {
    const packageName = (0, _componentIdToPackageName().default)(this.component);

    const packageDir = _path().default.join('node_modules', packageName);

    const distDirName = _constants().DEFAULT_DIST_DIRNAME;

    return _path().default.join(packageDir, distDirName);
  }

  get componentDir() {
    return this.workspace.componentDir(new (_component().ComponentID)(this.component.id));
  }

  async compileOneFileWithNewCompiler(file) {
    const options = {
      componentDir: this.componentDir,
      filePath: file.relative
    };
    const isFileSupported = this.compilerInstance.isFileSupported(file.path);
    let compileResults;

    if (isFileSupported) {
      try {
        var _this$compilerInstanc, _this$compilerInstanc2;

        compileResults = (_this$compilerInstanc = (_this$compilerInstanc2 = this.compilerInstance).transpileFile) === null || _this$compilerInstanc === void 0 ? void 0 : _this$compilerInstanc.call(_this$compilerInstanc2, file.contents.toString(), options);
      } catch (error) {
        this.compileErrors.push({
          path: file.path,
          error
        });
        return;
      }
    }

    const base = this.distDir;

    if (isFileSupported && compileResults) {
      this.dists.push(...compileResults.map(result => new (_sources().Dist)({
        base,
        path: _path().default.join(base, result.outputPath),
        contents: Buffer.from(result.outputText)
      })));
    } else if (this.compilerInstance.shouldCopyNonSupportedFiles) {
      // compiler doesn't support this file type. copy the file as is to the dist dir.
      this.dists.push(new (_sources().Dist)({
        base,
        path: _path().default.join(base, file.relative),
        contents: file.contents
      }));
    }
  }

  async compileAllFilesWithNewCompiler(component) {
    const base = this.distDir;
    const filesToCompile = [];
    component.files.forEach(file => {
      const isFileSupported = this.compilerInstance.isFileSupported(file.path);

      if (isFileSupported) {
        filesToCompile.push(file);
      } else if (this.compilerInstance.shouldCopyNonSupportedFiles) {
        // compiler doesn't support this file type. copy the file as is to the dist dir.
        this.dists.push(new (_sources().Dist)({
          base,
          path: _path().default.join(base, file.relative),
          contents: file.contents
        }));
      }
    });

    if (filesToCompile.length) {
      try {
        var _this$compilerInstanc3, _this$compilerInstanc4;

        await ((_this$compilerInstanc3 = (_this$compilerInstanc4 = this.compilerInstance).transpileComponent) === null || _this$compilerInstanc3 === void 0 ? void 0 : _this$compilerInstanc3.call(_this$compilerInstanc4, {
          component,
          componentDir: this.componentDir,
          outputDir: this.workspace.getComponentPackagePath(component)
        }));
      } catch (error) {
        this.compileErrors.push({
          path: this.componentDir,
          error
        });
      }
    }
  }

}

exports.ComponentCompiler = ComponentCompiler;

class WorkspaceCompiler {
  constructor(workspace, envs, pubsub, aspectLoader, ui) {
    this.workspace = workspace;
    this.envs = envs;
    this.pubsub = pubsub;
    this.aspectLoader = aspectLoader;
    this.ui = ui;

    if (this.workspace) {
      this.workspace.registerOnComponentChange(this.onComponentChange.bind(this));
      this.workspace.registerOnComponentAdd(this.onComponentChange.bind(this));
      this.ui.registerPreStart(this.onPreStart.bind(this));
    }

    if (this.aspectLoader) {
      this.aspectLoader.registerOnAspectLoadErrorSlot(this.onAspectLoadFail.bind(this));
    }
  }

  async onPreStart(preStartOpts) {
    if (preStartOpts.skipCompilation) {
      return;
    }

    await this.compileComponents([], {
      changed: true,
      verbose: false,
      deleteDistDir: false
    });
  }

  async onAspectLoadFail(err, id) {
    if (err.code && err.code === 'MODULE_NOT_FOUND' && this.workspace) {
      await this.compileComponents([id.toString()], {}, true);
      return true;
    }

    return false;
  }

  async onComponentChange(component) {
    const buildResults = await this.compileComponents([component.id.toString()], {}, true);
    return {
      results: buildResults,

      toString() {
        var _buildResults$, _buildResults$$buildR;

        return `${(_buildResults$ = buildResults[0]) === null || _buildResults$ === void 0 ? void 0 : (_buildResults$$buildR = _buildResults$.buildResults) === null || _buildResults$$buildR === void 0 ? void 0 : _buildResults$$buildR.join('\n\t')}`;
      }

    };
  }

  async compileComponents(componentsIds, // when empty, it compiles new+modified (unless options.all is set),
  options, noThrow) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    if (this.workspace.isLegacy) throw new Error('workspace-compiler should work for Harmony workspace only');
    const componentIds = await this.getIdsToCompile(componentsIds, options.changed);
    const components = await this.workspace.getMany(componentIds);
    const componentsAndNewCompilers = [];
    components.forEach(c => {
      var _environment$getCompi, _c$state$_consumer$co;

      const environment = this.envs.getEnv(c).env;
      const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment); // if there is no componentDir (e.g. author that added files, not dir), then we can't write the dists
      // inside the component dir.

      if (compilerInstance && (_c$state$_consumer$co = c.state._consumer.componentMap) !== null && _c$state$_consumer$co !== void 0 && _c$state$_consumer$co.getComponentDir()) {
        const compilerName = compilerInstance.constructor.name || 'compiler';
        componentsAndNewCompilers.push(new ComponentCompiler(this.pubsub, this.workspace, c.state._consumer, compilerInstance, compilerName));
      }
    });
    const newCompilersResultOnWorkspace = await (0, _pMapSeries().default)(componentsAndNewCompilers, componentAndNewCompilers => componentAndNewCompilers.compile(noThrow, options));
    return newCompilersResultOnWorkspace;
  }

  async getIdsToCompile(componentsIds, changed = false) {
    if (componentsIds.length) {
      return this.workspace.resolveMultipleComponentIds(componentsIds);
    }

    if (changed) {
      return this.workspace.getNewAndModifiedIds();
    }

    return this.workspace.getAllComponentIds();
  }

}

exports.WorkspaceCompiler = WorkspaceCompiler;

//# sourceMappingURL=workspace-compiler.js.map