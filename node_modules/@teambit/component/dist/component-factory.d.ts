import { BitId } from '@teambit/legacy-bit-id';
import LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import type { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';
import type { AspectDefinition } from '@teambit/aspect-loader';
import { ComponentID } from '@teambit/component-id';
import { Component, InvalidComponent } from './component';
import { State } from './state';
import { Snap } from './snap';
export interface ComponentFactory {
    name: string;
    path: string;
    isLegacy: boolean;
    resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;
    resolveMultipleComponentIds(ids: (string | ComponentID | BitId)[]): Promise<ComponentID[]>;
    get(id: ComponentID | string, withState?: boolean, consumerComponent?: ConsumerComponent): Promise<Component | undefined>;
    getMany(ids: ComponentID[]): Promise<Component[]>;
    getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;
    getRemoteComponent?: (id: ComponentID) => Promise<Component>;
    getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph>;
    getLogs(id: ComponentID): Promise<ComponentLog[]>;
    getState(id: ComponentID, snapId: string): Promise<State>;
    getSnap(id: ComponentID, snapId: string): Promise<Snap>;
    loadAspects: (ids: string[], throwOnError: boolean) => Promise<void>;
    resolveAspects: (runtimeName?: string, componentIds?: ComponentID[]) => Promise<AspectDefinition[]>;
    list(filter?: {
        offset: number;
        limit: number;
    }): Promise<Component[]>;
    listInvalid(): Promise<InvalidComponent[]>;
    listIds(): Promise<ComponentID[]>;
    hasId(componentId: ComponentID): Promise<boolean>;
    hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    priority?: boolean;
}
