{"version":3,"sources":["component.ts"],"names":["Component","constructor","id","head","_state","tags","TagMap","factory","state","config","filesystem","buildStatus","_consumer","headTag","undefined","byHash","hash","latest","getLatest","err","CouldNotFindLatest","toString","stringify","JSON","displayName","tokens","name","split","map","token","join","tag","version","isModified","Promise","resolve","isOutdated","latestTag","byVersion","isNew","loadState","snapId","getState","loadSnap","snapToGet","BitError","getSnap","snapsIterable","options","snapToStart","nextSnaps","done","iterator","next","value","currSnapId","shift","snap","parents","length","firstParentOnly","push","concat","stopFn","Symbol","asyncIterator","getClosestTag","snapToStartFrom","tagsHashMap","getHashMap","has","iterable","snaps","hashOfLastSnap","get","checkout","write","path","fs","equals","component"],"mappings":"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","sourcesContent":["import { AnyFS } from '@teambit/any-fs';\nimport { capitalize } from '@teambit/toolbox.string.capitalize';\nimport { SemVer } from 'semver';\nimport { ComponentID } from '@teambit/component-id';\nimport { BitError } from '@teambit/bit-error';\nimport { BuildStatus } from '@teambit/legacy/dist/constants';\n\nimport { ComponentFactory } from './component-factory';\nimport ComponentFS from './component-fs';\n// import { NothingToSnap } from './exceptions';\nimport ComponentConfig from './config';\n// eslint-disable-next-line import/no-cycle\nimport { Snap } from './snap';\nimport { State } from './state';\nimport { TagMap } from './tag-map';\nimport { Tag } from './tag';\nimport { CouldNotFindLatest } from './exceptions';\n// import { Author } from './types';\n\ntype SnapsIterableOpts = {\n  firstParentOnly?: boolean;\n  stopFn?: (snap: Snap) => Promise<boolean>;\n};\n\nexport type InvalidComponent = { id: ComponentID; err: Error };\n\n/**\n * in-memory representation of a component.\n */\nexport class Component {\n  constructor(\n    /**\n     * component ID represented by the `ComponentId` type.\n     */\n    readonly id: ComponentID,\n\n    /**\n     * head version of the component. can be `null` for new components.\n     */\n    readonly head: Snap | null = null,\n\n    /**\n     * state of the component.\n     */\n    private _state: State,\n\n    /**\n     * tags of the component.\n     */\n    readonly tags: TagMap = new TagMap(),\n\n    /**\n     * the component factory\n     */\n    private factory: ComponentFactory\n  ) {}\n\n  get state(): State {\n    return this._state;\n  }\n\n  set state(state: State) {\n    this._state = state;\n  }\n\n  /**\n   * component configuration which is later generated to a component `package.json` and `bit.json`.\n   */\n  get config(): ComponentConfig {\n    return this.state.config;\n  }\n\n  /**\n   * in-memory representation of the component current filesystem.\n   */\n  get filesystem(): ComponentFS {\n    return this.state.filesystem;\n  }\n\n  /**\n   * build status of the component\n   */\n  get buildStatus(): BuildStatus {\n    return this._state._consumer.buildStatus;\n  }\n\n  get headTag() {\n    if (!this.head) return undefined;\n    return this.tags.byHash(this.head.hash);\n  }\n\n  get latest(): string | undefined {\n    if (!this.head) return undefined;\n    try {\n      return this.tags.getLatest();\n    } catch (err: any) {\n      if (err instanceof CouldNotFindLatest) {\n        return this.head.toString();\n      }\n      throw err;\n    }\n  }\n\n  stringify(): string {\n    return JSON.stringify({\n      id: this.id,\n      head: this.head,\n    });\n  }\n\n  /**\n   * record component changes in the `Scope`.\n   */\n  // snap(author: Author, message = '') {\n  // if (!this.isModified()) throw new NothingToSnap();\n  // const snap = new Snap(this, author, message);\n\n  // return new Component(this.id, snap, snap.state);\n  // }\n\n  /**\n   * display name of the component.\n   */\n  get displayName() {\n    const tokens = this.id.name.split('-').map((token) => capitalize(token));\n    return tokens.join(' ');\n  }\n\n  /**\n   * tag a component `Snap` with a semantic version. we follow SemVer specs as defined [here](https://semver.org/)).\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  tag(version: SemVer) {\n    // const snap = this.snap();\n    // const tag = new Tag(version, snap);\n    // this.tags.set(tag);\n  }\n\n  /**\n   * determines whether this component is modified in the workspace.\n   */\n  isModified(): Promise<boolean> {\n    if (!this.head) return Promise.resolve(true);\n    return Promise.resolve(this.state.isModified);\n    // return Promise.resolve(this.state.hash !== this.head.hash);\n  }\n\n  /**\n   * is component isOutdated\n   */\n  isOutdated(): boolean {\n    if (!this.latest) return false;\n    const latestTag = this.tags.byVersion(this.latest);\n    if (!latestTag) return false;\n    if (this.head?.hash !== latestTag?.hash) return true;\n    return false;\n  }\n\n  /**\n   * determines whether this component is new.\n   */\n  isNew(): Promise<boolean> {\n    return Promise.resolve(this.head === null);\n  }\n\n  // TODO: @david after snap we need to make sure to refactor here.\n  loadState(snapId: string): Promise<State> {\n    return this.factory.getState(this.id, snapId);\n  }\n\n  loadSnap(snapId?: string): Promise<Snap> {\n    const snapToGet = snapId || this.head?.hash;\n    if (!snapToGet) {\n      throw new BitError('could not load snap for new components');\n    }\n    return this.factory.getSnap(this.id, snapToGet);\n  }\n\n  /**\n   * Get iterable which iterate over snap parents lazily\n   * @param snapId\n   * @param options\n   */\n  snapsIterable(snapId?: string, options: SnapsIterableOpts = {}): AsyncIterable<Snap> {\n    const snapToStart = snapId || this.head?.hash;\n    let nextSnaps = [snapToStart];\n    let done;\n    if (!snapToStart) {\n      done = true;\n    }\n\n    const iterator: AsyncIterator<Snap> = {\n      next: async () => {\n        if (done) {\n          return { value: undefined, done };\n        }\n        const currSnapId = nextSnaps.shift();\n        const snap = await this.loadSnap(currSnapId);\n        if (snap.parents && snap.parents.length) {\n          if (options.firstParentOnly) {\n            nextSnaps.push(snap.parents[0]);\n          } else {\n            nextSnaps = nextSnaps.concat(snap.parents);\n          }\n        }\n        if (!nextSnaps.length) {\n          done = true;\n        } else if (options.stopFn) {\n          done = await options.stopFn(snap);\n        }\n        return { value: snap, done: undefined };\n      },\n    };\n    return {\n      [Symbol.asyncIterator]: () => iterator,\n    };\n  }\n\n  /**\n   * traverse recursively from the provided snap (or head) upwards until it finds a tag\n   * @param snapToStartFrom\n   */\n  async getClosestTag(snapToStartFrom?: string): Promise<Tag | undefined> {\n    const tagsHashMap = this.tags.getHashMap();\n    const stopFn = async (snap: Snap) => {\n      if (tagsHashMap.has(snap.hash)) {\n        return true;\n      }\n      return false;\n    };\n    const iterable = this.snapsIterable(snapToStartFrom, { firstParentOnly: true, stopFn });\n    const snaps: Snap[] = [];\n    for await (const snap of iterable) {\n      snaps.push(snap);\n    }\n    if (snaps.length) {\n      const hashOfLastSnap = snaps[snaps.length - 1].hash;\n      return tagsHashMap.get(hashOfLastSnap);\n    }\n    return undefined;\n  }\n\n  /**\n   * checkout the component to a different version in its working tree.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  checkout(version: SemVer) {}\n\n  /**\n   * examine difference between two components.\n   */\n  // diff(other: Component): Difference {}\n\n  /**\n   * merge two different components\n   */\n  // merge(other: Component): Component {}\n\n  /**\n   * write a component to a given file system.\n   * @param path root path to write the component\n   * @param fs instance of any fs to use.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  write(path: string, fs?: AnyFS) {}\n\n  /**\n   *\n   * Check if 2 components are equal\n   * @param {Component} component\n   * @returns {boolean}\n   * @memberof Component\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  equals(component: Component): boolean {\n    return component.id.toString() === this.id.toString();\n  }\n}\n"]}