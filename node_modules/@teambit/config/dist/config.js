"use strict";

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Config = void 0;

function _workspaceConfig() {
  const data = require("./workspace-config");

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

class Config {
  constructor(workspaceConfig, scopeConfig) {
    this.workspaceConfig = workspaceConfig;
    this.scopeConfig = scopeConfig;
  } // constructor(private props: ConfigProps) {}


  get type() {
    if (this.workspaceConfig) {
      return 'workspace';
    }

    return 'scope';
  }

  get path() {
    var _this$config;

    return (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.path;
  }

  get config() {
    if (this.workspaceConfig) {
      return this.workspaceConfig;
    }

    return this.scopeConfig;
  }

  static async loadIfExist(dirPath) {
    const workspaceConfig = await _workspaceConfig().WorkspaceConfig.loadIfExist(dirPath);

    if (workspaceConfig) {
      return new Config(workspaceConfig);
    } // TODO: try load scope config here
    // return undefined;
    // TODO: change to return a maybe type


    return {}; // return new Config(workspaceConfig, 'workspace');
  }
  /**
   * Ensure the given directory has a workspace config
   * Load if existing and create new if not
   *
   * @static
   * @param {PathOsBasedAbsolute} dirPath
   * @param {WorkspaceConfigFileProps} [workspaceConfigProps={} as any]
   * @returns {Promise<WorkspaceConfig>}
   * @memberof WorkspaceConfig
   */


  static async ensureWorkspace(dirPath, workspaceConfigProps = {}, legacyInitProps) {
    const workspaceConfig = await _workspaceConfig().WorkspaceConfig.ensure(dirPath, workspaceConfigProps, legacyInitProps);
    return new Config(workspaceConfig);
  }

  get extensions() {
    var _this$config2;

    return (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2.extensions;
  }

  extension(extensionId, ignoreVersion) {
    var _this$config3;

    return (_this$config3 = this.config) === null || _this$config3 === void 0 ? void 0 : _this$config3.extension(extensionId, ignoreVersion);
  }

  setExtension(extensionId, config, options) {
    var _this$config4;

    (_this$config4 = this.config) === null || _this$config4 === void 0 ? void 0 : _this$config4.setExtension(extensionId, config, options);
  }

  getHarmonyConfigObject() {
    const config = {};
    if (!this.extensions) return config;
    this.extensions.forEach(extension => {
      config[extension.stringId] = extension.config;
    });
    return config;
  }

}

exports.Config = Config;

//# sourceMappingURL=config.js.map