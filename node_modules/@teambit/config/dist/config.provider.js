"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = provideConfig;

function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/config/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _workspaceConfig() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/workspace-config"));

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("./config");

  _config = function () {
    return data;
  };

  return data;
}

function _invalidConfigFile() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-file"));

  _invalidConfigFile = function () {
    return data;
  };

  return data;
}

function _workspaceConfig2() {
  const data = require("./workspace-config");

  _workspaceConfig2 = function () {
    return data;
  };

  return data;
}

async function provideConfig() {
  _workspaceConfig().default.registerOnWorkspaceConfigIsExist(onLegacyWorkspaceConfigIsExist());

  _workspaceConfig().default.registerOnWorkspaceConfigEnsuring(onLegacyWorkspaceEnsure());

  const consumerInfo = await (0, _consumer().getConsumerInfo)(process.cwd());
  const config = await tryToGetConfig((consumerInfo === null || consumerInfo === void 0 ? void 0 : consumerInfo.path) || process.cwd());

  _workspaceConfig().default.registerOnWorkspaceConfigLoading(onLegacyWorkspaceLoad(config));

  return config;
} // This is used to handle cases where the user run bit init --reset / --reset-hard
// during this time we don't yet know if the user ask for init reset so we catch it here
// other places should handle cases when there is no config
// TODO: change the {} to some maybe type


async function tryToGetConfig(dirPath) {
  try {
    const config = await _config().Config.loadIfExist(dirPath);
    return config;
  } catch (err) {
    if (!(err instanceof _exceptions().InvalidBitJson) && !(err instanceof _invalidConfigFile().default)) {
      throw err;
    }

    return {};
  }
}

function onLegacyWorkspaceConfigIsExist() {
  return async dirPath => {
    return _workspaceConfig2().WorkspaceConfig.isExist(dirPath);
  };
}

function onLegacyWorkspaceLoad(config) {
  return async dirPath => {
    if (config !== null && config !== void 0 && config.workspaceConfig && config.path && _path().default.normalize(dirPath) === _path().default.dirname(config.path)) {
      return config.config.toLegacy();
    }

    const newConfig = await _config().Config.loadIfExist(dirPath);

    if (newConfig && newConfig.type === 'workspace') {
      return newConfig.config.toLegacy();
    }

    return undefined;
  };
}

function onLegacyWorkspaceEnsure() {
  const func = async (dirPath, standAlone = false, legacyWorkspaceConfigProps) => {
    let workspaceConfigProps;

    if (legacyWorkspaceConfigProps) {
      workspaceConfigProps = (0, _workspaceConfig2().transformLegacyPropsToExtensions)(legacyWorkspaceConfigProps);
    }

    const legacyInitProps = {
      standAlone
    };
    const config = await _config().Config.ensureWorkspace(dirPath, workspaceConfigProps, legacyInitProps);
    const workspaceConfig = config.config;
    return workspaceConfig.toLegacy();
  };

  return func;
}

//# sourceMappingURL=config.provider.js.map