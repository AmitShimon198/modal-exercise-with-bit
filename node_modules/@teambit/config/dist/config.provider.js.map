{"version":3,"sources":["config.provider.ts"],"names":["provideConfig","LegacyWorkspaceConfig","registerOnWorkspaceConfigIsExist","onLegacyWorkspaceConfigIsExist","registerOnWorkspaceConfigEnsuring","onLegacyWorkspaceEnsure","consumerInfo","process","cwd","config","tryToGetConfig","path","registerOnWorkspaceConfigLoading","onLegacyWorkspaceLoad","dirPath","Config","loadIfExist","err","InvalidBitJson","InvalidConfigFile","WorkspaceConfig","isExist","workspaceConfig","normalize","dirname","toLegacy","newConfig","type","undefined","func","standAlone","legacyWorkspaceConfigProps","workspaceConfigProps","legacyInitProps","ensureWorkspace"],"mappings":";;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMe,eAAeA,aAAf,GAA+B;AAC5CC,6BAAsBC,gCAAtB,CAAuDC,8BAA8B,EAArF;;AACAF,6BAAsBG,iCAAtB,CAAwDC,uBAAuB,EAA/E;;AACA,QAAMC,YAAY,GAAG,MAAM,iCAAgBC,OAAO,CAACC,GAAR,EAAhB,CAA3B;AACA,QAAMC,MAAc,GAAG,MAAMC,cAAc,CAAC,CAAAJ,YAAY,SAAZ,IAAAA,YAAY,WAAZ,YAAAA,YAAY,CAAEK,IAAd,KAAsBJ,OAAO,CAACC,GAAR,EAAvB,CAA3C;;AACAP,6BAAsBW,gCAAtB,CAAuDC,qBAAqB,CAACJ,MAAD,CAA5E;;AACA,SAAOA,MAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,eAAeC,cAAf,CAA8BI,OAA9B,EAAsE;AACpE,MAAI;AACF,UAAML,MAAc,GAAG,MAAMM,iBAAOC,WAAP,CAAmBF,OAAnB,CAA7B;AACA,WAAOL,MAAP;AACD,GAHD,CAGE,OAAOQ,GAAP,EAAiB;AACjB,QAAI,EAAEA,GAAG,YAAYC,4BAAjB,KAAoC,EAAED,GAAG,YAAYE,4BAAjB,CAAxC,EAA6E;AAC3E,YAAMF,GAAN;AACD;;AACD,WAAO,EAAP;AACD;AACF;;AAED,SAASd,8BAAT,GAA0E;AACxE,SAAO,MAAOW,OAAP,IAA8D;AACnE,WAAOM,oCAAgBC,OAAhB,CAAwBP,OAAxB,CAAP;AACD,GAFD;AAGD;;AAED,SAASD,qBAAT,CAA+BJ,MAA/B,EAA6E;AAC3E,SAAO,MAAOK,OAAP,IAA6E;AAClF,QAAIL,MAAM,SAAN,IAAAA,MAAM,WAAN,IAAAA,MAAM,CAAEa,eAAR,IAA2Bb,MAAM,CAACE,IAAlC,IAA0CA,gBAAKY,SAAL,CAAeT,OAAf,MAA4BH,gBAAKa,OAAL,CAAaf,MAAM,CAACE,IAApB,CAA1E,EAAqG;AACnG,aAAQF,MAAM,CAACA,MAAR,CAAmCgB,QAAnC,EAAP;AACD;;AACD,UAAMC,SAAS,GAAG,MAAMX,iBAAOC,WAAP,CAAmBF,OAAnB,CAAxB;;AACA,QAAIY,SAAS,IAAIA,SAAS,CAACC,IAAV,KAAmB,WAApC,EAAiD;AAC/C,aAAQD,SAAS,CAACjB,MAAX,CAAsCgB,QAAtC,EAAP;AACD;;AACD,WAAOG,SAAP;AACD,GATD;AAUD;;AAED,SAASvB,uBAAT,GAAkE;AAChE,QAAMwB,IAAmC,GAAG,OAC1Cf,OAD0C,EAE1CgB,UAAU,GAAG,KAF6B,EAG1CC,0BAH0C,KAIvC;AACH,QAAIC,oBAAJ;;AACA,QAAID,0BAAJ,EAAgC;AAC9BC,MAAAA,oBAAoB,GAAG,0DAAiCD,0BAAjC,CAAvB;AACD;;AACD,UAAME,eAAgC,GAAG;AACvCH,MAAAA;AADuC,KAAzC;AAGA,UAAMrB,MAAM,GAAG,MAAMM,iBAAOmB,eAAP,CAAuBpB,OAAvB,EAAgCkB,oBAAhC,EAAsDC,eAAtD,CAArB;AACA,UAAMX,eAAe,GAAGb,MAAM,CAACA,MAA/B;AACA,WAAQa,eAAD,CAAqCG,QAArC,EAAP;AACD,GAfD;;AAgBA,SAAOI,IAAP;AACD","sourcesContent":["import { getConsumerInfo } from '@teambit/legacy/dist/consumer';\nimport { ILegacyWorkspaceConfig, LegacyWorkspaceConfigProps } from '@teambit/legacy/dist/consumer/config';\nimport { InvalidBitJson } from '@teambit/legacy/dist/consumer/config/exceptions';\nimport LegacyWorkspaceConfig, {\n  WorkspaceConfigEnsureFunction,\n  WorkspaceConfigIsExistFunction,\n  WorkspaceConfigLoadFunction,\n} from '@teambit/legacy/dist/consumer/config/workspace-config';\nimport { PathOsBased } from '@teambit/legacy/dist/utils/path';\nimport path from 'path';\n\nimport { Config } from './config';\nimport InvalidConfigFile from './exceptions/invalid-config-file';\nimport { LegacyInitProps, transformLegacyPropsToExtensions, WorkspaceConfig } from './workspace-config';\n\nexport type ConfigDeps = [];\n\nexport type ConfigConfig = {};\n\nexport default async function provideConfig() {\n  LegacyWorkspaceConfig.registerOnWorkspaceConfigIsExist(onLegacyWorkspaceConfigIsExist());\n  LegacyWorkspaceConfig.registerOnWorkspaceConfigEnsuring(onLegacyWorkspaceEnsure());\n  const consumerInfo = await getConsumerInfo(process.cwd());\n  const config: Config = await tryToGetConfig(consumerInfo?.path || process.cwd());\n  LegacyWorkspaceConfig.registerOnWorkspaceConfigLoading(onLegacyWorkspaceLoad(config));\n  return config;\n}\n\n// This is used to handle cases where the user run bit init --reset / --reset-hard\n// during this time we don't yet know if the user ask for init reset so we catch it here\n// other places should handle cases when there is no config\n// TODO: change the {} to some maybe type\nasync function tryToGetConfig(dirPath: string): Promise<Config | any> {\n  try {\n    const config: Config = await Config.loadIfExist(dirPath);\n    return config;\n  } catch (err: any) {\n    if (!(err instanceof InvalidBitJson) && !(err instanceof InvalidConfigFile)) {\n      throw err;\n    }\n    return {};\n  }\n}\n\nfunction onLegacyWorkspaceConfigIsExist(): WorkspaceConfigIsExistFunction {\n  return async (dirPath: PathOsBased): Promise<boolean | undefined> => {\n    return WorkspaceConfig.isExist(dirPath);\n  };\n}\n\nfunction onLegacyWorkspaceLoad(config?: Config): WorkspaceConfigLoadFunction {\n  return async (dirPath: PathOsBased): Promise<ILegacyWorkspaceConfig | undefined> => {\n    if (config?.workspaceConfig && config.path && path.normalize(dirPath) === path.dirname(config.path)) {\n      return (config.config as WorkspaceConfig).toLegacy();\n    }\n    const newConfig = await Config.loadIfExist(dirPath);\n    if (newConfig && newConfig.type === 'workspace') {\n      return (newConfig.config as WorkspaceConfig).toLegacy();\n    }\n    return undefined;\n  };\n}\n\nfunction onLegacyWorkspaceEnsure(): WorkspaceConfigEnsureFunction {\n  const func: WorkspaceConfigEnsureFunction = async (\n    dirPath: string,\n    standAlone = false,\n    legacyWorkspaceConfigProps?: LegacyWorkspaceConfigProps\n  ) => {\n    let workspaceConfigProps;\n    if (legacyWorkspaceConfigProps) {\n      workspaceConfigProps = transformLegacyPropsToExtensions(legacyWorkspaceConfigProps);\n    }\n    const legacyInitProps: LegacyInitProps = {\n      standAlone,\n    };\n    const config = await Config.ensureWorkspace(dirPath, workspaceConfigProps, legacyInitProps);\n    const workspaceConfig = config.config;\n    return (workspaceConfig as WorkspaceConfig).toLegacy();\n  };\n  return func;\n}\n"]}