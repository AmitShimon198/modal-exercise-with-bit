{"version":3,"sources":["workspace-manifest-factory.ts"],"names":["DEFAULT_CREATE_OPTIONS","filterComponentsFromManifests","createManifestForComponentsWithoutDependencies","dedupe","WorkspaceManifestFactory","constructor","dependencyResolver","createFromComponents","name","version","rootPolicy","rootDir","components","options","optsWithDefaults","Object","assign","componentDependenciesMap","buildComponentDependenciesMap","dependencyFilterFn","dedupedDependencies","rootDependencies","toManifest","componentsManifestsMap","getComponentsManifests","workspaceManifest","WorkspaceManifest","buildResultsP","map","component","packageName","state","_consumer","depList","getDependencies","componentPolicy","getPolicy","filterComponents","filterResolvedFromEnv","filter","dep","id","updateDependenciesVersions","depManifest","toDependenciesManifest","result","Map","length","results","Promise","all","forEach","currResult","set","dependencyList","mergedPolicies","mergeVariantPolicies","config","extensions","updateDependencyVersion","componentsToFilterOut","filtered","ComponentDependency","componentId","hasVersion","existingComponent","find","toString","ignoreVersion","_legacy","isEqual","fromPolicy","value","resolveFromEnv","dependency","variantPolicy","getPackageName","variantVersion","getDepVersion","lifecycle","variantVersionWithoutMinus","undefined","setVersion","componentsManifests","has","blankDependencies","dependencies","devDependencies","peerDependencies","get","getVersion","isVersionSnap","manifest","ComponentManifest","SemVer"],"mappings":";;;;;;;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAgBA,MAAMA,sBAAmD,GAAG;AAC1DC,EAAAA,6BAA6B,EAAE,IAD2B;AAE1DC,EAAAA,8CAA8C,EAAE,IAFU;AAG1DC,EAAAA,MAAM,EAAE;AAHkD,CAA5D;;AAKO,MAAMC,wBAAN,CAA+B;AACpCC,EAAAA,WAAW,CAASC,kBAAT,EAAqD;AAAA,SAA5CA,kBAA4C,GAA5CA,kBAA4C;AAAE;;AAExC,QAApBC,oBAAoB,CACxBC,IADwB,EAExBC,OAFwB,EAGxBC,UAHwB,EAIxBC,OAJwB,EAKxBC,UALwB,EAMxBC,OAAoC,GAAGb,sBANf,EAOI;AAC5B;AACA,UAAMc,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBhB,sBAAlB,EAA0Ca,OAA1C,CAAzB;AACA,UAAMI,wBAAkD,GAAG,MAAM,KAAKC,6BAAL,CAC/DN,UAD+D,EAE/DE,gBAAgB,CAACb,6BAF8C,EAG/DS,UAH+D,EAI/DI,gBAAgB,CAACK,kBAJ8C,CAAjE;AAMA,QAAIC,mBAAmB,GAAG,8CAA1B;;AACA,QAAIP,OAAO,CAACV,MAAZ,EAAoB;AAClBiB,MAAAA,mBAAmB,GAAG,oCAAmBV,UAAnB,EAA+BO,wBAA/B,CAAtB;AACD,KAFD,MAEO;AACLG,MAAAA,mBAAmB,CAACC,gBAApB,GAAuCX,UAAU,CAACY,UAAX,EAAvC;AACAF,MAAAA,mBAAmB,CAACH,wBAApB,GAA+CA,wBAA/C;AACD;;AACD,UAAMM,sBAAsB,GAAGC,sBAAsB,CACnDJ,mBADmD,EAEnDR,UAFmD,EAGnDE,gBAAgB,CAACZ,8CAHkC,CAArD;AAKA,UAAMuB,iBAAiB,GAAG,KAAIC,sCAAJ,EACxBlB,IADwB,EAExBC,OAFwB,EAGxBW,mBAAmB,CAACC,gBAHI,EAIxBV,OAJwB,EAKxBY,sBALwB,CAA1B;AAOA,WAAOE,iBAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAC6C,QAA7BP,6BAA6B,CACzCN,UADyC,EAEzCX,6BAA6B,GAAG,IAFS,EAGzCS,UAHyC,EAIzCS,kBAJyC,EAKN;AACnC,UAAMQ,aAAa,GAAGf,UAAU,CAACgB,GAAX,CAAe,MAAOC,SAAP,IAAqB;AACxD,YAAMC,WAAW,GAAG,yCAAyBD,SAAS,CAACE,KAAV,CAAgBC,SAAzC,CAApB;AACA,UAAIC,OAAO,GAAG,MAAM,KAAK3B,kBAAL,CAAwB4B,eAAxB,CAAwCL,SAAxC,CAApB;AACA,YAAMM,eAAe,GAAG,MAAM,KAAK7B,kBAAL,CAAwB8B,SAAxB,CAAkCP,SAAlC,CAA9B;;AACA,UAAI5B,6BAAJ,EAAmC;AACjCgC,QAAAA,OAAO,GAAGI,gBAAgB,CAACJ,OAAD,EAAUrB,UAAV,CAA1B;AACD;;AACDqB,MAAAA,OAAO,GAAGK,qBAAqB,CAACL,OAAD,EAAUE,eAAV,CAA/B,CAPwD,CAQxD;;AACAF,MAAAA,OAAO,GAAGA,OAAO,CAACM,MAAR,CAAgBC,GAAD,IAASA,GAAG,CAACC,EAAJ,KAAW,iBAAnC,CAAV;;AACA,UAAItB,kBAAJ,EAAwB;AACtBc,QAAAA,OAAO,GAAGd,kBAAkB,CAACc,OAAD,CAA5B;AACD;;AACD,YAAM,KAAKS,0BAAL,CAAgCb,SAAhC,EAA2CnB,UAA3C,EAAuDuB,OAAvD,CAAN;AACA,YAAMU,WAAW,GAAG,MAAMV,OAAO,CAACW,sBAAR,EAA1B;AAEA,aAAO;AAAEd,QAAAA,WAAF;AAAea,QAAAA;AAAf,OAAP;AACD,KAjBqB,CAAtB;AAkBA,UAAME,MAAM,GAAG,IAAIC,GAAJ,EAAf;;AAEA,QAAInB,aAAa,CAACoB,MAAlB,EAA0B;AACxB,YAAMC,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYvB,aAAZ,CAAtB;AACAqB,MAAAA,OAAO,CAACG,OAAR,CAAiBC,UAAD,IAAgB;AAC9BP,QAAAA,MAAM,CAACQ,GAAP,CAAWD,UAAU,CAACtB,WAAtB,EAAmCsB,UAAU,CAACT,WAA9C;AACD,OAFD;AAGD;;AAED,WAAOE,MAAP;AACD;;AAEuC,QAA1BH,0BAA0B,CACtCb,SADsC,EAEtCnB,UAFsC,EAGtC4C,cAHsC,EAIvB;AACf,UAAMC,cAAc,GAAG,MAAM,KAAKjD,kBAAL,CAAwBkD,oBAAxB,CAA6C3B,SAAS,CAAC4B,MAAV,CAAiBC,UAA9D,CAA7B;AACAJ,IAAAA,cAAc,CAACH,OAAf,CAAwBX,GAAD,IAAS;AAC9BmB,MAAAA,uBAAuB,CAACnB,GAAD,EAAM9B,UAAN,EAAkB6C,cAAlB,CAAvB;AACD,KAFD;AAGD;;AA7FmC;;;;AAgGtC,SAASlB,gBAAT,CAA0BiB,cAA1B,EAA0DM,qBAA1D,EAA8G;AAC5G,QAAMC,QAAQ,GAAGP,cAAc,CAACf,MAAf,CAAuBC,GAAD,IAAS;AAC9C;AACA,QAAI,EAAEA,GAAG,YAAYsB,mCAAjB,CAAJ,EAA2C;AACzC,aAAO,IAAP;AACD,KAJ6C,CAK9C;;;AACA,QAAI,CAACtB,GAAG,CAACuB,WAAJ,CAAgBC,UAAhB,EAAL,EAAmC,OAAO,KAAP;AACnC,UAAMC,iBAAiB,GAAGL,qBAAqB,CAACM,IAAtB,CAA4BrC,SAAD,IAAe;AAClE;AACA,UAAI,CAACA,SAAS,CAACY,EAAV,CAAauB,UAAb,EAAL,EAAgC;AAC9B,eAAOnC,SAAS,CAACY,EAAV,CAAa0B,QAAb,OAA4B3B,GAAG,CAACuB,WAAJ,CAAgBI,QAAhB,CAAyB;AAAEC,UAAAA,aAAa,EAAE;AAAjB,SAAzB,CAAnC;AACD,OAJiE,CAKlE;AACA;AACA;AACA;;;AACA,aACEvC,SAAS,CAACY,EAAV,CAAa4B,OAAb,CAAqBC,OAArB,CAA6B9B,GAAG,CAACuB,WAAJ,CAAgBM,OAA7C,KACAxC,SAAS,CAACE,KAAV,CAAgBC,SAAhB,CAA0BS,EAA1B,CAA6B6B,OAA7B,CAAqC9B,GAAG,CAACuB,WAAJ,CAAgBM,OAArD,CAFF;AAID,KAbyB,CAA1B;AAcA,QAAIJ,iBAAJ,EAAuB,OAAO,KAAP;AACvB,WAAO,IAAP;AACD,GAvBgB,CAAjB;AAwBA,SAAOJ,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASvB,qBAAT,CAA+BgB,cAA/B,EAA+DnB,eAA/D,EAA+G;AAC7G,QAAM0B,QAAQ,GAAGP,cAAc,CAACf,MAAf,CAAuBC,GAAD,IAAS;AAC9C,UAAM+B,UAAU,GAAGpC,eAAe,CAAC+B,IAAhB,CAAqB1B,GAAG,CAACC,EAAzB,CAAnB;;AACA,QAAI,CAAC8B,UAAL,EAAiB;AACf,aAAO,IAAP;AACD;;AACD,QAAIA,UAAU,CAACC,KAAX,CAAiBC,cAArB,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD,GATgB,CAAjB;AAUA,SAAOZ,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,CACEe,UADF,EAEEhE,UAFF,EAGEiE,aAHF,EAIQ;AACN,MAAID,UAAU,CAACE,cAAf,EAA+B;AAC7B,UAAM9C,WAAW,GAAG4C,UAAU,CAACE,cAAX,EAApB;AACA,UAAMC,cAAc,GAAGF,aAAa,CAACG,aAAd,CAA4BhD,WAA5B,EAAyC4C,UAAU,CAACK,SAApD,CAAvB;AACA,UAAMC,0BAA0B,GAAGH,cAAc,IAAIA,cAAc,KAAK,GAArC,GAA2CA,cAA3C,GAA4DI,SAA/F;AACA,UAAMxE,OAAO,GACXuE,0BAA0B,IAC1BtE,UAAU,CAACoE,aAAX,CAAyBhD,WAAzB,EAAsC4C,UAAU,CAACK,SAAjD,CADA,IAEAL,UAAU,CAACjE,OAFX,IAGA,WAJF;AAKAiE,IAAAA,UAAU,CAACQ,UAAX,CAAsBzE,OAAtB;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,sBAAT,CACEJ,mBADF,EAEER,UAFF,EAGEV,8CAA8C,GAAG,IAHnD,EAI0B;AACxB,QAAMiF,mBAA2C,GAAG,IAAIrC,GAAJ,EAApD;AACAlC,EAAAA,UAAU,CAACuC,OAAX,CAAoBtB,SAAD,IAAe;AAChC,UAAMC,WAAW,GAAG,yCAAyBD,SAAS,CAACE,KAAV,CAAgBC,SAAzC,CAApB;;AACA,QACEZ,mBAAmB,CAACH,wBAApB,CAA6CmE,GAA7C,CAAiDtD,WAAjD,KACA5B,8CAFF,EAGE;AACA,YAAMmF,iBAA6C,GAAG;AACpDC,QAAAA,YAAY,EAAE,EADsC;AAEpDC,QAAAA,eAAe,EAAE,EAFmC;AAGpDC,QAAAA,gBAAgB,EAAE;AAHkC,OAAtD;AAKA,UAAIF,YAAY,GAAGD,iBAAnB;;AACA,UAAIjE,mBAAmB,CAACH,wBAApB,CAA6CmE,GAA7C,CAAiDtD,WAAjD,CAAJ,EAAmE;AACjEwD,QAAAA,YAAY,GAAGlE,mBAAmB,CAACH,wBAApB,CAA6CwE,GAA7C,CAAiD3D,WAAjD,CAAf;AACD;;AAED,YAAM4D,UAAU,GAAG,MAAc;AAC/B,YAAI,CAAC7D,SAAS,CAACY,EAAV,CAAauB,UAAb,EAAL,EAAgC,OAAO,WAAP;AAChC,YAAInC,SAAS,CAACY,EAAV,CAAa4B,OAAb,CAAqBsB,aAArB,EAAJ,EAA0C,OAAQ,SAAQ9D,SAAS,CAACY,EAAV,CAAahC,OAAQ,EAArC;AAC1C,eAAOoB,SAAS,CAACY,EAAV,CAAahC,OAApB;AACD,OAJD;;AAMA,YAAMA,OAAO,GAAGiF,UAAU,EAA1B;AACA,YAAME,QAAQ,GAAG,KAAIC,sCAAJ,EAAsB/D,WAAtB,EAAmC,KAAIgE,gBAAJ,EAAWrF,OAAX,CAAnC,EAAwD6E,YAAxD,EAAsEzD,SAAtE,CAAjB;AACAsD,MAAAA,mBAAmB,CAAC9B,GAApB,CAAwBvB,WAAxB,EAAqC8D,QAArC;AACD;AACF,GA1BD;AA2BA,SAAOT,mBAAP;AACD","sourcesContent":["import { Component } from '@teambit/component';\nimport componentIdToPackageName from '@teambit/legacy/dist/utils/bit/component-id-to-package-name';\nimport { SemVer } from 'semver';\nimport { ComponentDependency, DependencyList, Dependency, PackageName } from '../dependencies';\nimport { VariantPolicy, WorkspacePolicy } from '../policy';\n\nimport { DependencyResolverMain } from '../dependency-resolver.main.runtime';\nimport { ComponentsManifestsMap } from '../types';\nimport { ComponentManifest } from './component-manifest';\nimport { DedupedDependencies, dedupeDependencies, getEmptyDedupedDependencies } from './deduping';\nimport { ManifestToJsonOptions, ManifestDependenciesObject } from './manifest';\nimport { WorkspaceManifest } from './workspace-manifest';\n\nexport type DepsFilterFn = (dependencies: DependencyList) => DependencyList;\n\nexport type ComponentDependenciesMap = Map<PackageName, ManifestDependenciesObject>;\nexport interface WorkspaceManifestToJsonOptions extends ManifestToJsonOptions {\n  includeDir?: boolean;\n}\n\nexport type CreateFromComponentsOptions = {\n  filterComponentsFromManifests: boolean;\n  createManifestForComponentsWithoutDependencies: boolean;\n  dedupe?: boolean;\n  dependencyFilterFn?: DepsFilterFn;\n};\n\nconst DEFAULT_CREATE_OPTIONS: CreateFromComponentsOptions = {\n  filterComponentsFromManifests: true,\n  createManifestForComponentsWithoutDependencies: true,\n  dedupe: true,\n};\nexport class WorkspaceManifestFactory {\n  constructor(private dependencyResolver: DependencyResolverMain) {}\n\n  async createFromComponents(\n    name: string,\n    version: SemVer,\n    rootPolicy: WorkspacePolicy,\n    rootDir: string,\n    components: Component[],\n    options: CreateFromComponentsOptions = DEFAULT_CREATE_OPTIONS\n  ): Promise<WorkspaceManifest> {\n    // Make sure to take other default if passed options with only one option\n    const optsWithDefaults = Object.assign({}, DEFAULT_CREATE_OPTIONS, options);\n    const componentDependenciesMap: ComponentDependenciesMap = await this.buildComponentDependenciesMap(\n      components,\n      optsWithDefaults.filterComponentsFromManifests,\n      rootPolicy,\n      optsWithDefaults.dependencyFilterFn\n    );\n    let dedupedDependencies = getEmptyDedupedDependencies();\n    if (options.dedupe) {\n      dedupedDependencies = dedupeDependencies(rootPolicy, componentDependenciesMap);\n    } else {\n      dedupedDependencies.rootDependencies = rootPolicy.toManifest();\n      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;\n    }\n    const componentsManifestsMap = getComponentsManifests(\n      dedupedDependencies,\n      components,\n      optsWithDefaults.createManifestForComponentsWithoutDependencies\n    );\n    const workspaceManifest = new WorkspaceManifest(\n      name,\n      version,\n      dedupedDependencies.rootDependencies,\n      rootDir,\n      componentsManifestsMap\n    );\n    return workspaceManifest;\n  }\n\n  /**\n   * Get the components and build a map with the package name (from the component) as key and the dependencies as values\n   *\n   * @param {Component[]} components\n   * @param {boolean} [filterComponentsFromManifests=true] - filter existing components from the dep graphs\n   * @returns\n   */\n  private async buildComponentDependenciesMap(\n    components: Component[],\n    filterComponentsFromManifests = true,\n    rootPolicy: WorkspacePolicy,\n    dependencyFilterFn?: DepsFilterFn\n  ): Promise<ComponentDependenciesMap> {\n    const buildResultsP = components.map(async (component) => {\n      const packageName = componentIdToPackageName(component.state._consumer);\n      let depList = await this.dependencyResolver.getDependencies(component);\n      const componentPolicy = await this.dependencyResolver.getPolicy(component);\n      if (filterComponentsFromManifests) {\n        depList = filterComponents(depList, components);\n      }\n      depList = filterResolvedFromEnv(depList, componentPolicy);\n      // Remove bit bin from dep list\n      depList = depList.filter((dep) => dep.id !== '@teambit/legacy');\n      if (dependencyFilterFn) {\n        depList = dependencyFilterFn(depList);\n      }\n      await this.updateDependenciesVersions(component, rootPolicy, depList);\n      const depManifest = await depList.toDependenciesManifest();\n\n      return { packageName, depManifest };\n    });\n    const result = new Map<PackageName, ManifestDependenciesObject>();\n\n    if (buildResultsP.length) {\n      const results = await Promise.all(buildResultsP);\n      results.forEach((currResult) => {\n        result.set(currResult.packageName, currResult.depManifest);\n      });\n    }\n\n    return result;\n  }\n\n  private async updateDependenciesVersions(\n    component: Component,\n    rootPolicy: WorkspacePolicy,\n    dependencyList: DependencyList\n  ): Promise<void> {\n    const mergedPolicies = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);\n    dependencyList.forEach((dep) => {\n      updateDependencyVersion(dep, rootPolicy, mergedPolicies);\n    });\n  }\n}\n\nfunction filterComponents(dependencyList: DependencyList, componentsToFilterOut: Component[]): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    // Do not filter non components (like packages) dependencies\n    if (!(dep instanceof ComponentDependency)) {\n      return true;\n    }\n    // Remove dependencies which has no version (they are new in the workspace)\n    if (!dep.componentId.hasVersion()) return false;\n    const existingComponent = componentsToFilterOut.find((component) => {\n      // For new components, the component has no version but the dependency id has version 0.0.1\n      if (!component.id.hasVersion()) {\n        return component.id.toString() === dep.componentId.toString({ ignoreVersion: true });\n      }\n      // We are checking against both component.id._legacy and component.state._consumer.id\n      // Because during tag operation, the component.id._legacy has the current version (before the tag)\n      // while the component.state._consumer.id has the upcoming version (the version that will be after the tag)\n      // The dependency in some cases is already updated to the upcoming version\n      return (\n        component.id._legacy.isEqual(dep.componentId._legacy) ||\n        component.state._consumer.id.isEqual(dep.componentId._legacy)\n      );\n    });\n    if (existingComponent) return false;\n    return true;\n  });\n  return filtered;\n}\n\n/**\n * Filter deps which should be resolved from the env, we don't want to install them, they will be linked manually later\n * @param dependencyList\n * @param componentPolicy\n */\nfunction filterResolvedFromEnv(dependencyList: DependencyList, componentPolicy: VariantPolicy): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    const fromPolicy = componentPolicy.find(dep.id);\n    if (!fromPolicy) {\n      return true;\n    }\n    if (fromPolicy.value.resolveFromEnv) {\n      return false;\n    }\n    return true;\n  });\n  return filtered;\n}\n\n/**\n * This will create a function that will modify the version of the component dependencies before calling the package manager install\n * It's important for this use case:\n * between 2 bit components we are not allowing a range, only a specific version as dependency\n * therefor, when resolve a component dependency we take the version from the actual installed version in the file system\n * imagine the following case\n * I have in my policy my-dep:0.0.10\n * during installation it is installed (hoisted to the root)\n * now i'm changing it to be ^0.0.11\n * On the next bit install, when I will look at the component deps I'll see it with version 0.0.10 always (that's resolved from the FS)\n * so the version ^0.0.11 will be never installed.\n * For installation purpose we want a different resolve method, we want to take the version from the policies so we will install the correct one\n * this function will get the root deps / policy, and a function to merge the component policies (by the dep resolver extension).\n * it will then search for the dep version in the component policy, than in the workspace policy and take it from there\n * now in the described case, it will be change to ^0.0.11 and will be install correctly\n * then on the next calculation for tagging it will have the installed version\n *\n * @param {Component} component\n * @param {ManifestDependenciesObject} rootDependencies\n * @param {MergeDependenciesFunc} mergeDependenciesFunc\n * @returns {DepVersionModifierFunc}\n */\nfunction updateDependencyVersion(\n  dependency: Dependency,\n  rootPolicy: WorkspacePolicy,\n  variantPolicy: VariantPolicy\n): void {\n  if (dependency.getPackageName) {\n    const packageName = dependency.getPackageName();\n    const variantVersion = variantPolicy.getDepVersion(packageName, dependency.lifecycle);\n    const variantVersionWithoutMinus = variantVersion && variantVersion !== '-' ? variantVersion : undefined;\n    const version =\n      variantVersionWithoutMinus ||\n      rootPolicy.getDepVersion(packageName, dependency.lifecycle) ||\n      dependency.version ||\n      '0.0.1-new';\n    dependency.setVersion(version);\n  }\n}\n\n/**\n * Get the components manifests based on the calculated dedupedDependencies\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {Component[]} components\n * @returns {ComponentsManifestsMap}\n */\nfunction getComponentsManifests(\n  dedupedDependencies: DedupedDependencies,\n  components: Component[],\n  createManifestForComponentsWithoutDependencies = true\n): ComponentsManifestsMap {\n  const componentsManifests: ComponentsManifestsMap = new Map();\n  components.forEach((component) => {\n    const packageName = componentIdToPackageName(component.state._consumer);\n    if (\n      dedupedDependencies.componentDependenciesMap.has(packageName) ||\n      createManifestForComponentsWithoutDependencies\n    ) {\n      const blankDependencies: ManifestDependenciesObject = {\n        dependencies: {},\n        devDependencies: {},\n        peerDependencies: {},\n      };\n      let dependencies = blankDependencies;\n      if (dedupedDependencies.componentDependenciesMap.has(packageName)) {\n        dependencies = dedupedDependencies.componentDependenciesMap.get(packageName) as ManifestDependenciesObject;\n      }\n\n      const getVersion = (): string => {\n        if (!component.id.hasVersion()) return '0.0.1-new';\n        if (component.id._legacy.isVersionSnap()) return `0.0.1-${component.id.version}`;\n        return component.id.version as string;\n      };\n\n      const version = getVersion();\n      const manifest = new ComponentManifest(packageName, new SemVer(version), dependencies, component);\n      componentsManifests.set(packageName, manifest);\n    }\n  });\n  return componentsManifests;\n}\n"]}