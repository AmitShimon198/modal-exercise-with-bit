"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentGenerator = void 0;

function _vinyl() {
  const data = _interopRequireDefault(require("vinyl"));

  _vinyl = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _camelcase() {
  const data = _interopRequireDefault(require("camelcase"));

  _camelcase = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _composeComponentPath() {
  const data = require("@teambit/legacy/dist/utils/bit/compose-component-path");

  _composeComponentPath = function () {
    return data;
  };

  return data;
}

class ComponentGenerator {
  constructor(workspace, componentIds, options, template, envs) {
    this.workspace = workspace;
    this.componentIds = componentIds;
    this.options = options;
    this.template = template;
    this.envs = envs;
  }

  async generate() {
    const dirsToDeleteIfFailed = [];
    const generateResults = await (0, _pMapSeries().default)(this.componentIds, async componentId => {
      try {
        const componentPath = this.getComponentPath(componentId);

        if (_fsExtra().default.existsSync(_path().default.join(this.workspace.path, componentPath))) {
          throw new (_bitError().BitError)(`unable to create a component at "${componentPath}", this path already exist`);
        }

        if (await this.workspace.hasName(componentId.fullName)) {
          throw new (_bitError().BitError)(`unable to create a component "${componentId.fullName}", a component with the same name already exist`);
        }

        dirsToDeleteIfFailed.push(componentPath);
        return await this.generateOneComponent(componentId, componentPath);
      } catch (err) {
        await this.deleteGeneratedComponents(dirsToDeleteIfFailed);
        throw err;
      }
    });
    await this.workspace.writeBitMap();
    return generateResults;
  }

  async deleteGeneratedComponents(dirs) {
    await Promise.all(dirs.map(async dir => {
      const absoluteDir = _path().default.join(this.workspace.path, dir);

      try {
        await _fsExtra().default.remove(absoluteDir);
      } catch (err) {
        if (err.code !== 'ENOENT') {
          // if not exist, it's fine
          throw err;
        }
      }
    }));
  }

  async generateOneComponent(componentId, componentPath) {
    const name = componentId.name;
    const namePascalCase = (0, _camelcase().default)(name, {
      pascalCase: true
    });
    const nameCamelCase = (0, _camelcase().default)(name);
    const files = this.template.generateFiles({
      name,
      namePascalCase,
      nameCamelCase,
      componentId
    });
    const mainFile = files.find(file => file.isMain);
    await this.writeComponentFiles(componentPath, files);
    const addResults = await this.workspace.track({
      rootDir: componentPath,
      mainFile: mainFile === null || mainFile === void 0 ? void 0 : mainFile.relativePath,
      componentName: componentId.fullName
    });
    const component = await this.workspace.get(componentId);
    const env = this.envs.getEnv(component);
    return {
      id: componentId,
      dir: componentPath,
      files: addResults.files,
      envId: env.id
    };
  }
  /**
   * writes the generated template files to the default directory set in the workspace config
   */


  async writeComponentFiles(componentPath, templateFiles) {
    const dataToPersist = new (_dataToPersist().default)();
    const vinylFiles = templateFiles.map(templateFile => {
      const templateFileVinyl = new (_vinyl().default)({
        base: componentPath,
        path: _path().default.join(componentPath, templateFile.relativePath),
        contents: Buffer.from(templateFile.content)
      });
      return _sources().AbstractVinyl.fromVinyl(templateFileVinyl);
    });
    const results = vinylFiles.map(v => v.path);
    dataToPersist.addManyFiles(vinylFiles);
    dataToPersist.addBasePath(this.workspace.path);
    await dataToPersist.persistAllToFS();
    return results;
  }

  getComponentPath(componentId) {
    if (this.options.path) return this.options.path;
    return (0, _composeComponentPath().composeComponentPath)(componentId._legacy.changeScope(componentId.scope), this.workspace.defaultDirectory);
  }

}

exports.ComponentGenerator = ComponentGenerator;

//# sourceMappingURL=component-generator.js.map