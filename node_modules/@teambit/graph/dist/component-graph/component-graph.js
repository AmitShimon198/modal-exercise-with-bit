"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentGraph = exports.DEPENDENCIES_TYPES = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cleargraph() {
  const data = require("cleargraph");

  _cleargraph = function () {
    return data;
  };

  return data;
}

function _duplicateDependency() {
  const data = require("../duplicate-dependency");

  _duplicateDependency = function () {
    return data;
  };

  return data;
}

const DEPENDENCIES_TYPES = ['dependencies', 'devDependencies'];
exports.DEPENDENCIES_TYPES = DEPENDENCIES_TYPES;

class ComponentGraph extends _cleargraph().Graph {
  constructor(nodes = [], edges = []) {
    super(nodes, edges);
    (0, _defineProperty2().default)(this, "versionMap", void 0);
    this.versionMap = new Map();
  }

  create(nodes = [], edges = []) {
    return new ComponentGraph(nodes, edges);
  }

  findDuplicateDependencies() {
    const duplicateDependencies = new Map();

    for (const [compFullName, versions] of this.versionMap) {
      if (versions.allVersionNodes.length > 1) {
        const versionSubgraphs = [];
        const notLatestVersions = versions.allVersionNodes.filter(version => version !== versions.latestVersionNode);
        notLatestVersions.forEach(version => {
          const predecessors = this.predecessorsSubgraph(version);
          const immediatePredecessors = this.predecessors(version).map(predecessor => predecessor.id);
          const subGraph = this.buildFromCleargraph(predecessors);
          const versionSubgraph = {
            versionId: version,
            subGraph,
            // TODO: validate that this is working correctly
            immediateDependents: immediatePredecessors
          };
          versionSubgraphs.push(versionSubgraph);
        });

        if (versionSubgraphs.length > 0) {
          const duplicateDep = new (_duplicateDependency().DuplicateDependency)(versions.latestVersionNode, versionSubgraphs);
          duplicateDependencies.set(compFullName, duplicateDep);
        }
      }
    }

    return duplicateDependencies;
  }

  buildFromCleargraph(graph) {
    // TODO: once cleargraph constructor and graph.nodes are consistent we should just use this line
    // this.create(graph.nodes, graph.edges)
    const newGraph = new ComponentGraph();
    const newGraphNodes = graph.nodes.map(node => {
      return {
        id: node.id,
        node: node.attr
      };
    });
    const newGraphEdges = graph.edges.map(edge => {
      return {
        sourceId: edge.sourceId,
        targetId: edge.targetId,
        edge: edge.attr
      };
    });
    newGraph.setNodes(newGraphNodes);
    newGraph.setEdges(newGraphEdges);
    return newGraph;
  }

  runtimeOnly(componentIds) {
    return this.successorsSubgraph(componentIds, edge => edge.attr.type === 'runtime');
  }

  _calculateVersionMap() {
    const versionMap = new Map();

    for (const node of this.nodes) {
      const comp = node.attr;
      const compKey = node.id;

      const compFullName = comp.id._legacy.toStringWithoutVersion();

      if (!versionMap.has(compFullName)) {
        versionMap.set(compFullName, {
          allVersionNodes: [compKey],
          latestVersionNode: compKey
        });
      } else {
        const value = versionMap.get(compFullName);

        if (value) {
          var _this$node, _this$node2;

          if (Object.prototype.hasOwnProperty.call(value, 'allVersionNodes')) {
            value.allVersionNodes.push(compKey);
          }

          const currentCompVersion = (_this$node = this.node(compKey)) === null || _this$node === void 0 ? void 0 : _this$node.attr.id._legacy.getVersion();
          const latestCompVersion = (_this$node2 = this.node(value.latestVersionNode)) === null || _this$node2 === void 0 ? void 0 : _this$node2.attr.id._legacy.getVersion();

          if (!!currentCompVersion && !!latestCompVersion && currentCompVersion.isLaterThan(latestCompVersion)) {
            value.latestVersionNode = compKey;
          }
        }
      }
    }

    return versionMap;
  }

}

exports.ComponentGraph = ComponentGraph;

//# sourceMappingURL=component-graph.js.map