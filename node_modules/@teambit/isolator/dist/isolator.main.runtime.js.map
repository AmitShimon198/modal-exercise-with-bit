{"version":3,"sources":["isolator.main.runtime.ts"],"names":["CAPSULES_BASE_DIR","path","join","CACHE_ROOT","DEFAULT_ISOLATE_INSTALL_OPTIONS","installPackages","dedupe","copyPeerToRuntimeOnComponents","copyPeerToRuntimeOnRoot","IsolatorMain","provider","dependencyResolver","loggerExtension","componentAspect","graphAspect","logger","createLogger","IsolatorAspect","id","isolator","constructor","graphBuilder","isolateComponents","seeders","opts","legacyScope","host","getHost","longProcessLogger","createLongProcessLogger","legacyLogger","debug","JSON","stringify","Object","assign","name","createGraphOpts","componentsToIsolate","seedersOnly","getMany","createGraph","baseDir","capsuleList","createCapsules","end","consoleSuccess","Network","getCapsulesRootDir","getGraphOpts","graph","getGraph","successorsSubgraph","map","toString","compsAndDeps","nodes","node","attr","existingCompsP","c","existing","includeFromNestedHosts","hasIdNested","hasId","undefined","existingComps","Promise","all","components","config","capsulesDir","emptyRootDir","fs","emptyDir","capsules","createCapsulesFromComponents","CapsuleList","fromArray","getExistingAsIs","skipIfExists","existingCapsules","filter","capsule","existsSync","length","capsulesWithPackagesData","getCapsulesPreviousPackageJson","writeComponentsInCapsules","updateWithCurrentPackageJsonData","installOptions","installInCapsules","cachePackagesOnCapsulesRoot","linkInCapsules","linkingOptions","forEach","capsuleWithPackageData","writeFileSync","PACKAGE_JSON","currentPackageJson","isolateInstallOptions","installer","getInstaller","rootDir","cacheRootDirectory","peerOnlyPolicy","getPeersOnlyPolicy","installTeambitBit","packageManagerInstallOptions","install","toComponentMap","linker","getLinker","capsulesWithModifiedPackageJson","getCapsulesWithModifiedPackageJson","link","legacyLink","packageJsonHasChanged","wereDependenciesInPackageJsonChanged","legacyComponents","component","state","_consumer","clone","allIds","BitIds","getCapsule","params","getComponentWriteParams","componentWriter","ComponentWriter","populateComponentsFilesToWrite","dataToPersist","persistAllToCapsule","keepExistingCapsule","workspacePolicy","getWorkspacePolicy","byLifecycleType","ids","bitMap","BitMap","writeToPath","origin","consumer","scope","override","writePackageJson","writeConfig","ignoreBitDependencies","excludeRegistryPrefix","isolated","tuples","ComponentMap","create","list","workspacePath","workspaceCapsuleFolder","readdir","capsuleFullPaths","workspace","e","code","Capsule","createFromComponent","previousPackageJson","DEPENDENCIES_FIELDS","some","field","packageJsonPath","previousPackageJsonRaw","promises","readFile","encoding","parse","updateP","packageJson","getCurrentPackageJson","found","find","isEqual","Error","packageJsonObject","currentVersion","getComponentPackageVersionWithCache","getComponentDepsManifest","dependencies","manifest","devDependencies","compDeps","toTypeArray","dep","depCapsule","componentId","version","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","lifecycle","entry","toManifest","packageName","deps","getDependencies","PackageJsonFile","loadFromCapsuleSync","addDependencies","packageJsonFile","addDevDependencies","addOrUpdateProperty","idStr","_componentsPackagesVersionCache","MainRuntime","DependencyResolverAspect","LoggerAspect","ComponentAspect","GraphAspect","addRuntime"],"mappings":"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","sourcesContent":["import { MainRuntime } from '@teambit/cli';\nimport { compact, pick } from 'lodash';\nimport { Component, ComponentMap, ComponentAspect, ComponentID } from '@teambit/component';\nimport type { ComponentMain, ComponentFactory } from '@teambit/component';\nimport { getComponentPackageVersion } from '@teambit/component-package-version';\nimport { GraphAspect } from '@teambit/graph';\nimport type { GraphBuilder } from '@teambit/graph';\nimport {\n  DependencyResolverAspect,\n  DependencyResolverMain,\n  LinkingOptions,\n  WorkspacePolicy,\n  InstallOptions,\n  DependencyList,\n  ComponentDependency,\n  KEY_NAME_BY_LIFECYCLE_TYPE,\n} from '@teambit/dependency-resolver';\nimport legacyLogger from '@teambit/legacy/dist/logger/logger';\nimport { Logger, LoggerAspect, LoggerMain } from '@teambit/logger';\nimport { BitIds } from '@teambit/legacy/dist/bit-id';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport { CACHE_ROOT, DEPENDENCIES_FIELDS, PACKAGE_JSON } from '@teambit/legacy/dist/constants';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport PackageJsonFile from '@teambit/legacy/dist/consumer/component/package-json-file';\nimport { importMultipleDistsArtifacts } from '@teambit/legacy/dist/consumer/component/sources/artifact-files';\nimport { PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';\nimport { Scope } from '@teambit/legacy/dist/scope';\nimport fs from 'fs-extra';\nimport hash from 'object-hash';\nimport path from 'path';\nimport equals from 'ramda/src/equals';\nimport BitMap from '@teambit/legacy/dist/consumer/bit-map';\nimport ComponentWriter, { ComponentWriterProps } from '@teambit/legacy/dist/consumer/component-ops/component-writer';\nimport { Capsule } from './capsule';\nimport CapsuleList from './capsule-list';\nimport { IsolatorAspect } from './isolator.aspect';\nimport { symlinkBitLegacyToCapsules } from './symlink-bit-legacy-to-capsules';\nimport { symlinkOnCapsuleRoot, symlinkDependenciesToCapsules } from './symlink-dependencies-to-capsules';\nimport { Network } from './network';\n\nconst CAPSULES_BASE_DIR = path.join(CACHE_ROOT, 'capsules'); // TODO: move elsewhere\n\nexport type ListResults = {\n  workspace: string;\n  capsules: string[];\n};\n\nexport type IsolateComponentsInstallOptions = {\n  installPackages?: boolean; // default: true\n  // TODO: add back when depResolver.getInstaller support it\n  // packageManager?: string;\n  dedupe?: boolean;\n  copyPeerToRuntimeOnComponents?: boolean;\n  copyPeerToRuntimeOnRoot?: boolean;\n  installTeambitBit?: boolean;\n};\n\ntype CreateGraphOptions = {\n  /**\n   * include components that exists in nested hosts. for example include components that exist in scope but not in the workspace\n   */\n  includeFromNestedHosts?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n};\n\nexport type IsolateComponentsOptions = CreateGraphOptions & {\n  name?: string;\n  /**\n   * the capsule root-dir based on a *hash* of this baseDir, not on the baseDir itself.\n   */\n  baseDir?: string;\n\n  /**\n   * create a new capsule with a random string attached to the path suffix\n   */\n  alwaysNew?: boolean;\n\n  /**\n   * installation options\n   */\n  installOptions?: IsolateComponentsInstallOptions;\n\n  linkingOptions?: LinkingOptions;\n\n  /**\n   * delete the capsule rootDir first. it makes sure that the isolation process starts fresh with\n   * no previous capsules. for build and tag this is true.\n   */\n  emptyRootDir?: boolean;\n\n  /**\n   * skip the reproduction of the capsule in case it exists.\n   */\n  skipIfExists?: boolean;\n\n  /**\n   * get existing capsule without doing any changes, no writes, no installations.\n   */\n  getExistingAsIs?: boolean;\n\n  /**\n   * place the package-manager cache on the capsule-root\n   */\n  cachePackagesOnCapsulesRoot?: boolean;\n\n  /**\n   * do not build graph with all dependencies. isolate the seeders only.\n   */\n  seedersOnly?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n};\n\ntype CapsulePackageJsonData = {\n  capsule: Capsule;\n  currentPackageJson?: Record<string, any>;\n  previousPackageJson: Record<string, any> | null;\n};\n\nconst DEFAULT_ISOLATE_INSTALL_OPTIONS: IsolateComponentsInstallOptions = {\n  installPackages: true,\n  dedupe: true,\n  copyPeerToRuntimeOnComponents: false,\n  copyPeerToRuntimeOnRoot: true,\n};\n\nexport class IsolatorMain {\n  static runtime = MainRuntime;\n  static dependencies = [DependencyResolverAspect, LoggerAspect, ComponentAspect, GraphAspect];\n  static defaultConfig = {};\n  _componentsPackagesVersionCache: { [idStr: string]: string } = {}; // cache packages versions of components\n\n  static async provider([dependencyResolver, loggerExtension, componentAspect, graphAspect]: [\n    DependencyResolverMain,\n    LoggerMain,\n    ComponentMain,\n    GraphBuilder\n  ]): Promise<IsolatorMain> {\n    const logger = loggerExtension.createLogger(IsolatorAspect.id);\n    const isolator = new IsolatorMain(dependencyResolver, logger, componentAspect, graphAspect);\n    return isolator;\n  }\n  constructor(\n    private dependencyResolver: DependencyResolverMain,\n    private logger: Logger,\n    private componentAspect: ComponentMain,\n    private graphBuilder: GraphBuilder\n  ) {}\n\n  // TODO: the legacy scope used for the component writer, which then decide if it need to write the artifacts and dists\n  // TODO: we should think of another way to provide it (maybe a new opts) then take the scope internally from the host\n  async isolateComponents(\n    seeders: ComponentID[],\n    opts: IsolateComponentsOptions = {},\n    legacyScope?: LegacyScope\n  ): Promise<Network> {\n    const host = this.componentAspect.getHost();\n    const longProcessLogger = this.logger.createLongProcessLogger('create capsules network');\n    legacyLogger.debug(\n      `isolatorExt, createNetwork ${seeders.join(', ')}. opts: ${JSON.stringify(\n        Object.assign({}, opts, { host: opts.host?.name })\n      )}`\n    );\n    const createGraphOpts = pick(opts, ['includeFromNestedHosts', 'host']);\n    const componentsToIsolate = opts.seedersOnly\n      ? await host.getMany(seeders)\n      : await this.createGraph(seeders, createGraphOpts);\n    opts.baseDir = opts.baseDir || host.path;\n    const capsuleList = await this.createCapsules(componentsToIsolate, opts, legacyScope);\n    longProcessLogger.end();\n    this.logger.consoleSuccess();\n    return new Network(capsuleList, seeders, this.getCapsulesRootDir(opts.baseDir));\n  }\n\n  private async createGraph(seeders: ComponentID[], opts: CreateGraphOptions = {}): Promise<Component[]> {\n    const host = this.componentAspect.getHost();\n    const getGraphOpts = pick(opts, ['host']);\n    const graph = await this.graphBuilder.getGraph(seeders, getGraphOpts);\n    const successorsSubgraph = graph.successorsSubgraph(seeders.map((id) => id.toString()));\n    const compsAndDeps = successorsSubgraph.nodes.map((node) => node.attr);\n    // do not ignore the version here. a component might be in .bitmap with one version and\n    // installed as a package with another version. we don't want them both.\n    const existingCompsP = compsAndDeps.map(async (c) => {\n      let existing;\n      if (opts.includeFromNestedHosts) {\n        existing = await host.hasIdNested(c.id, true);\n      } else {\n        existing = await host.hasId(c.id);\n      }\n      if (existing) return c;\n      return undefined;\n    });\n    const existingComps = await Promise.all(existingCompsP);\n    return compact(existingComps);\n  }\n\n  /**\n   * Create capsules for the provided components\n   * do not use this outside directly, use isolate components which build the entire network\n   * @param components\n   * @param opts\n   * @param legacyScope\n   */\n  private async createCapsules(\n    components: Component[],\n    opts: IsolateComponentsOptions,\n    legacyScope?: Scope\n  ): Promise<CapsuleList> {\n    const config = { installPackages: true, ...opts };\n    const capsulesDir = this.getCapsulesRootDir(opts.baseDir as string);\n    if (opts.emptyRootDir) {\n      await fs.emptyDir(capsulesDir);\n    }\n    const capsules = await this.createCapsulesFromComponents(components, capsulesDir, config);\n    const capsuleList = CapsuleList.fromArray(capsules);\n    if (opts.getExistingAsIs) {\n      return capsuleList;\n    }\n\n    if (opts.skipIfExists) {\n      const existingCapsules = CapsuleList.fromArray(\n        capsuleList.filter((capsule) => capsule.fs.existsSync('package.json'))\n      );\n\n      if (existingCapsules.length === capsuleList.length) return existingCapsules;\n    }\n    const capsulesWithPackagesData = await this.getCapsulesPreviousPackageJson(capsules);\n\n    await this.writeComponentsInCapsules(components, capsuleList, legacyScope);\n    await this.updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsuleList);\n    const installOptions = Object.assign({}, DEFAULT_ISOLATE_INSTALL_OPTIONS, opts.installOptions || {});\n    if (installOptions.installPackages) {\n      await this.installInCapsules(capsulesDir, capsuleList, installOptions, opts.cachePackagesOnCapsulesRoot ?? false);\n      await this.linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, opts.linkingOptions ?? {});\n    }\n\n    // rewrite the package-json with the component dependencies in it. the original package.json\n    // that was written before, didn't have these dependencies in order for the package-manager to\n    // be able to install them without crushing when the versions don't exist yet\n    capsulesWithPackagesData.forEach((capsuleWithPackageData) => {\n      capsuleWithPackageData.capsule.fs.writeFileSync(\n        PACKAGE_JSON,\n        JSON.stringify(capsuleWithPackageData.currentPackageJson, null, 2)\n      );\n    });\n\n    return capsuleList;\n  }\n\n  private async installInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    isolateInstallOptions: IsolateComponentsInstallOptions,\n    cachePackagesOnCapsulesRoot: boolean\n  ) {\n    const installer = this.dependencyResolver.getInstaller({\n      rootDir: capsulesDir,\n      cacheRootDirectory: cachePackagesOnCapsulesRoot ? capsulesDir : undefined,\n    });\n    // When using isolator we don't want to use the policy defined in the workspace directly,\n    // we only want to instal deps from components and the peer from the workspace\n\n    const peerOnlyPolicy = this.getPeersOnlyPolicy();\n    const installOptions: InstallOptions = {\n      installTeambitBit: !!isolateInstallOptions.installTeambitBit,\n    };\n    const packageManagerInstallOptions = {\n      dedupe: isolateInstallOptions.dedupe,\n      copyPeerToRuntimeOnComponents: isolateInstallOptions.copyPeerToRuntimeOnComponents,\n      copyPeerToRuntimeOnRoot: isolateInstallOptions.copyPeerToRuntimeOnRoot,\n    };\n    await installer.install(\n      capsulesDir,\n      peerOnlyPolicy,\n      this.toComponentMap(capsuleList),\n      installOptions,\n      packageManagerInstallOptions\n    );\n  }\n\n  private async linkInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    linkingOptions: LinkingOptions\n  ) {\n    const linker = this.dependencyResolver.getLinker({\n      rootDir: capsulesDir,\n      linkingOptions,\n    });\n    const peerOnlyPolicy = this.getPeersOnlyPolicy();\n    const capsulesWithModifiedPackageJson = this.getCapsulesWithModifiedPackageJson(capsulesWithPackagesData);\n    await linker.link(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), {\n      ...linkingOptions,\n      legacyLink: false,\n    });\n    await symlinkOnCapsuleRoot(capsuleList, this.logger, capsulesDir);\n    await symlinkDependenciesToCapsules(capsulesWithModifiedPackageJson, capsuleList, this.logger);\n    // TODO: this is a hack to have access to the bit bin project in order to access core extensions from user extension\n    // TODO: remove this after exporting core extensions as components\n    await symlinkBitLegacyToCapsules(capsulesWithModifiedPackageJson, this.logger);\n    // await copyBitLegacyToCapsuleRoot(capsulesDir, this.logger);\n  }\n\n  private getCapsulesWithModifiedPackageJson(capsulesWithPackagesData: CapsulePackageJsonData[]) {\n    const capsulesWithModifiedPackageJson: Capsule[] = capsulesWithPackagesData\n      .filter((capsuleWithPackageData) => {\n        const packageJsonHasChanged = this.wereDependenciesInPackageJsonChanged(capsuleWithPackageData);\n        // @todo: when a component is tagged, it changes all package-json of its dependents, but it\n        // should not trigger any \"npm install\" because they dependencies are symlinked by us\n        return packageJsonHasChanged;\n      })\n      .map((capsuleWithPackageData) => capsuleWithPackageData.capsule);\n    return capsulesWithModifiedPackageJson;\n  }\n\n  private async writeComponentsInCapsules(components: Component[], capsuleList: CapsuleList, legacyScope?: Scope) {\n    const legacyComponents = components.map((component) => component.state._consumer.clone());\n    if (legacyScope) await importMultipleDistsArtifacts(legacyScope, legacyComponents);\n    const allIds = BitIds.fromArray(legacyComponents.map((c) => c.id));\n    await Promise.all(\n      components.map(async (component) => {\n        const capsule = capsuleList.getCapsule(component.id);\n        if (!capsule) return;\n        const params = this.getComponentWriteParams(component.state._consumer, allIds, legacyScope);\n        const componentWriter = new ComponentWriter(params);\n        await componentWriter.populateComponentsFilesToWrite();\n        await component.state._consumer.dataToPersist.persistAllToCapsule(capsule, { keepExistingCapsule: true });\n      })\n    );\n  }\n\n  private getPeersOnlyPolicy(): WorkspacePolicy {\n    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();\n    const peerOnlyPolicy = workspacePolicy.byLifecycleType('peer');\n    return peerOnlyPolicy;\n  }\n\n  private getComponentWriteParams(\n    component: ConsumerComponent,\n    ids: BitIds,\n    legacyScope?: Scope\n  ): ComponentWriterProps {\n    return {\n      component,\n      // @ts-ignore\n      bitMap: new BitMap(undefined, undefined, undefined, false),\n      writeToPath: '.',\n      origin: 'IMPORTED',\n      consumer: undefined,\n      scope: legacyScope,\n      override: false,\n      writePackageJson: true,\n      writeConfig: false,\n      ignoreBitDependencies: ids,\n      excludeRegistryPrefix: false,\n      isolated: true,\n    };\n  }\n\n  private toComponentMap(capsuleList: CapsuleList): ComponentMap<string> {\n    const tuples: [Component, string][] = capsuleList.map((capsule) => {\n      return [capsule.component, capsule.path];\n    });\n\n    return ComponentMap.create(tuples);\n  }\n\n  async list(workspacePath: string): Promise<ListResults> {\n    try {\n      const workspaceCapsuleFolder = this.getCapsulesRootDir(workspacePath);\n      const capsules = await fs.readdir(workspaceCapsuleFolder);\n      const capsuleFullPaths = capsules.map((c) => path.join(workspaceCapsuleFolder, c));\n      return {\n        workspace: workspacePath,\n        capsules: capsuleFullPaths,\n      };\n    } catch (e: any) {\n      if (e.code === 'ENOENT') {\n        return { workspace: workspacePath, capsules: [] };\n      }\n      throw e;\n    }\n  }\n\n  getCapsulesRootDir(baseDir: string): PathOsBasedAbsolute {\n    return path.join(CAPSULES_BASE_DIR, hash(baseDir));\n  }\n\n  private async createCapsulesFromComponents(\n    components: Component[],\n    baseDir: string,\n    opts: IsolateComponentsOptions\n  ): Promise<Capsule[]> {\n    const capsules: Capsule[] = await Promise.all(\n      components.map((component: Component) => {\n        return Capsule.createFromComponent(component, baseDir, opts);\n      })\n    );\n    return capsules;\n  }\n\n  private wereDependenciesInPackageJsonChanged(capsuleWithPackageData: CapsulePackageJsonData): boolean {\n    const { previousPackageJson, currentPackageJson } = capsuleWithPackageData;\n    if (!previousPackageJson) return true;\n    // @ts-ignore at this point, currentPackageJson is set\n    return DEPENDENCIES_FIELDS.some((field) => !equals(previousPackageJson[field], currentPackageJson[field]));\n  }\n\n  private async getCapsulesPreviousPackageJson(capsules: Capsule[]): Promise<CapsulePackageJsonData[]> {\n    return Promise.all(\n      capsules.map(async (capsule) => {\n        const packageJsonPath = path.join(capsule.path, 'package.json');\n        let previousPackageJson: any = null;\n        try {\n          const previousPackageJsonRaw = await capsule.fs.promises.readFile(packageJsonPath, { encoding: 'utf8' });\n          previousPackageJson = JSON.parse(previousPackageJsonRaw);\n        } catch (e: any) {\n          // package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss\n        }\n        return {\n          capsule,\n          previousPackageJson,\n        };\n      })\n    );\n  }\n\n  private async updateWithCurrentPackageJsonData(\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    capsules: CapsuleList\n  ) {\n    const updateP = capsules.map(async (capsule) => {\n      const packageJson = await this.getCurrentPackageJson(capsule, capsules);\n      const found = capsulesWithPackagesData.find((c) => c.capsule.component.id.isEqual(capsule.component.id));\n      if (!found) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);\n      found.currentPackageJson = packageJson.packageJsonObject;\n    });\n    return Promise.all(updateP);\n  }\n\n  private async getCurrentPackageJson(capsule: Capsule, capsules: CapsuleList): Promise<PackageJsonFile> {\n    const component: Component = capsule.component;\n    const currentVersion = await this.getComponentPackageVersionWithCache(component);\n    // const newVersion = '0.0.1-new';\n    const getComponentDepsManifest = async (dependencies: DependencyList) => {\n      const manifest = {\n        dependencies: {},\n        devDependencies: {},\n      };\n      const compDeps = dependencies.toTypeArray<ComponentDependency>('component');\n      const promises = compDeps.map(async (dep) => {\n        const depCapsule = capsules.getCapsule(dep.componentId);\n        let version = dep.version;\n        if (depCapsule) {\n          version = await this.getComponentPackageVersionWithCache(depCapsule?.component);\n        }\n        const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];\n        const entry = dep.toManifest();\n        if (entry) {\n          manifest[keyName][entry.packageName] = version;\n        }\n      });\n      await Promise.all(promises);\n      return manifest;\n    };\n    const deps = await this.dependencyResolver.getDependencies(component);\n    const manifest = await getComponentDepsManifest(deps);\n\n    // unfortunately, component.packageJsonFile is not available here.\n    // the reason is that `writeComponentsToCapsules` clones the component before writing them\n    // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes\n    // such as postInstall scripts for custom-module-resolution.\n    const packageJson = PackageJsonFile.loadFromCapsuleSync(capsule.path);\n\n    const addDependencies = (packageJsonFile: PackageJsonFile) => {\n      packageJsonFile.addDependencies(manifest.dependencies);\n      packageJsonFile.addDevDependencies(manifest.devDependencies);\n    };\n    addDependencies(packageJson);\n    packageJson.addOrUpdateProperty('version', currentVersion);\n    return packageJson;\n  }\n\n  private async getComponentPackageVersionWithCache(component: Component): Promise<string> {\n    const idStr = component.id.toString();\n    if (this._componentsPackagesVersionCache[idStr]) {\n      return this._componentsPackagesVersionCache[idStr];\n    }\n    const version = await getComponentPackageVersion(component);\n    this._componentsPackagesVersionCache[idStr] = version;\n    return version;\n  }\n}\n\nIsolatorAspect.addRuntime(IsolatorMain);\n"]}