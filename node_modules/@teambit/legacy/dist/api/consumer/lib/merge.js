"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;

function _tail2() {
  const data = _interopRequireDefault(require("ramda/src/tail"));

  _tail2 = function () {
    return data;
  };

  return data;
}

function _head2() {
  const data = _interopRequireDefault(require("ramda/src/head"));

  _head2 = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("../../../consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("../../../consumer/versions-ops/merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _mergeSnaps() {
  const data = require("../../../consumer/versions-ops/merge-version/merge-snaps");

  _mergeSnaps = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

async function merge(values, mergeStrategy, abort, resolve, noSnap, message, build) {
  const consumer = await (0, _consumer().loadConsumer)();

  if (consumer.isLegacy && (noSnap || message || abort || resolve)) {
    throw new (_lanesIsDisabled().LanesIsDisabled)();
  }

  let mergeResults;
  const firstValue = (0, _head2().default)(values);

  if (resolve) {
    mergeResults = await (0, _mergeSnaps().resolveMerge)(consumer, values, message, build);
  } else if (abort) {
    mergeResults = await (0, _mergeSnaps().abortMerge)(consumer, values);
  } else if (!_bitId().BitId.isValidVersion(firstValue)) {
    const bitIds = getComponentsToMerge(consumer, values); // @todo: version could be the lane only or remote/lane

    mergeResults = await (0, _mergeSnaps().mergeComponentsFromRemote)(consumer, bitIds, mergeStrategy, noSnap, message, build);
  } else {
    const version = firstValue;
    const ids = (0, _tail2().default)(values);
    const bitIds = getComponentsToMerge(consumer, ids);
    mergeResults = await (0, _mergeVersion().mergeVersion)(consumer, version, bitIds, mergeStrategy);
  }

  await consumer.onDestroy();
  return mergeResults;
}

function getComponentsToMerge(consumer, ids) {
  if ((0, _hasWildcard().default)(ids)) {
    const componentsList = new (_componentsList().default)(consumer);
    return componentsList.listComponentsByIdsWithWildcard(ids);
  }

  return ids.map(id => consumer.getParsedId(id));
}