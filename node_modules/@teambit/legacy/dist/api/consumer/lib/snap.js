"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.snapAction = snapAction;

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("../../../consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

async function snapAction(args) {
  const {
    id,
    message,
    force,
    verbose,
    ignoreIssues,
    skipTests,
    skipAutoSnap,
    build,
    disableTagAndSnapPipelines,
    forceDeploy
  } = args;
  const consumer = await (0, _consumer().loadConsumer)();
  if (consumer.isLegacy) throw new (_lanesIsDisabled().LanesIsDisabled)();
  const componentsList = new (_componentsList().default)(consumer);
  const newComponents = await componentsList.listNewComponents();
  const ids = await getIdsToSnap();
  if (!ids) return null;
  const tagResults = await consumer.snap({
    ids,
    ignoreIssues,
    message,
    force,
    build,
    skipTests,
    verbose,
    skipAutoSnap,
    disableTagAndSnapPipelines,
    forceDeploy
  }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  tagResults.newComponents = newComponents;
  await consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return tagResults;

  async function getIdsToSnap() {
    const idHasWildcard = id && (0, _hasWildcard().default)(id);

    if (id && !idHasWildcard) {
      const bitId = consumer.getParsedId(id);

      if (!force) {
        const componentStatus = await consumer.getComponentStatusById(bitId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        if (componentStatus.modified === false) return null;
      }

      return new (_bitId().BitIds)(bitId);
    }

    const tagPendingComponents = await componentsList.listTagPendingComponents(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if ((0, _isEmpty2().default)(tagPendingComponents)) return null;
    return idHasWildcard ? _componentsList().default.filterComponentsByWildcard(tagPendingComponents, id) : tagPendingComponents;
  }
}