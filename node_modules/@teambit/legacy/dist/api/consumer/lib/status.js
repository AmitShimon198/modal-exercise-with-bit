"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = status;

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

async function status() {
  _loader().default.start(_loaderMessages().BEFORE_STATUS);

  const consumer = await (0, _consumer().loadConsumer)();
  const laneObj = await consumer.getCurrentLaneObject();
  const componentsList = new (_componentsList().default)(consumer);
  const newComponents = await componentsList.listNewComponents(true);
  const modifiedComponent = await componentsList.listModifiedComponents(true);
  const stagedComponents = await componentsList.listExportPendingComponents(laneObj);
  const autoTagPendingComponents = await componentsList.listAutoTagPendingComponents();
  const autoTagPendingComponentsIds = autoTagPendingComponents.map(component => component.id);
  const allInvalidComponents = await componentsList.listInvalidComponents();
  const importPendingComponents = allInvalidComponents // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  .filter(c => c.error instanceof _componentsPendingImport().default) // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  .map(i => i.id); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  const invalidComponents = allInvalidComponents.filter(c => !(c.error instanceof _componentsPendingImport().default));
  const outdatedComponents = await componentsList.listOutdatedComponents();
  const mergePendingComponents = await componentsList.listMergePendingComponents();
  const newAndModified = newComponents.concat(modifiedComponent);
  const componentsWithIssues = newAndModified.filter(component => {
    if (consumer.isLegacy && component.issues) {
      component.issues.delete(_componentIssues().IssuesClasses.relativeComponentsAuthored);
    }

    return component.issues && !component.issues.isEmpty();
  });
  const componentsDuringMergeState = componentsList.listDuringMergeStateComponents();
  const softTaggedComponents = componentsList.listSoftTaggedComponents();
  const snappedComponents = (await componentsList.listSnappedComponentsOnMain()).map(c => c.toBitId());

  _analytics().Analytics.setExtraData('new_components', newComponents.length);

  _analytics().Analytics.setExtraData('staged_components', stagedComponents.length);

  _analytics().Analytics.setExtraData('num_components_with_missing_dependencies', componentsWithIssues.length);

  _analytics().Analytics.setExtraData('autoTagPendingComponents', autoTagPendingComponents.length);

  _analytics().Analytics.setExtraData('deleted', invalidComponents.length);

  await consumer.onDestroy();
  return {
    newComponents: _componentsList().default.sortComponentsByName(newComponents),
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    modifiedComponent: _componentsList().default.sortComponentsByName(modifiedComponent),
    stagedComponents: _componentsList().default.sortComponentsByName(stagedComponents),
    componentsWithIssues,
    // no need to sort, we don't print it as is
    importPendingComponents,
    // no need to sort, we use only its length
    autoTagPendingComponents: _componentsList().default.sortComponentsByName(autoTagPendingComponentsIds),
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    invalidComponents,
    outdatedComponents,
    mergePendingComponents,
    componentsDuringMergeState,
    componentsWithIndividualFiles: await componentsList.listComponentsWithIndividualFiles(),
    componentsWithTrackDirs: await componentsList.listComponentsWithTrackDir(),
    softTaggedComponents,
    snappedComponents
  };
}