"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagAction = tagAction;
exports.AUTO_TAGGED_MSG = exports.NOTHING_TO_TAG_MSG = void 0;

function _concat2() {
  const data = _interopRequireDefault(require("ramda/src/concat"));

  _concat2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("../../../hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _semverHelper() {
  const data = require("../../../utils/semver-helper");

  _semverHelper = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const HooksManagerInstance = _hooks().default.getInstance();

const NOTHING_TO_TAG_MSG = 'nothing to tag';
exports.NOTHING_TO_TAG_MSG = NOTHING_TO_TAG_MSG;
const AUTO_TAGGED_MSG = 'auto-tagged dependents';
exports.AUTO_TAGGED_MSG = AUTO_TAGGED_MSG;

async function tagAction(tagParams) {
  const {
    ids,
    all,
    exactVersion,
    releaseType,
    force,
    ignoreIssues,
    scope,
    includeImported,
    persist,
    snapped
  } = tagParams;
  const idsHasWildcard = (0, _hasWildcard().default)(ids);
  const isAll = Boolean(all || scope || idsHasWildcard);
  const validExactVersion = (0, _semverHelper().validateVersion)(exactVersion);
  const preHook = isAll ? _constants().PRE_TAG_ALL_HOOK : _constants().PRE_TAG_HOOK;
  HooksManagerInstance.triggerHook(preHook, tagParams);
  const consumer = await (0, _consumer().loadConsumer)();
  const componentsList = new (_componentsList().default)(consumer);

  _loader().default.start('determine components to tag...');

  const newComponents = await componentsList.listNewComponents();
  const {
    bitIds,
    warnings
  } = await getComponentsToTag(consumer, Boolean(scope), exactVersion, includeImported, persist, force, ids, snapped);
  if ((0, _isEmpty2().default)(bitIds)) return null;

  const consumerTagParams = _objectSpread(_objectSpread({}, tagParams), {}, {
    ids: _bitId().BitIds.fromArray(bitIds),
    exactVersion: validExactVersion,
    releaseType,
    ignoreIssues
  });

  const tagResults = await consumer.tag(consumerTagParams); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  tagResults.warnings = warnings; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  tagResults.newComponents = newComponents;
  const postHook = isAll ? _constants().POST_TAG_ALL_HOOK : _constants().POST_TAG_HOOK;
  HooksManagerInstance.triggerHook(postHook, tagResults);

  _analytics().Analytics.setExtraData('num_components', // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  (0, _concat2().default)(tagResults.taggedComponents, tagResults.autoTaggedResults, tagResults.newComponents).length);

  await consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return tagResults;
}

async function getComponentsToTag(consumer, isAllScope, exactVersion, includeImported, persist, force, ids, snapped) {
  const warnings = [];
  const componentsList = new (_componentsList().default)(consumer);

  if (persist) {
    const softTaggedComponents = componentsList.listSoftTaggedComponents();
    return {
      bitIds: softTaggedComponents,
      warnings: []
    };
  }

  const tagPendingComponents = isAllScope ? await componentsList.listTagPendingOfAllScope(includeImported) : await componentsList.listTagPendingComponents();
  const snappedComponents = await componentsList.listSnappedComponentsOnMain();
  const snappedComponentsIds = snappedComponents.map(c => c.toBitId());

  if (ids.length) {
    const bitIds = await Promise.all(ids.map(async id => {
      const [idWithoutVer, version] = id.split('@');
      const idHasWildcard = (0, _hasWildcard().default)(id);

      if (idHasWildcard) {
        const allIds = _componentsList().default.filterComponentsByWildcard(tagPendingComponents, idWithoutVer);

        return allIds.map(bitId => bitId.changeVersion(version));
      }

      const bitId = consumer.getParsedId(idWithoutVer);

      if (!force) {
        const componentStatus = await consumer.getComponentStatusById(bitId);
        if (componentStatus.modified === false) return null;
      }

      return bitId.changeVersion(version);
    }));
    return {
      bitIds: (0, _lodash().compact)(bitIds.flat()),
      warnings
    };
  }

  if (snapped) {
    return {
      bitIds: snappedComponentsIds,
      warnings
    };
  }

  tagPendingComponents.push(...snappedComponentsIds);

  if (isAllScope && exactVersion) {
    const tagPendingComponentsLatest = await consumer.scope.latestVersions(tagPendingComponents, false);
    tagPendingComponentsLatest.forEach(componentId => {
      if (componentId.version && _semver().default.gt(componentId.version, exactVersion)) {
        warnings.push(`warning: ${componentId.toString()} has a version greater than ${exactVersion}`);
      }
    });
  }

  return {
    bitIds: tagPendingComponents.map(id => id.changeVersion(undefined)),
    warnings
  };
}