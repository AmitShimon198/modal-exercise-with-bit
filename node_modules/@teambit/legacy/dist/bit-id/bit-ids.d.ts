import BitId, { BitIdStr } from '../bit-id/bit-id';
export default class BitIds extends Array<BitId> {
    serialize(): string[];
    resolveVersion(idWithLatest: BitId): BitId;
    has(bitId: BitId): boolean;
    hasWithoutVersion(bitId: BitId): boolean;
    hasWithoutScope(bitId: BitId): boolean;
    hasWithoutScopeAndVersion(bitId: BitId): boolean;
    hasWithoutScopeAndVersionAsString(bitIdStr: BitIdStr): boolean;
    search(bitId: BitId): BitId | null | undefined;
    searchWithoutVersion(bitId: BitId): BitId | null | undefined;
    searchWithoutScopeAndVersion(bitId: BitId): BitId | undefined;
    searchWithoutScope(bitId: BitId): BitId | null | undefined;
    searchStrWithoutVersion(idStr: string): BitId | null | undefined;
    searchStrWithoutScopeAndVersion(idStr: string): BitId | null | undefined;
    filterExact(bitId: BitId): BitId[];
    filterWithoutVersion(bitId: BitId): BitId[];
    filterWithoutScopeAndVersion(bitId: BitId): BitId[];
    removeIfExist(bitId: BitId): BitIds;
    difference(bitIds: BitIds): BitIds;
    removeIfExistWithoutVersion(bitId: BitId): BitIds;
    removeMultipleIfExistWithoutVersion(bitIds: BitIds): BitIds;
    static deserialize(array?: string[]): BitIds;
    static deserializeObsolete(array?: string[]): BitIds;
    toString(): string;
    toGroupByScopeName(idsWithDefaultScope: BitIds): {
        [scopeName: string]: BitIds;
    };
    findDuplicationsIgnoreVersion(): {
        [id: string]: BitId[];
    };
    add(bitIds: BitId[]): void;
    static fromObject(dependencies: {
        [key: string]: string;
    }): BitIds;
    static fromArray(bitIds: BitId[]): BitIds;
    static uniqFromArray(bitIds: BitId[]): BitIds;
    throwForDuplicationIgnoreVersion(): void;
    toVersionLatest(): BitIds;
    clone(): BitIds;
}
