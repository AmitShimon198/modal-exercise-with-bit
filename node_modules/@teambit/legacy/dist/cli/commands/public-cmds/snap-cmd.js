"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AUTO_SNAPPED_MSG = exports.NOTHING_TO_SNAP_MSG = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _featureToggle() {
  const data = require("../../../api/consumer/lib/feature-toggle");

  _featureToggle = function () {
    return data;
  };

  return data;
}

const NOTHING_TO_SNAP_MSG = 'nothing to snap';
exports.NOTHING_TO_SNAP_MSG = NOTHING_TO_SNAP_MSG;
const AUTO_SNAPPED_MSG = 'auto-snapped dependents';
exports.AUTO_SNAPPED_MSG = AUTO_SNAPPED_MSG;

class Snap {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'snap [id]');
    (0, _defineProperty2().default)(this, "description", `record component changes.
  https://${_constants().BASE_DOCS_DOMAIN}/docs/snap-component-version
  ${(0, _constants().WILDCARD_HELP)('snap')}`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "opts", [['m', 'message <message>', 'log message describing the user changes'], ['a', 'all', 'snap all new and modified components'], ['f', 'force', 'force-snap even if tests are failing and even when component has not changed'], ['v', 'verbose', 'show specs output on failure'], ['i', 'ignore-issues', 'ignore component issues (shown in "bit status" as "issues found")'], ['', 'build', 'Harmony only. run the pipeline build and complete the tag'], ['', 'skip-tests', 'skip running component tests during snap process'], ['', 'skip-auto-snap', 'skip auto snapping dependents'], ['', 'disable-snap-pipeline', 'skip the snap pipeline'], ['', 'force-deploy', 'Harmony only. run the deploy pipeline although the build failed']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  action([id], {
    message = '',
    all = false,
    force = false,
    verbose = false,
    ignoreIssues = false,
    build,
    skipTests = false,
    skipAutoSnap = false,
    disableSnapPipeline = false,
    forceDeploy = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;

    if (!id && !all) {
      throw new (_generalError().default)('missing [id]. to snap all components, please use --all flag');
    }

    if (id && all) {
      throw new (_generalError().default)('you can use either a specific component [id] to snap a particular component or --all flag to snap them all');
    }

    const disableTagAndSnapPipelines = disableSnapPipeline;

    if (disableTagAndSnapPipelines && forceDeploy) {
      throw new (_generalError().default)('you can use either force-deploy or disable-snap-pipeline, but not both');
    }

    return (0, _consumer().snapAction)({
      id,
      message,
      force,
      verbose,
      ignoreIssues,
      build,
      skipTests,
      skipAutoSnap,
      disableTagAndSnapPipelines,
      forceDeploy
    });
  }

  report(results) {
    if (!results) return _chalk().default.yellow(NOTHING_TO_SNAP_MSG);
    const {
      snappedComponents,
      autoSnappedResults,
      warnings,
      newComponents
    } = results;
    const changedComponents = snappedComponents.filter(component => !newComponents.searchWithoutVersion(component.id));
    const addedComponents = snappedComponents.filter(component => newComponents.searchWithoutVersion(component.id));
    const autoTaggedCount = autoSnappedResults ? autoSnappedResults.length : 0;
    const warningsOutput = warnings && warnings.length ? `${_chalk().default.yellow(warnings.join('\n'))}\n\n` : '';
    const tagExplanation = `\n(use "bit export [collection]" to push these components to a remote")
(use "bit untag" to unstage versions)\n`;

    const outputComponents = comps => {
      return comps.map(component => {
        let componentOutput = `     > ${component.id.toString()}`;
        const autoTag = autoSnappedResults.filter(result => result.triggeredBy.searchWithoutScopeAndVersion(component.id));

        if (autoTag.length) {
          const autoTagComp = autoTag.map(a => a.component.id.toString());
          componentOutput += `\n       ${AUTO_SNAPPED_MSG}: ${autoTagComp.join(', ')}`;
        }

        return componentOutput;
      }).join('\n');
    };

    const outputIfExists = (label, explanation, components) => {
      if (!components.length) return '';
      return `\n${_chalk().default.underline(label)}\n(${explanation})\n${outputComponents(components)}\n`;
    };

    return warningsOutput + _chalk().default.green(`${snappedComponents.length + autoTaggedCount} component(s) snapped`) + tagExplanation + outputIfExists('new components', 'first version for components', addedComponents) + outputIfExists('changed components', 'components that got a version bump', changedComponents);
  }

}

exports.default = Snap;