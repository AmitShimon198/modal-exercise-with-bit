"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.individualFilesDesc = exports.statusWorkspaceIsCleanMsg = exports.statusInvalidComponentsMsg = exports.statusFailureMsg = void 0;

function _groupBy2() {
  const data = _interopRequireDefault(require("ramda/src/groupBy"));

  _groupBy2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("../../../consumer/component"));

  _component = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _chalkBox() {
  const data = require("../../chalk-box");

  _chalkBox = function () {
    return data;
  };

  return data;
}

function _componentIssuesTemplate() {
  const data = require("../../templates/component-issues-template");

  _componentIssuesTemplate = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../../../scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

const TROUBLESHOOTING_MESSAGE = `${_chalk().default.yellow(`see troubleshooting at https://${_constants().BASE_DOCS_DOMAIN}/docs/add-and-isolate-components#common-isolation-errors`)}`;
const statusFailureMsg = 'issues found';
exports.statusFailureMsg = statusFailureMsg;
const statusInvalidComponentsMsg = 'invalid components';
exports.statusInvalidComponentsMsg = statusInvalidComponentsMsg;
const statusWorkspaceIsCleanMsg = 'nothing to tag or export (use "bit add <file...>" to track files or directories as components)';
exports.statusWorkspaceIsCleanMsg = statusWorkspaceIsCleanMsg;
const individualFilesDesc = `these components were added as individual files and not as directories, which are invalid in Harmony
please make sure each component has its own directory and re-add it. alternatively, use "bit move --component" to help with the move.`;
exports.individualFilesDesc = individualFilesDesc;
const trackDirDesc = `these components were added by an older version of Bit and therefore have "trackDir" record in the .bitmap file
please run "bit migrate --harmony" to convert these records to "rootDir".`;

class Status {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'status');
    (0, _defineProperty2().default)(this, "shortDescription", 'show the working area component(s) status');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "description", `show the working area component(s) status.\n  https://${_constants().BASE_DOCS_DOMAIN}/docs/view#status`);
    (0, _defineProperty2().default)(this, "alias", 's');
    (0, _defineProperty2().default)(this, "opts", [['j', 'json', 'return a json version of the component'], ['', 'strict', 'in case issues found, exit with code 1']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "json", false);
  }

  // eslint-disable-next-line no-empty-pattern
  async action([], {
    json,
    strict
  }) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.json = json;
    const results = await (0, _consumer().status)();
    const exitCode = results.componentsWithIssues.length && strict ? 1 : 0;
    return {
      data: results,
      __code: exitCode
    };
  }

  report({
    newComponents,
    modifiedComponent,
    stagedComponents,
    componentsWithIssues,
    importPendingComponents,
    autoTagPendingComponents,
    invalidComponents,
    outdatedComponents,
    mergePendingComponents,
    componentsDuringMergeState,
    componentsWithIndividualFiles,
    componentsWithTrackDirs,
    softTaggedComponents,
    snappedComponents
  }) {
    if (this.json) {
      return JSON.stringify({
        newComponents,
        modifiedComponent: modifiedComponent.map(c => c.id.toString()),
        stagedComponents: stagedComponents.map(c => c.id()),
        componentsWithIssues: componentsWithIssues.map(c => {
          var _c$issues;

          return {
            id: c.id.toString(),
            issues: (_c$issues = c.issues) === null || _c$issues === void 0 ? void 0 : _c$issues.toObject()
          };
        }),
        importPendingComponents: importPendingComponents.map(id => id.toString()),
        autoTagPendingComponents: autoTagPendingComponents.map(s => s.toString()),
        invalidComponents,
        outdatedComponents: outdatedComponents.map(c => c.id.toString()),
        mergePendingComponents: mergePendingComponents.map(c => c.id.toString()),
        componentsDuringMergeState: componentsDuringMergeState.map(id => id.toString()),
        componentsWithIndividualFiles: componentsWithIndividualFiles.map(c => c.id.toString()),
        componentsWithTrackDirs: componentsWithTrackDirs.map(c => c.id.toString()),
        softTaggedComponents: softTaggedComponents.map(s => s.toString()),
        snappedComponents: snappedComponents.map(s => s.toString())
      }, null, 2);
    } // If there is problem with at least one component we want to show a link to the
    // troubleshooting doc


    let showTroubleshootingLink = false;

    function format(component, showVersions = false, message) {
      const getBitId = () => {
        if (component instanceof _bitId().BitId) return component;
        if (component instanceof _component().default) return component.id;
        if (component instanceof _models().ModelComponent) return component.toBitId();
        throw new Error(`type of component ${component} is not supported`);
      };

      const bitId = getBitId();
      const issues = componentsWithIssues.find(compWithIssue => compWithIssue.id.isEqual(bitId));
      const softTagged = softTaggedComponents.find(softTaggedId => softTaggedId.isEqual(bitId));
      const messageStatusText = message || 'ok';
      const messageStatusTextWithSoftTag = softTagged ? `${messageStatusText} (soft-tagged)` : messageStatusText;
      const color = message ? 'yellow' : 'green';

      const messageStatus = _chalk().default[color](messageStatusTextWithSoftTag);

      if (component instanceof _bitId().BitId) {
        return `${(0, _chalkBox().formatBitString)(component.toStringWithoutVersion())} ... ${messageStatus}`;
      }

      let bitFormatted = `${(0, _chalkBox().formatNewBit)(component)}`;

      if (showVersions) {
        if (!(component instanceof _models().ModelComponent)) {
          throw new Error(`expect "${component}" to be instance of ModelComponent`);
        }

        const localVersions = component.getLocalTagsOrHashes();
        bitFormatted += `. versions: ${localVersions.join(', ')}`;
      }

      bitFormatted += ' ... ';
      if (!issues) return `${bitFormatted}${messageStatus}`;
      showTroubleshootingLink = true;
      return `${bitFormatted} ${_chalk().default.red(statusFailureMsg)}${(0, _componentIssuesTemplate().formatIssues)(issues)}`;
    }

    const importPendingWarning = importPendingComponents.length ? _chalk().default.yellow(`${_constants().IMPORT_PENDING_MSG}.\n`) : '';
    const splitByMissing = (0, _groupBy2().default)(component => {
      return component.includes(statusFailureMsg) ? 'missing' : 'nonMissing';
    });
    const {
      missing,
      nonMissing
    } = splitByMissing(newComponents.map(c => format(c)));

    const outdatedTitle = _chalk().default.underline.white('pending updates');

    const outdatedDesc = '(use "bit checkout [version] [component_id]" to merge changes)\n(use "bit diff [component_id] [new_version]" to compare changes)\n(use "bit log [component_id]" to list all available versions)\n';
    const outdatedComps = outdatedComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toStringWithoutVersion())} current: ${component.id.version} latest: ${// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      component.latestVersion}\n`;
    }).join('');
    const outdatedStr = outdatedComponents.length ? [outdatedTitle, outdatedDesc, outdatedComps].join('\n') : '';

    const pendingMergeTitle = _chalk().default.underline.white('pending merge');

    const pendingMergeDesc = '(use "bit merge <remote-name>/<lane-name> [component-id]" to merge changes)\n';
    const pendingMergeComps = mergePendingComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toString())} local and remote have diverged and have ${component.diverge.snapsOnLocalOnly.length} and ${component.diverge.snapsOnRemoteOnly.length} different snaps each, respectively\n`;
    }).join('');
    const pendingMergeStr = pendingMergeComps.length ? [pendingMergeTitle, pendingMergeDesc, pendingMergeComps].join('\n') : '';

    const compWithConflictsTitle = _chalk().default.underline.white('components during merge state');

    const compWithConflictsDesc = `(use "bit merge [component-id] --resolve" to mark them as resolved and snap the changes
or use "bit merge [component-id] --abort" to cancel the merge operation)\n`;
    const compWithConflictsComps = componentsDuringMergeState.map(id => {
      return `    > ${_chalk().default.cyan(id.toString())}`;
    }).join('');
    const compWithConflictsStr = compWithConflictsComps.length ? [compWithConflictsTitle, compWithConflictsDesc, compWithConflictsComps].join('\n') : '';
    const newComponentDescription = '\n(use "bit tag --all [version]" to lock a version with all your changes)\n';
    const newComponentsTitle = newComponents.length ? _chalk().default.underline.white('new components') + newComponentDescription : '';
    const newComponentsOutput = [newComponentsTitle, ...(nonMissing || []), ...(missing || [])].join('\n');
    const modifiedDesc = '(use "bit diff" to compare changes)\n';
    const modifiedComponentOutput = (0, _utils().immutableUnshift)(modifiedComponent.map(c => format(c)), modifiedComponent.length ? _chalk().default.underline.white('modified components') + newComponentDescription + modifiedDesc : '').join('\n');
    const autoTagPendingOutput = (0, _utils().immutableUnshift)(autoTagPendingComponents.map(c => format(c)), autoTagPendingComponents.length ? _chalk().default.underline.white('components pending to be tagged automatically (when their dependencies are tagged)') : '').join('\n');
    const invalidDesc = '\nthese components were failed to load.\n';
    const invalidComponentOutput = (0, _utils().immutableUnshift)(invalidComponents.map(c => format(c.id, true, (0, _componentIssuesTemplate().getInvalidComponentLabel)(c.error))).sort(), invalidComponents.length ? _chalk().default.underline.white(statusInvalidComponentsMsg) + invalidDesc : '').join('\n');
    const individualFilesOutput = (0, _utils().immutableUnshift)(componentsWithIndividualFiles.map(c => format(c.id, false, 'individual files')).sort(), componentsWithIndividualFiles.length ? `${_chalk().default.underline.white('components with individual files')}\n${individualFilesDesc}\n` : '').join('\n');
    const trackDirOutput = (0, _utils().immutableUnshift)(componentsWithTrackDirs.map(c => format(c.id, false, 'trackDir record')).sort(), componentsWithTrackDirs.length ? `${_chalk().default.underline.white('components with trackDir record')}\n${trackDirDesc}\n` : '').join('\n');
    const stagedDesc = '\n(use "bit export <remote_scope> to push these components to a remote scope")\n';
    const stagedComponentsOutput = (0, _utils().immutableUnshift)( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    stagedComponents.map(c => format(c, true)), stagedComponents.length ? _chalk().default.underline.white('staged components') + stagedDesc : '').join('\n');
    const snappedDesc = '\n(use "bit tag --all [version]" or "bit tag --snapped [version]" to lock a version)\n';
    const snappedComponentsOutput = (0, _utils().immutableUnshift)( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    snappedComponents.map(c => format(c, true)), snappedComponents.length ? _chalk().default.underline.white('snapped components') + snappedDesc : '').join('\n');
    const troubleshootingStr = showTroubleshootingLink ? `\n${TROUBLESHOOTING_MESSAGE}` : '';
    return importPendingWarning + [outdatedStr, pendingMergeStr, compWithConflictsStr, newComponentsOutput, modifiedComponentOutput, snappedComponentsOutput, stagedComponentsOutput, autoTagPendingOutput, invalidComponentOutput, individualFilesOutput, trackDirOutput].filter(x => x).join(_chalk().default.underline('\n                         \n') + _chalk().default.white('\n')) + troubleshootingStr || _chalk().default.yellow(statusWorkspaceIsCleanMsg);
  }

}

exports.default = Status;