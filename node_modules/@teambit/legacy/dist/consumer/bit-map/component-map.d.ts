import { BitId, BitIds } from '../../bit-id';
import { COMPONENT_ORIGINS } from '../../constants';
import { RemoteLaneId } from '../../lane-id/lane-id';
import { PathLinux, PathLinuxRelative, PathOsBased, PathOsBasedRelative } from '../../utils/path';
import Consumer from '../consumer';
export declare type ComponentOrigin = keyof typeof COMPONENT_ORIGINS;
export declare type ComponentMapFile = {
    name: string;
    relativePath: PathLinux;
    test: boolean;
};
export declare type NextVersion = {
    version: 'patch' | 'minor' | 'major' | 'prerelease' | string;
    preRelease?: string;
    message?: string;
    username?: string;
    email?: string;
};
declare type LaneVersion = {
    remoteLane: RemoteLaneId;
    version: string;
};
export declare type ComponentMapData = {
    id: BitId;
    files: ComponentMapFile[];
    mainFile: PathLinux;
    rootDir?: PathLinux;
    trackDir?: PathLinux;
    origin: ComponentOrigin;
    originallySharedDir?: PathLinux;
    wrapDir?: PathLinux;
    exported?: boolean;
    onLanesOnly: boolean;
    lanes?: LaneVersion[];
    defaultVersion?: string;
    isAvailableOnCurrentLane?: boolean;
    nextVersion?: NextVersion;
};
export declare type PathChange = {
    from: PathLinux;
    to: PathLinux;
};
export default class ComponentMap {
    id: BitId;
    files: ComponentMapFile[];
    mainFile: PathLinux;
    rootDir?: PathLinux;
    trackDir: PathLinux | undefined;
    origin: ComponentOrigin;
    originallySharedDir: PathLinux | undefined;
    wrapDir: PathLinux | undefined;
    markBitMapChangedCb: Function;
    exported: boolean | null | undefined;
    onLanesOnly?: boolean | undefined;
    lanes: LaneVersion[];
    defaultVersion?: string | null;
    isAvailableOnCurrentLane?: boolean | undefined;
    nextVersion?: NextVersion;
    recentlyTracked?: boolean;
    scope?: string | null;
    version?: string;
    noFilesError?: Error;
    constructor({ id, files, mainFile, rootDir, trackDir, origin, originallySharedDir, wrapDir, onLanesOnly, lanes, defaultVersion, isAvailableOnCurrentLane, nextVersion, }: ComponentMapData);
    static fromJson(componentMapObj: Omit<ComponentMapData, 'lanes'> & {
        lanes: Array<{
            remoteLane: string;
            version: string;
        }>;
    }): ComponentMap;
    toPlainObject(isLegacy: boolean): Record<string, any>;
    static getPathWithoutRootDir(rootDir: PathLinux, filePath: PathLinux): PathLinux;
    static changeFilesPathAccordingToItsRootDir(existingRootDir: PathLinux, files: ComponentMapFile[]): PathChange[];
    setMarkAsChangedCb(markAsChangedBinded: Function): void;
    _findFile(fileName: PathLinux): ComponentMapFile | undefined;
    changeRootDirAndUpdateFilesAccordingly(newRootDir: PathLinuxRelative): void;
    addRootDirToDistributedFiles(rootDir: PathOsBased): void;
    updateFileLocation(fileFrom: PathOsBased, fileTo: PathOsBased): PathChange[];
    updateDirLocation(dirFrom: PathOsBasedRelative, dirTo: PathOsBasedRelative): PathChange[];
    getFilesRelativeToConsumer(): PathLinux[];
    getAllFilesPaths(): PathLinux[];
    getFilesGroupedByBeingTests(): {
        allFiles: string[];
        nonTestsFiles: string[];
        testsFiles: string[];
    };
    removeTrackDirIfNeeded(): void;
    getTrackDir(): PathLinux | undefined;
    getRootDir(): PathLinuxRelative;
    hasRootDir(): boolean;
    getComponentDir(): PathLinux | undefined;
    doesAuthorHaveRootDir(): boolean;
    updatePerLane(currentRemote?: RemoteLaneId | null, currentLaneIds?: BitIds | null): void;
    addLane(remoteLaneId: RemoteLaneId, version: string): void;
    trackDirectoryChangesLegacy(consumer: Consumer, id: BitId): Promise<void>;
    trackDirectoryChangesHarmony(consumer: Consumer, id: BitId): Promise<void>;
    updateNextVersion(nextVersion: NextVersion): void;
    clearNextVersion(): void;
    removeFiles(files: ComponentMapFile[]): void;
    sort(): void;
    clone(): ComponentMap;
    validate(): void;
}
export {};
