import { IssuesList } from '@teambit/component-issues';
import { Dependency } from '..';
import { BitId } from '../../../../bit-id';
import Consumer from '../../../../consumer/consumer';
import { PathLinux, PathLinuxRelative, PathOsBased } from '../../../../utils/path';
import ComponentMap from '../../../bit-map/component-map';
import Component from '../../../component/consumer-component';
import { RelativePath } from '../dependency';
import { FileObject, ImportSpecifier, DependenciesTree } from '../files-dependency-builder/types/dependency-tree-type';
import OverridesDependencies from './overrides-dependencies';
import { ResolvedPackageData } from '../../../../utils/packages';
import { DependenciesData } from './dependencies-data';
export declare type AllDependencies = {
    dependencies: Dependency[];
    devDependencies: Dependency[];
};
export declare type AllPackagesDependencies = {
    packageDependencies: Record<string, any> | null | undefined;
    devPackageDependencies: Record<string, any> | null | undefined;
    compilerPackageDependencies: Record<string, any> | null | undefined;
    testerPackageDependencies: Record<string, any> | null | undefined;
    peerPackageDependencies: Record<string, any> | null | undefined;
};
export declare type FileType = {
    isTestFile: boolean;
};
export declare type DebugDependencies = {
    components: DebugComponentsDependency[];
    unidentifiedPackages?: string[];
};
export declare type DebugComponentsDependency = {
    id: BitId;
    importSource?: string;
    dependencyPackageJsonPath?: string;
    dependentPackageJsonPath?: string;
    versionResolvedFrom?: 'DependencyPkgJson' | 'DependentPkgJson' | 'BitMap' | 'Model' | string;
    version?: string;
    componentIdResolvedFrom?: 'DependencyPkgJson' | 'DependencyPath' | 'LegacyUnknown';
    packageName?: string;
};
declare type WorkspacePolicyGetter = () => {
    dependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
};
export default class DependencyResolver {
    component: Component;
    consumer: Consumer;
    componentId: BitId;
    componentMap: ComponentMap;
    componentFromModel: Component;
    consumerPath: PathOsBased;
    tree: DependenciesTree;
    allDependencies: AllDependencies;
    allPackagesDependencies: AllPackagesDependencies;
    issues: IssuesList;
    coreAspects: string[];
    processedFiles: string[];
    compilerFiles: PathLinux[];
    testerFiles: PathLinux[];
    overridesDependencies: OverridesDependencies;
    debugDependenciesData: DebugDependencies;
    static getWorkspacePolicy: WorkspacePolicyGetter;
    static registerWorkspacePolicyGetter(func: WorkspacePolicyGetter): void;
    static getDepResolverAspectName: () => string;
    static getCoreAspectsPackagesAndIds: () => Record<string, string>;
    static getDevFiles: (component: Component) => Promise<string[]>;
    constructor(component: Component, consumer: Consumer);
    setTree(tree: DependenciesTree): void;
    getDependenciesData(cacheResolvedDependencies: Record<string, any>, cacheProjectAst: Record<string, any> | undefined): Promise<DependenciesData>;
    populateDependencies(files: string[], testsFiles: string[]): void;
    addCustomResolvedIssues(): void;
    removeIgnoredPackagesByOverrides(): void;
    throwForNonExistFile(file: string): void;
    manuallyAddDependencies(): void;
    applyOverridesOnEnvPackages(): void;
    traverseTreeForComponentId(depFile: PathLinux): BitId | undefined;
    getComponentIdByResolvedPackageData(bit: ResolvedPackageData): BitId;
    getComponentIdByDepFile(depFile: PathLinux): {
        componentId: BitId | null | undefined;
        depFileRelative: PathLinux;
        destination: string | null | undefined;
    };
    _getComponentIdFromCustomResolveToPackageWithDist(depFile: string): BitId | null | undefined;
    getDependencyPathsFromModel(componentId: BitId, depFile: PathLinux, rootDir: PathLinux): {
        componentId: BitId;
        destination: string;
        depFileRelative: string;
    };
    processDepFiles(originFile: PathLinuxRelative, fileType: FileType, nested?: boolean): void;
    processOneDepFile(originFile: PathLinuxRelative, depFile: string, importSpecifiers: ImportSpecifier[] | undefined, linkFile: string | undefined, fileType: FileType, depFileObject: FileObject, nested?: boolean): boolean;
    processLinkFile(originFile: PathLinuxRelative, linkFile: FileObject, fileType: FileType): void;
    processComponents(originFile: PathLinuxRelative, fileType: FileType): void;
    private addImportNonMainIssueIfNeeded;
    private getValidVersion;
    processPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    processMissing(originFile: PathLinuxRelative, fileType: FileType): void;
    _addToMissingComponentsIfNeeded(missingComponents: string[], originFile: string, fileType: FileType): void;
    processErrors(originFile: PathLinuxRelative): void;
    processCoreAspects(originFile: PathLinuxRelative): void;
    processUnidentifiedPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    private _pushToDependenciesIfNotExist;
    pushToDependenciesArray(currentComponentsDeps: Dependency, fileType: FileType, depDebug: DebugComponentsDependency): void;
    removeDevAndEnvDepsIfTheyAlsoRegulars(): void;
    findOriginallyCustomModuleResolvedDependencies(packages: string[]): Record<string, any> | null | undefined;
    getExistingDependency(dependencies: Dependency[], id: BitId): Dependency | null | undefined;
    getExistingDepRelativePaths(dependency: Dependency, relativePath: RelativePath): RelativePath | null | undefined;
    getDiffSpecifiers(originSpecifiers: ImportSpecifier[], targetSpecifiers: ImportSpecifier[]): any;
    populatePeerPackageDependencies(): void;
    applyWorkspacePolicy(): void;
    _getPackageJson(): Record<string, any> | undefined;
    private setLegacyInsideHarmonyIssue;
    _addTypesPackagesForTypeScript(packages: Record<string, any>, originFile: PathLinuxRelative): void;
    _pkgFieldMapping(field: string): "packageDependencies" | "devPackageDependencies" | "peerPackageDependencies";
    _pushToUntrackDependenciesIssues(originFile: PathLinuxRelative, depFileRelative: any, nested?: boolean): void;
    _pushToRelativeComponentsIssues(originFile: any, componentId: BitId): void;
    _pushToRelativeComponentsAuthoredIssues(originFile: any, componentId: any, importSource: string, relativePath: RelativePath): void;
    _pushToMissingDependenciesOnFs(originFile: PathLinuxRelative, missingFiles: string[]): void;
    _pushToMissingPackagesDependenciesIssues(originFile: PathLinuxRelative, missingPackages: string[]): void;
    _pushToMissingCustomModuleIssues(originFile: PathLinuxRelative, componentId: string): void;
    _pushToMissingLinksIssues(originFile: PathLinuxRelative, componentId: BitId): void;
    _pushToMissingComponentsIssues(originFile: PathLinuxRelative, componentId: BitId): void;
}
export {};
