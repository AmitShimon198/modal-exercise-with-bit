import semver, { ReleaseType } from 'semver';
import { BitId, BitIds } from '../bit-id';
import { BitIdStr } from '../bit-id/bit-id';
import { LocalLaneId } from '../lane-id/lane-id';
import CompilerExtension from '../legacy-extensions/compiler-extension';
import EnvExtension from '../legacy-extensions/env-extension';
import { EnvType } from '../legacy-extensions/env-extension-types';
import TesterExtension from '../legacy-extensions/tester-extension';
import { ComponentWithDependencies, Scope } from '../scope';
import { AutoTagResult } from '../scope/component-ops/auto-tag';
import { Lane, ModelComponent, Version } from '../scope/models';
import { PathAbsolute, PathLinuxRelative, PathOsBased, PathOsBasedAbsolute, PathOsBasedRelative, PathRelative } from '../utils/path';
import BitMap from './bit-map/bit-map';
import Component from './component';
import { ComponentStatus, ComponentStatusLoader, ComponentStatusResult } from './component-ops/component-status-loader';
import ComponentLoader from './component/component-loader';
import { InvalidComponent } from './component/consumer-component';
import { ILegacyWorkspaceConfig } from './config';
import { WorkspaceConfigProps } from './config/workspace-config';
import DirStructure from './dir-structure/dir-structure';
import { BasicTagParams } from '../api/consumer/lib/tag';
declare type ConsumerProps = {
    projectPath: string;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    created?: boolean;
    isolated?: boolean;
    addedGitHooks?: string[] | undefined;
    existingGitHooks: string[] | undefined;
};
export default class Consumer {
    projectPath: PathOsBased;
    created: boolean;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    bitMap: BitMap;
    isolated: boolean;
    addedGitHooks: string[] | undefined;
    existingGitHooks: string[] | undefined;
    _dirStructure: DirStructure;
    _componentsStatusCache: Record<string, any>;
    packageManagerArgs: string[];
    componentLoader: ComponentLoader;
    componentStatusLoader: ComponentStatusLoader;
    packageJson: any;
    onCacheClear: Array<() => void>;
    constructor({ projectPath, config, scope, created, isolated, addedGitHooks, existingGitHooks, }: ConsumerProps);
    setBitMap(): Promise<void>;
    get compiler(): Promise<CompilerExtension | undefined>;
    get tester(): Promise<TesterExtension | undefined>;
    get dirStructure(): DirStructure;
    get componentFsCache(): import("./component/component-fs-cache").ComponentFsCache;
    get bitmapIdsFromCurrentLane(): BitIds;
    get bitMapIdsFromAllLanes(): BitIds;
    clearCache(): void;
    getEnv(envType: EnvType, context: Record<string, any> | undefined): Promise<EnvExtension | undefined>;
    getTmpFolder(fullPath?: boolean): PathOsBased;
    getCurrentLaneId(): LocalLaneId;
    getCurrentLaneObject(): Promise<Lane | null>;
    cleanTmpFolder(): Promise<void>;
    migrate(verbose: any): Record<string, any>;
    write(): Promise<Consumer>;
    getPath(): PathOsBased;
    toAbsolutePath(pathStr: PathRelative): PathOsBasedAbsolute;
    getPathRelativeToConsumer(pathToCheck: PathRelative | PathAbsolute): PathOsBasedRelative;
    getParsedId(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId;
    getParsedIdIfExist(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId | undefined;
    loadComponentFromModel(id: BitId): Promise<Component>;
    loadComponentFromModelIfExist(id: BitId): Promise<Component | undefined>;
    loadAllVersionsOfComponentFromModel(id: BitId): Promise<Component[]>;
    loadComponentWithDependenciesFromModel(id: BitId, throwIfNotExist?: boolean): Promise<ComponentWithDependencies>;
    loadComponent(id: BitId): Promise<Component>;
    loadComponentForCapsule(id: BitId): Promise<Component>;
    loadComponents(ids: BitIds, throwOnFailure?: boolean): Promise<{
        components: Component[];
        invalidComponents: InvalidComponent[];
    }>;
    importEnvironment(bitId: BitId, verbose: boolean | undefined, dontPrintEnvMsg: boolean): Promise<ComponentWithDependencies[]>;
    importComponents(ids: BitIds, withAllVersions: boolean, saveDependenciesAsComponents?: boolean): Promise<ComponentWithDependencies[]>;
    importComponentsObjectsHarmony(ids: BitIds, fromOriginalScope?: boolean, allHistory?: boolean): Promise<ComponentWithDependencies[]>;
    shouldDependenciesSavedAsComponents(bitIds: BitId[], saveDependenciesAsComponents?: boolean): Promise<{
        id: BitId;
        saveDependenciesAsComponents: boolean;
    }[]>;
    shouldDistsBeInsideTheComponent(): boolean;
    listComponentsForAutoTagging(modifiedComponents: BitIds): Promise<Component[]>;
    isComponentModified(componentFromModel: Version, componentFromFileSystem: Component): Promise<boolean>;
    getManyComponentsStatuses(ids: BitId[]): Promise<ComponentStatusResult[]>;
    getComponentStatusById(id: BitId): Promise<ComponentStatus>;
    tag(tagParams: {
        ids: BitIds;
        exactVersion: string | undefined;
        releaseType: semver.ReleaseType;
        incrementBy?: number;
        ignoreIssues: boolean | undefined;
    } & BasicTagParams): Promise<{
        taggedComponents: Component[];
        autoTaggedResults: AutoTagResult[];
        isSoftTag: boolean;
        publishedPackages: string[];
    }>;
    private throwForComponentIssues;
    updateNextVersionOnBitmap(taggedComponents: Component[], exactVersion?: string | null, releaseType?: ReleaseType, preRelease?: string): void;
    snap({ ids, message, ignoreIssues, force, skipTests, verbose, build, skipAutoSnap, resolveUnmerged, disableTagAndSnapPipelines, forceDeploy, }: {
        ids: BitIds;
        message?: string;
        ignoreIssues?: boolean;
        force?: boolean;
        skipTests?: boolean;
        verbose?: boolean;
        build: boolean;
        skipAutoSnap?: boolean;
        resolveUnmerged?: boolean;
        disableTagAndSnapPipelines?: boolean;
        forceDeploy?: boolean;
    }): Promise<{
        snappedComponents: Component[];
        autoSnappedResults: AutoTagResult[];
    }>;
    _loadComponentsForTag(ids: BitIds): Promise<Component[]>;
    updateComponentsVersions(components: Array<ModelComponent | Component>): Promise<any>;
    getComponentIdFromNodeModulesPath(requirePath: string, bindingPrefix: string): BitId;
    splitPackagePathToNameAndFile(packagePath: string): {
        packageName: string;
        internalPath: string;
    };
    private stripNodeModulesFromPackagePath;
    composeRelativeComponentPath(bitId: BitId): PathLinuxRelative;
    composeComponentPath(bitId: BitId): PathOsBasedAbsolute;
    composeRelativeDependencyPath(bitId: BitId): PathOsBased;
    composeDependencyPath(bitId: BitId): PathOsBased;
    static create(projectPath: PathOsBasedAbsolute, noGit?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    static _getScopePath(projectPath: PathOsBasedAbsolute, noGit: boolean): PathOsBasedAbsolute;
    static ensure(projectPath: PathOsBasedAbsolute, standAlone?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    static reset(projectPath: PathOsBasedAbsolute, resetHard: boolean, noGit?: boolean): Promise<void>;
    resetNew(): Promise<void>;
    static createIsolatedWithExistingScope(consumerPath: PathOsBased, scope: Scope): Promise<Consumer>;
    static locateProjectScope(projectPath: string): string | undefined;
    static load(currentPath: PathOsBasedAbsolute): Promise<Consumer>;
    get isLegacy(): boolean;
    cleanFromBitMap(componentsToRemoveFromFs: BitIds, removedDependencies: BitIds): Promise<void>;
    addRemoteAndLocalVersionsToDependencies(component: Component, loadedFromFileSystem: boolean): Promise<void>;
    getAuthoredAndImportedDependentsIdsOf(components: Component[]): Promise<BitIds>;
    getAuthoredAndImportedDependentsComponentsOf(components: Component[]): Promise<Component[]>;
    injectConf(componentId: BitId, force: boolean): Promise<any>;
    _getEnvProps(envType: EnvType, context: Record<string, any> | undefined): {
        name: string;
        consumerPath: string;
        scopePath: string;
        rawConfig: Record<string, any>;
        files: string[];
        bitJsonPath: string;
        options: import("../legacy-extensions/base-extension").BaseExtensionOptions;
        envType: EnvType;
        context: Record<string, any> | undefined;
    } | undefined;
    writeBitMap(): Promise<void>;
    onDestroy(): Promise<void>;
}
export {};
