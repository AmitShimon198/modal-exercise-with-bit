"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLanes = mergeLanes;

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = _interopRequireWildcard(require("../../lane-id/lane-id"));

  _laneId = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("../../scope/repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _mergeSnaps() {
  const data = require("../versions-ops/merge-version/merge-snaps");

  _mergeSnaps = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function mergeLanes({
  consumer,
  mergeStrategy,
  laneName,
  remoteName,
  noSnap,
  snapMessage,
  existingOnWorkspaceOnly,
  build
}) {
  const currentLaneId = consumer.getCurrentLaneId();

  if (!remoteName && laneName === currentLaneId.name) {
    throw new (_generalError().default)(`unable to switch to lane "${laneName}", you're already checked out to this lane`);
  }

  const localLaneId = consumer.getCurrentLaneId();
  const localLane = currentLaneId.isDefault() ? null : await consumer.scope.loadLane(localLaneId);
  const laneId = new (_laneId().default)({
    name: laneName
  });
  let bitIds;
  let otherLane;
  let remoteLane;
  let otherLaneName;

  if (remoteName) {
    const remoteLaneId = _laneId().RemoteLaneId.from(laneId.name, remoteName);

    remoteLane = await consumer.scope.objects.remoteLanes.getRemoteLane(remoteLaneId);

    if (!remoteLane.length) {
      throw new (_generalError().default)(`unable to switch to "${laneName}" of "${remoteName}", the remote lane was not found or not fetched locally`);
    }

    bitIds = await consumer.scope.objects.remoteLanes.getRemoteBitIds(remoteLaneId);
    otherLaneName = `${remoteName}/${laneId.name}`;
  } else {
    otherLane = await consumer.scope.loadLane(laneId);
    if (!otherLane) throw new (_generalError().default)(`unable to switch to "${laneName}", the lane was not found`);
    bitIds = otherLane.components.map(c => c.id.changeVersion(c.head.toString()));
    otherLaneName = laneId.name;
  }

  const allComponentsStatus = await getAllComponentsStatus();
  return (0, _mergeSnaps().merge)({
    consumer,
    mergeStrategy,
    allComponentsStatus,
    remoteName,
    laneId,
    localLane,
    noSnap,
    snapMessage,
    build
  });

  async function getAllComponentsStatus() {
    const tmp = new (_repositories().Tmp)(consumer.scope);

    try {
      const componentsStatus = await Promise.all(bitIds.map(bitId => (0, _mergeSnaps().getComponentStatus)(consumer, bitId, localLane, otherLaneName, existingOnWorkspaceOnly)));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
}