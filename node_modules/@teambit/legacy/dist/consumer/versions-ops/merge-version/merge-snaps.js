"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeComponentsFromRemote = mergeComponentsFromRemote;
exports.merge = merge;
exports.getComponentStatus = getComponentStatus;
exports.applyVersion = applyVersion;
exports.abortMerge = abortMerge;
exports.resolveMerge = resolveMerge;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _getDivergeData() {
  const data = require("../../../scope/component-ops/get-diverge-data");

  _getDivergeData = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../../../scope/objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("../../../scope/repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../../component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = _interopRequireWildcard(require("../checkout-version"));

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("./merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _threeWayMerge() {
  const data = _interopRequireDefault(require("./three-way-merge"));

  _threeWayMerge = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * when user is on main, it merges the remote main components into local.
 * when user is on a lane, it merges the remote lane components into the local lane.
 */
async function mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, snapMessage, build) {
  const localLaneId = consumer.getCurrentLaneId();
  const localLaneObject = await consumer.getCurrentLaneObject();
  const remoteTrackedLane = consumer.scope.lanes.getRemoteTrackedDataByLocalLane(localLaneId.name);

  if (!localLaneId.isDefault() && !remoteTrackedLane) {
    throw new Error(`unable to find a remote tracked to the local lane "${localLaneId.name}"`);
  }

  const allComponentsStatus = await getAllComponentsStatus();
  return merge({
    consumer,
    mergeStrategy,
    allComponentsStatus,
    remoteName: remoteTrackedLane ? remoteTrackedLane.remoteScope : null,
    laneId: localLaneId,
    localLane: localLaneObject,
    noSnap,
    snapMessage,
    build
  });

  async function getAllComponentsStatus() {
    const tmp = new (_repositories().Tmp)(consumer.scope);

    try {
      const componentsStatus = await Promise.all(bitIds.map(async bitId => {
        const remoteLaneName = remoteTrackedLane ? remoteTrackedLane.remoteLane : localLaneId.name;
        const remoteScopeName = remoteTrackedLane ? remoteTrackedLane.remoteScope : bitId.scope;

        const remoteLaneId = _laneId().RemoteLaneId.from(remoteLaneName, remoteScopeName);

        const remoteHead = await consumer.scope.objects.remoteLanes.getRef(remoteLaneId, bitId);
        const remoteLaneIdStr = remoteLaneId.toString();
        if (!remoteHead) throw new (_generalError().default)(`unable to find a remote head of "${bitId.toStringWithoutVersion()}" in "${remoteLaneIdStr}"`);
        return getComponentStatus(consumer, bitId.changeVersion(remoteHead.toString()), localLaneObject, remoteLaneIdStr);
      }));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
}

async function merge({
  consumer,
  mergeStrategy,
  allComponentsStatus,
  remoteName,
  laneId,
  localLane,
  noSnap,
  snapMessage,
  build
}) {
  const componentWithConflict = allComponentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);

  if (componentWithConflict && !mergeStrategy) {
    mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
  }

  const failedComponents = allComponentsStatus.filter(componentStatus => componentStatus.failureMessage).map(componentStatus => ({
    id: componentStatus.id,
    failureMessage: componentStatus.failureMessage
  }));
  const succeededComponents = allComponentsStatus.filter(componentStatus => !componentStatus.failureMessage); // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,
  // which can be an issue when some components are also dependencies of others

  const componentsResults = await (0, _pMapSeries().default)(succeededComponents, ({
    componentFromFS,
    id,
    mergeResults
  }) => {
    return applyVersion({
      consumer,
      componentFromFS,
      id,
      mergeResults,
      mergeStrategy,
      remoteHead: new (_objects().Ref)(id.version),
      // @ts-ignore
      remoteName: remoteName || componentFromFS.scope,
      laneId,
      localLane
    });
  });
  if (localLane) consumer.scope.objects.add(localLane);
  await consumer.scope.objects.persist(); // persist anyway, it localLane is null it should save all main heads

  await consumer.scope.objects.unmergedComponents.write();
  const mergeSnapResults = noSnap ? null : await snapResolvedComponents(consumer, snapMessage, build);
  return {
    components: componentsResults,
    failedComponents,
    mergeSnapResults
  };
}

async function getComponentStatus(consumer, id, localLane, otherLaneName, existingOnWorkspaceOnly = false) {
  const componentStatus = {
    id
  };

  const returnFailure = msg => {
    componentStatus.failureMessage = msg;
    return componentStatus;
  };

  const modelComponent = await consumer.scope.getModelComponentIfExist(id);

  if (!modelComponent) {
    throw new (_generalError().default)(`component ${id.toString()} is on the lane but its objects were not found, please re-import the lane`);
  }

  const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);

  if (unmerged && unmerged.resolved === false) {
    return returnFailure(`component ${id.toStringWithoutVersion()} has conflicts that need to be resolved first, please use bit merge --resolve/--abort`);
  }

  const version = id.version;
  const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, {
    ignoreVersion: true
  });
  const componentOnLane = await modelComponent.loadVersion(version, consumer.scope.objects);

  if (!existingBitMapId) {
    if (existingOnWorkspaceOnly) {
      return returnFailure(`component ${id.toStringWithoutVersion()} is not in the workspace`);
    } // @ts-ignore


    return {
      componentFromFS: null,
      componentFromModel: componentOnLane,
      id,
      mergeResults: null
    };
  }

  const currentlyUsedVersion = existingBitMapId.version;

  if (currentlyUsedVersion === version) {
    // @todo: maybe this check is not needed as we check for diverge later on
    if (localLane || modelComponent.hasHead()) {
      return returnFailure(`component ${id.toStringWithoutVersion()} is already merged`);
    }
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  const component = await consumer.loadComponent(existingBitMapId);
  const componentModificationStatus = await consumer.getComponentStatusById(component.id);

  if (componentModificationStatus.modified) {
    throw new (_generalError().default)(`unable to merge ${id.toStringWithoutVersion()}, the component is modified, please snap/tag it first`);
  }

  const repo = consumer.scope.objects;

  if (localLane) {
    modelComponent.setLaneHeadLocal(localLane);

    if (modelComponent.laneHeadLocal && modelComponent.laneHeadLocal.toString() !== existingBitMapId.version) {
      throw new (_generalError().default)(`unable to merge ${id.toStringWithoutVersion()}, the component is checkout to a different version than the lane head. please run "bit checkout your-lane --lane" first`);
    }
  }

  const otherLaneHead = new (_objects().Ref)(version);
  const divergeData = await (0, _getDivergeData().getDivergeData)(repo, modelComponent, otherLaneHead);

  if (!divergeData.isDiverged()) {
    if (divergeData.isLocalAhead()) {
      // do nothing!
      return returnFailure(`component ${component.id.toString()} is ahead, nothing to merge`);
    }

    if (divergeData.isRemoteAhead()) {
      // just override with the model data
      return {
        componentFromFS: component,
        componentFromModel: componentOnLane,
        id,
        mergeResults: null
      };
    } // we know that localHead and remoteHead are set, so if none of them is ahead they must be equal


    return returnFailure(`component ${component.id.toString()} is already merged`);
  }

  const baseSnap = divergeData.commonSnapBeforeDiverge; // must be set when isTrueMerge

  const baseComponent = await modelComponent.loadVersion(baseSnap.toString(), repo);
  const currentComponent = await modelComponent.loadVersion(otherLaneHead.toString(), repo); // threeWayMerge expects `otherComponent` to be Component and `currentComponent` to be Version
  // since it doesn't matter whether we take the changes from base to current or the changes from
  // base to other, here we replace the two. the result is going to be the same.

  const mergeResults = await (0, _threeWayMerge().default)({
    consumer,
    otherComponent: component,
    // this is actually the current
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    otherLabel: `${currentlyUsedVersion} (local)`,
    currentComponent,
    // this is actually the other
    currentLabel: `${otherLaneHead.toString()} (${otherLaneName})`,
    baseComponent
  });
  return {
    componentFromFS: component,
    id,
    mergeResults
  };
}

async function applyVersion({
  consumer,
  componentFromFS,
  id,
  mergeResults,
  mergeStrategy,
  remoteHead,
  remoteName,
  laneId,
  localLane
}) {
  const filesStatus = {};
  const unmergedComponent = {
    // @ts-ignore
    id: {
      name: id.name,
      scope: id.scope
    },
    // @ts-ignore
    head: remoteHead,
    // @ts-ignore
    remote: remoteName,
    lane: laneId.name
  };
  id = componentFromFS ? componentFromFS.id : id;

  if (mergeResults && mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.ours) {
    if (!componentFromFS) throw new Error(`applyVersion expect to get componentFromFS for ${id.toString()}`);
    componentFromFS.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.unchanged;
    });
    unmergedComponent.resolved = true;
    consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
    return {
      id,
      filesStatus
    };
  }

  const remoteId = id.changeVersion(remoteHead.toString());
  const idToLoad = !mergeResults || mergeStrategy === _mergeVersion().MergeOptions.theirs ? remoteId : id;
  const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(idToLoad);
  const componentMap = componentFromFS && componentFromFS.componentMap;
  if (componentFromFS && !componentMap) throw new (_generalError().default)('applyVersion: componentMap was not found');

  if (componentMap && componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && !id.scope) {
    componentWithDependencies.dependencies = [];
    componentWithDependencies.devDependencies = [];
  }

  const shouldWritePackageJson = async () => {
    if (!componentMap) return true;
    const rootDir = componentMap && componentMap.rootDir;
    if (!rootDir) return false;

    const packageJsonPath = _path().default.join(consumer.getPath(), rootDir, 'package.json');

    return _fsExtra().default.pathExists(packageJsonPath);
  };

  const shouldInstallNpmPackages = () => {
    if (componentMap && componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) return false;
    return true;
  };

  const writePackageJson = await shouldWritePackageJson();
  const files = componentWithDependencies.component.files;
  files.forEach(file => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.updated;
  });
  let modifiedStatus = {};

  if (mergeResults) {
    // update files according to the merge results
    modifiedStatus = (0, _checkoutVersion().applyModifiedVersion)(files, mergeResults, mergeStrategy, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    componentWithDependencies.component.originallySharedDir);
  }

  const shouldDependenciesSaveAsComponents = await consumer.shouldDependenciesSavedAsComponents([id]);
  componentWithDependencies.component.dependenciesSavedAsComponents = shouldDependenciesSaveAsComponents[0].saveDependenciesAsComponents;
  const manyComponentsWriter = new (_manyComponentsWriter().default)({
    consumer,
    componentsWithDependencies: [componentWithDependencies],
    installNpmPackages: shouldInstallNpmPackages(),
    override: true,
    writeConfig: false,
    // @todo: should write if config exists before, needs to figure out how to do it.
    verbose: false,
    // @todo: do we need a flag here?
    writeDists: true,
    // @todo: do we need a flag here?
    writePackageJson
  });
  await manyComponentsWriter.writeAll(); // if mergeResults, the head snap is going to be updated on a later phase when snapping with two parents
  // otherwise, update the head of the current lane or main

  if (mergeResults) {
    if (mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.manual) {
      unmergedComponent.resolved = false;
      unmergedComponent.unmergedPaths = mergeResults.modifiedFiles.filter(f => f.conflict).map(f => f.filePath);
    } else {
      unmergedComponent.resolved = true;
    }

    consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
  } else if (localLane) {
    localLane.addComponent({
      id,
      head: remoteHead
    });
  } else {
    // this is main
    const modelComponent = await consumer.scope.getModelComponent(id);
    if (!consumer.isLegacy) modelComponent.setHead(remoteHead);
    consumer.scope.objects.add(modelComponent);
  }

  return {
    id,
    filesStatus: Object.assign(filesStatus, modifiedStatus)
  };
}

async function snapResolvedComponents(consumer, snapMessage, build) {
  const resolvedComponents = consumer.scope.objects.unmergedComponents.getResolvedComponents();

  _logger().default.debug(`merge-snaps, snapResolvedComponents, total ${resolvedComponents.length.toString()} components`);

  if (!resolvedComponents.length) return null;

  const ids = _bitId().BitIds.fromArray(resolvedComponents.map(r => new (_bitId().BitId)(r.id)));

  return consumer.snap({
    ids,
    build,
    message: snapMessage
  });
}

async function abortMerge(consumer, values) {
  const ids = getIdsForUnresolved(consumer, values); // @ts-ignore not clear yet what to do with other flags

  const results = await (0, _checkoutVersion().default)(consumer, {
    ids,
    reset: true
  });
  ids.forEach(id => consumer.scope.objects.unmergedComponents.removeComponent(id.name));
  await consumer.scope.objects.unmergedComponents.write();
  return {
    abortedComponents: results.components
  };
}

async function resolveMerge(consumer, values, snapMessage, build) {
  const ids = getIdsForUnresolved(consumer, values);
  const {
    snappedComponents
  } = await consumer.snap({
    ids: _bitId().BitIds.fromArray(ids),
    resolveUnmerged: true,
    build,
    message: snapMessage
  });
  return {
    resolvedComponents: snappedComponents
  };
}

function getIdsForUnresolved(consumer, idsStr) {
  if (idsStr && idsStr.length) {
    const bitIds = idsStr.map(id => consumer.getParsedId(id));
    bitIds.forEach(id => {
      const entry = consumer.scope.objects.unmergedComponents.getEntry(id.name);

      if (!entry) {
        throw new (_generalError().default)(`unable to merge-resolve ${id.toString()}, it is not marked as unresolved`);
      }
    });
    return bitIds;
  }

  const unresolvedComponents = consumer.scope.objects.unmergedComponents.getComponents();
  if (!unresolvedComponents.length) throw new (_generalError().default)(`all components are resolved already, nothing to do`);
  return unresolvedComponents.map(u => new (_bitId().BitId)(u.id));
}