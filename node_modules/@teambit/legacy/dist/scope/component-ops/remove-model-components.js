"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));

  _reject2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../models");

  _models = function () {
    return data;
  };

  return data;
}

function _removedComponents() {
  const data = _interopRequireDefault(require("../removed-components"));

  _removedComponents = function () {
    return data;
  };

  return data;
}

class RemoveModelComponents {
  constructor(scope, bitIds, force, removeSameOrigin, consumer) {
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitIds", void 0);
    (0, _defineProperty2().default)(this, "force", void 0);
    (0, _defineProperty2().default)(this, "removeSameOrigin", false);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "currentLane", null);
    this.scope = scope;
    this.bitIds = bitIds;
    this.force = force;
    this.removeSameOrigin = removeSameOrigin;
    this.consumer = consumer;
  }

  async setCurrentLane() {
    this.currentLane = await this.scope.lanes.getCurrentLaneObject();
  }

  async remove() {
    const {
      missingComponents,
      foundComponents
    } = await this.scope.filterFoundAndMissingComponents(this.bitIds);
    await this.setCurrentLane();
    const dependentBits = await this.scope.findDependentBits(foundComponents);

    if ((0, _isEmpty2().default)(dependentBits) || this.force) {
      // do not run this in parallel (promise.all), otherwise, it may throw an error when
      // trying to delete the same file at the same time (happens when removing a component with
      // a dependency and the dependency itself)
      const removalData = await (0, _pMapSeries().default)(foundComponents, bitId => this.getRemoveSingleData(bitId));
      const compIds = new (_bitId().BitIds)(...removalData.map(x => x.compId));
      const depsIds = new (_bitId().BitIds)(...removalData.map(x => x.depIds).flat());
      const allIds = [...compIds, ...depsIds];
      const refsToRemoveAll = removalData.map(removed => removed.refsToRemove).flat();

      if (this.currentLane) {
        await this.scope.objects.writeObjectsToTheFS([this.currentLane]);
      }

      await this.scope.objects.deleteObjectsFromFS(refsToRemoveAll);
      await this.scope.objects.deleteRecordsFromUnmergedComponents(allIds.map(id => id.name));
      const removedFromLane = Boolean(this.currentLane && foundComponents.length);
      return new (_removedComponents().default)({
        removedComponentIds: compIds,
        missingComponents,
        removedDependencies: depsIds,
        removedFromLane
      });
    } // some of the components have dependents, don't remove them


    return new (_removedComponents().default)({
      missingComponents,
      dependentBits
    });
  }
  /**
   * removeSingle - remove single component
   * @param {BitId} bitId - list of remote component ids to delete
   * @param {boolean} removeSameOrigin - remove component dependencies from same origin
   */


  async getRemoveSingleData(bitId) {
    _logger().default.debug(`scope.removeSingle ${bitId.toString()}, remove dependencies: ${this.removeSameOrigin.toString()}`); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    const component = (await this.scope.getModelComponentIfExist(bitId)).toComponentVersion(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const consumerComponentToRemove = await component.toConsumer(this.scope.objects);
    const componentList = await this.scope.listIncludesSymlinks();
    const dependentBits = await this.scope.findDependentBits(consumerComponentToRemove.flattenedDependencies, bitId.version !== _constants().LATEST_BIT_VERSION);
    const {
      ids: depIds,
      refs: depsRefs
    } = await this.getDataForDependenciesRemoval(dependentBits, componentList, consumerComponentToRemove, bitId);
    const componentsRefs = await this.getDataForRemovingComponent(bitId, componentList);
    const version = Object.keys(component.component.versions).length <= 1 ? _constants().LATEST_BIT_VERSION : bitId.version;
    return {
      compId: bitId.changeVersion(version),
      depIds,
      refsToRemove: [...componentsRefs, ...depsRefs]
    };
  }

  async getDataForDependenciesRemoval(dependentBits, componentList, consumerComponentToRemove, bitId) {
    const refsToRemove = [];
    const depsToRemoveP = consumerComponentToRemove.flattenedDependencies.map(async dependencyId => {
      const dependentsIds = dependentBits[dependencyId.toStringWithoutVersion()];
      const relevantDependents = (0, _reject2().default)(dependent => dependent.isEqual(bitId) || dependent.scope !== dependencyId.scope, dependentsIds);
      let isNested = true;

      if (this.consumer) {
        const componentMapIgnoreVersion = this.consumer.bitMap.getComponentIfExist(dependencyId, {
          ignoreVersion: true
        });
        const componentMapExact = this.consumer.bitMap.getComponentIfExist(dependencyId);
        const componentMap = componentMapExact || componentMapIgnoreVersion;

        if (componentMap) {
          isNested = componentMap.origin === _constants().COMPONENT_ORIGINS.NESTED;
        }
      }

      if ((0, _isEmpty2().default)(relevantDependents) && !this.bitIds.searchWithoutVersion(dependencyId) && ( // don't delete dependency if it is already deleted as an individual
      dependencyId.scope !== bitId.scope || this.removeSameOrigin) && isNested) {
        const refs = await this.getDataForRemovingComponent(dependencyId, componentList);
        refsToRemove.push(...refs);
        return dependencyId;
      }

      return null;
    });
    const depsToRemove = await Promise.all(depsToRemoveP);
    return {
      ids: _bitId().BitIds.fromArray((0, _lodash().compact)(depsToRemove)),
      refs: refsToRemove
    };
  }

  async getDataForRemovingComponent(id, componentList) {
    if (this.currentLane) {
      const result = this.currentLane.removeComponent(id);
      if (!result) throw new Error(`failed deleting ${id.toString()}, the component was not found on the lane`);
      return [];
    }

    const symlink = componentList.find(component => component instanceof _models().Symlink && id.isEqualWithoutScopeAndVersion(component.toBitId()));
    const refs = await this.scope.sources.getRefsForComponentRemoval(id);
    if (symlink) refs.push(symlink.hash());
    return refs;
  }

}

exports.default = RemoveModelComponents;