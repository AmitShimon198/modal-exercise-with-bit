import { Graph } from 'graphlib';
import { BitId } from '../../bit-id';
import Component from '../../consumer/component/consumer-component';
import Consumer from '../../consumer/consumer';
import { ModelComponent, Version } from '../models';
import Scope from '../scope';
export declare type DependenciesInfo = {
    id: BitId;
    depth: number;
    parent: string;
    dependencyType: string;
};
export default class DependencyGraph {
    graph: Graph;
    scopeName: string;
    constructor(graph: Graph);
    setScopeName(scopeName: string): void;
    static loadAllVersions(scope: Scope): Promise<DependencyGraph>;
    static loadLatest(scope: Scope): Promise<DependencyGraph>;
    static loadFromString(str: object): DependencyGraph;
    static buildGraphWithAllVersions(scope: Scope): Promise<Graph>;
    static buildGraphFromScope(scope: Scope): Promise<Graph>;
    static buildGraphFromWorkspace(consumer: Consumer, onlyLatest?: boolean, reverse?: boolean): Promise<Graph>;
    static buildGraphFromCurrentlyUsedComponents(consumer: Consumer): Promise<Graph>;
    static _addDependenciesToGraph(id: BitId, graph: Graph, component: Version | Component, reverse?: boolean): void;
    static buildFromNodesAndEdges(nodes: Array<{
        idStr: string;
        bitId: BitId;
    }>, edges: Array<{
        src: string;
        target: string;
        depType: string;
    }>): Graph;
    getSubGraphOfConnectedComponents(id: BitId): Graph;
    getDependenciesInfo(id: BitId): DependenciesInfo[];
    getDependentsInfo(id: BitId): DependenciesInfo[];
    _getIdWithLatestVersion(id: BitId): BitId;
    getComponent(id: BitId): ModelComponent;
    getImmediateDependentsPerId(id: BitId, returnNodeValue?: boolean): Array<string | Component | BitId>;
    getImmediateDependenciesPerId(id: BitId): string[];
    serialize(graph?: Graph): Object;
}
