/// <reference types="node" />
import { Mutex } from 'async-mutex';
import { PathOsBasedAbsolute } from '../../utils/path';
import RemoteLanes from '../lanes/remote-lanes';
import UnmergedComponents from '../lanes/unmerged-components';
import { ScopeJson } from '../scope-json';
import ScopeIndex, { IndexType } from './components-index';
import BitObject from './object';
import { ObjectItem, ObjectList } from './object-list';
import BitRawObject from './raw-object';
import Ref from './ref';
import { ContentTransformer } from './repository-hooks';
export default class Repository {
    objects: {
        [key: string]: BitObject;
    };
    objectsToRemove: Ref[];
    scopeJson: ScopeJson;
    onRead: ContentTransformer;
    onPersist: ContentTransformer;
    scopePath: string;
    scopeIndex: ScopeIndex;
    private cache;
    remoteLanes: RemoteLanes;
    unmergedComponents: UnmergedComponents;
    persistMutex: Mutex;
    constructor(scopePath: string, scopeJson: ScopeJson);
    static load({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Promise<Repository>;
    static create({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Repository;
    static reset(scopePath: string): Promise<void>;
    static getPathByScopePath(scopePath: string): string;
    static onPostObjectsPersist: () => Promise<void>;
    ensureDir(): Promise<void>;
    getPath(): string;
    getBackupPath(dirName?: string): string;
    getLicense(): Promise<string>;
    getScopeMetaObject(): Promise<ObjectItem>;
    objectPath(ref: Ref): string;
    has(ref: Ref): Promise<boolean>;
    load(ref: Ref, throws?: boolean): Promise<BitObject>;
    list(): Promise<BitObject[]>;
    listRefs(cwd?: string): Promise<Array<Ref>>;
    listRawObjects(): Promise<any>;
    listObjectsFromIndex(indexType: IndexType, filter?: Function): Promise<BitObject[]>;
    getHashFromIndex(indexType: IndexType, filter: Function): string | null;
    _getBitObjectsByHashes(hashes: string[]): Promise<BitObject[]>;
    loadOptionallyCreateScopeIndex(): Promise<ScopeIndex>;
    loadRaw(ref: Ref): Promise<Buffer>;
    loadManyRaw(refs: Ref[]): Promise<ObjectItem[]>;
    loadManyRawIgnoreMissing(refs: Ref[]): Promise<ObjectItem[]>;
    loadRawObject(ref: Ref): Promise<BitRawObject>;
    loadSync(ref: Ref, throws?: boolean): BitObject;
    setCache(object: BitObject): this;
    getCache(ref: Ref): BitObject | undefined;
    removeFromCache(ref: Ref): void;
    clearCache(): void;
    backup(dirName?: string): void;
    add(object: BitObject | null | undefined): Repository;
    addMany(objects: BitObject[]): Repository;
    removeObject(ref: Ref): void;
    removeManyObjects(refs: Ref[]): void;
    findMany(refs: Ref[]): Promise<BitObject[]>;
    persist(validate?: boolean): Promise<void>;
    writeRemoteLanes(): Promise<void>;
    private clearObjects;
    validateObjects(validate: boolean, objects: BitObject[]): void;
    deleteObjectsFromFS(refs: Ref[]): Promise<void>;
    deleteRecordsFromUnmergedComponents(componentNames: string[]): Promise<void>;
    writeObjectsToTheFS(objects: BitObject[]): Promise<void>;
    _deleteOne(ref: Ref): Promise<boolean>;
    _writeOne(object: BitObject): Promise<boolean>;
    writeObjectsToPendingDir(objectList: ObjectList, pendingDir: PathOsBasedAbsolute): Promise<void>;
    readObjectsFromPendingDir(pendingDir: PathOsBasedAbsolute): Promise<ObjectList>;
    private hashPath;
}
