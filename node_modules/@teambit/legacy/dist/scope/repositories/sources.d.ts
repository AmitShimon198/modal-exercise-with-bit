import { BitId, BitIds } from '../../bit-id';
import ConsumerComponent from '../../consumer/component';
import Consumer from '../../consumer/consumer';
import ComponentObjects from '../component-objects';
import ComponentNeedsUpdate from '../exceptions/component-needs-update';
import { ModelComponent, Symlink, Version } from '../models';
import Lane from '../models/lane';
import { ComponentProps } from '../models/model-component';
import { BitObject, Ref } from '../objects';
import Repository from '../objects/repository';
import Scope from '../scope';
export declare type ComponentTree = {
    component: ModelComponent;
    objects: BitObject[];
};
export declare type LaneTree = {
    lane: Lane;
    objects: BitObject[];
};
export declare type ComponentDef = {
    id: BitId;
    component: ModelComponent | null | undefined;
};
export declare type MergeResult = {
    mergedComponent: ModelComponent;
    mergedVersions: string[];
};
export default class SourceRepository {
    scope: Scope;
    private cacheUnBuiltIds;
    constructor(scope: Scope);
    objects(): Repository;
    getMany(ids: BitId[] | BitIds, versionShouldBeBuilt?: boolean): Promise<ComponentDef[]>;
    get(bitId: BitId, versionShouldBeBuilt?: boolean): Promise<ModelComponent | undefined>;
    _findComponent(component: ModelComponent): Promise<ModelComponent | undefined>;
    _findComponentBySymlink(symlink: Symlink): Promise<ModelComponent | undefined>;
    getObjects(id: BitId): Promise<ComponentObjects>;
    findOrAddComponent(props: ComponentProps): Promise<ModelComponent>;
    modifyCIProps({ source, ciProps }: {
        source: ConsumerComponent;
        ciProps: Record<string, any>;
    }): Promise<any>;
    modifySpecsResults({ source, specsResults }: {
        source: ConsumerComponent;
        specsResults?: any;
    }): Promise<any>;
    updateDist({ source }: {
        source: ConsumerComponent;
    }): Promise<any>;
    private transformArtifactsFromVinylToSource;
    consumerComponentToVersion({ consumerComponent, consumer, }: {
        readonly consumerComponent: ConsumerComponent;
        consumer: Consumer;
    }): Promise<{
        version: Version;
        files: any;
        dists: any;
        compilerFiles: any;
        testerFiles: any;
    }>;
    consumerComponentToVersionHarmony(consumerComponent: ConsumerComponent): Promise<{
        version: Version;
        files: any;
    }>;
    enrichSource(consumerComponent: ConsumerComponent): Promise<ConsumerComponent>;
    getObjectsToEnrichSource(consumerComponent: ConsumerComponent): Promise<BitObject[]>;
    addSource({ source, consumer, lane, resolveUnmerged, }: {
        source: ConsumerComponent;
        consumer: Consumer;
        lane: Lane | null;
        resolveUnmerged?: boolean;
    }): Promise<ModelComponent>;
    addSourceFromScope(source: ConsumerComponent): Promise<ModelComponent>;
    put({ component, objects }: ComponentTree): ModelComponent;
    putObjects(objects: BitObject[]): void;
    removeComponentVersions(component: ModelComponent, versions: string[], allVersionsObjects: Version[]): void;
    getRefsForComponentRemoval(bitId: BitId, includeVersions?: boolean): Promise<Ref[]>;
    merge(incomingComp: ModelComponent, versionObjects: Version[]): Promise<MergeResult>;
    private getMergedSnaps;
    private throwForMissingVersions;
    mergeComponents(components: ModelComponent[], versions: Version[]): Promise<{
        mergeResults: MergeResult[];
        errors: Error[];
    }>;
    mergeLane(lane: Lane, local: boolean): Promise<{
        mergeResults: MergeResult[];
        mergeErrors: ComponentNeedsUpdate[];
        mergeLane: Lane;
    }>;
}
