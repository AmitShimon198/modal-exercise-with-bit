{"version":3,"sources":["packer.ts"],"names":["DEFAULT_TAR_DIR_IN_CAPSULE","TAR_FILE_ARTIFACT_NAME","Packer","constructor","isolator","logger","host","scope","legacyPacker","LegacyPacker","packComponent","componentId","scopePath","options","loadScopeFromCache","undefined","legacyScope","LegacyScope","load","ScopeNotFound","isLegacyScope","isLegacy","res","pack","Object","assign","id","capsule","getCapsule","packCapsule","writeOptions","dryRun","_","omit","packMultipleCapsules","capsules","override","omitFullTarPath","description","longProcessLogger","createLongProcessLogger","length","results","logProgress","component","toString","end","concreteWriteOpts","outDir","packResult","npmPack","path","fieldsToRemove","push","metadata","omitBy","isUndefined","value","errors","warnings","startTime","endTime","getArtifactDefInCapsule","rootDir","def","name","globPatterns","componentIdStr","resolveComponentId","network","isolateComponents","baseDir","seedersCapsules","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AADA;AAUA,MAAMA,0BAA0B,GAAG,aAAnC;AACO,MAAMC,sBAAsB,GAAG,kBAA/B;;;AAEA,MAAMC,MAAN,CAAa;AAElBC,EAAAA,WAAW,CACDC,QADC,EAEDC,MAFC,EAGDC,IAHC,EAIDC,KAJC,EAKT;AAAA,SAJQH,QAIR,GAJQA,QAIR;AAAA,SAHQC,MAGR,GAHQA,MAGR;AAAA,SAFQC,IAER,GAFQA,IAER;AAAA,SADQC,KACR,GADQA,KACR;AAAA;AACA,SAAKC,YAAL,GAAoB,KAAIC,cAAJ,EAAiB,KAAKJ,MAAtB,CAApB;AACD;;AAEkB,QAAbK,aAAa,CACjBC,WADiB,EAEjBC,SAFiB,EAGjBC,OAHiB,EAIU;AAAA;;AAC3B;AACA,UAAMC,kBAAkB,GACtBD,OAAO,IAAIA,OAAO,CAACC,kBAAR,KAA+BC,SAA1C,GAAsD,CAAC,CAACF,OAAO,CAACC,kBAAhE,GAAqF,KADvF;AAEA,UAAME,WAAW,GAAGJ,SAAS,GAAG,MAAMK,iBAAYC,IAAZ,CAAiBN,SAAjB,EAA4BE,kBAA5B,CAAT,kBAA2D,KAAKP,KAAhE,gDAA2D,YAAYS,WAApG;;AACA,QAAI,CAACA,WAAL,EAAkB;AAChB,YAAM,KAAIG,8BAAJ,EAAkBP,SAAlB,CAAN;AACD,KAP0B,CAQ3B;;;AACA,UAAMQ,aAAa,GAAIR,SAAS,IAAII,WAAW,CAACK,QAA1B,IAAuC,KAAKf,IAAL,CAAUe,QAAvE,CAT2B,CAW3B;;AACA,QAAID,aAAJ,EAAmB;AACjB,YAAME,GAAG,GAAG,MAAM,KAAKd,YAAL,CAAkBe,IAAlB,CAAuBZ,WAAvB,EAAoCK,WAApC,EAAiDH,OAAjD,CAAlB,CADiB,CAEjB;;AACA,aAAOW,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,GAAlB,EAAuB;AAAEI,QAAAA,EAAE,EAAEf;AAAN,OAAvB,CAAP;AACD;;AAED,UAAMgB,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgBjB,WAAhB,EAA6BK,WAA7B,CAAtB;AACA,UAAMM,GAAG,GAAG,MAAM,KAAKO,WAAL,CAAiBF,OAAjB,EAA0Bd,OAAO,CAACiB,YAAlC,EAAgDjB,OAAO,CAACkB,MAAxD,CAAlB;AAEA,WAAOP,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBO,kBAAEC,IAAF,CAAOX,GAAP,EAAY,CAAC,WAAD,CAAZ,CAAlB,EAA8C;AAAEI,MAAAA,EAAE,EAAEf;AAAN,KAA9C,CAAP;AACD;;AAEyB,QAApBuB,oBAAoB,CACxBC,QADwB,EAExBL,YAA8B,GAAG;AAAEM,IAAAA,QAAQ,EAAE;AAAZ,GAFT,EAGxBL,MAAM,GAAG,KAHe,EAIxBM,eAAe,GAAG,KAJM,EAKI;AAC5B,UAAMC,WAAW,GAAI,qBAAoBP,MAAM,GAAG,YAAH,GAAkB,EAAG,EAApE;AACA,UAAMQ,iBAAiB,GAAG,KAAKlC,MAAL,CAAYmC,uBAAZ,CAAoCF,WAApC,EAAiDH,QAAQ,CAACM,MAA1D,CAA1B;AACA,UAAMC,OAAO,GAAG,2BAAUP,QAAV,EAAqBR,OAAD,IAAa;AAC/CY,MAAAA,iBAAiB,CAACI,WAAlB,CAA8BhB,OAAO,CAACiB,SAAR,CAAkBlB,EAAlB,CAAqBmB,QAArB,EAA9B;AACA,aAAO,KAAKhB,WAAL,CAAiBF,OAAjB,EAA0BG,YAA1B,EAAwCC,MAAxC,EAAgDM,eAAhD,CAAP;AACD,KAHe,CAAhB;AAIAE,IAAAA,iBAAiB,CAACO,GAAlB;AACA,WAAOJ,OAAP;AACD;;AAEgB,QAAXb,WAAW,CACfF,OADe,EAEfG,YAA8B,GAAG;AAAEM,IAAAA,QAAQ,EAAE;AAAZ,GAFlB,EAGfL,MAAM,GAAG,KAHM,EAIfM,eAAe,GAAG,KAJH,EAKW;AAAA;;AAC1B,UAAMU,iBAAiB,GAAGjB,YAA1B,CAD0B,CAE1B;;AACAiB,IAAAA,iBAAiB,CAACC,MAAlB,4BAA2BD,iBAAiB,CAACC,MAA7C,yEAAuDhD,0BAAvD;AACA,UAAMiD,UAAU,GAAG,MAAM,KAAKzC,YAAL,CAAkB0C,OAAlB,CACvBvB,OAAO,CAACwB,IADe,EAEvBJ,iBAAiB,CAACC,MAAlB,IAA4BrB,OAAO,CAACwB,IAFb,EAGvBJ,iBAAiB,CAACX,QAHK,EAIvBL,MAJuB,CAAzB;AAMA,UAAMa,SAAS,GAAGjB,OAAO,CAACiB,SAA1B;AACA,UAAMQ,cAAwB,GAAG,EAAjC;;AACA,QAAIf,eAAJ,EAAqB;AACnBe,MAAAA,cAAc,CAACC,IAAf,CAAoB,SAApB;AACD,KAdyB,CAe1B;;;AACA,UAAMC,QAAQ,GAAG,uBAAEL,UAAU,CAACK,QAAb,EAAuBC,MAAvB,CAA8BvB,kBAAEwB,WAAhC,EAA6CvB,IAA7C,CAAkDmB,cAAlD,EAAkEK,KAAlE,EAAjB;AAEA,WAAO;AACLb,MAAAA,SADK;AAELU,MAAAA,QAFK;AAGLI,MAAAA,MAAM,EAAET,UAAU,CAACS,MAHd;AAILC,MAAAA,QAAQ,EAAEV,UAAU,CAACU,QAJhB;AAKLC,MAAAA,SAAS,EAAEX,UAAU,CAACW,SALjB;AAMLC,MAAAA,OAAO,EAAEZ,UAAU,CAACY;AANf,KAAP;AAQD;;AAEDC,EAAAA,uBAAuB,CAACd,MAAD,EAAsC;AAC3D,UAAMe,OAAO,GAAGf,MAAM,IAAIhD,0BAA1B;AACA,UAAMgE,GAAuB,GAAG;AAC9BC,MAAAA,IAAI,EAAEhE,sBADwB;AAE9BiE,MAAAA,YAAY,EAAE,CAAE,GAAEH,OAAQ,QAAZ;AAFgB,KAAhC;AAIA,WAAOC,GAAP;AACD;;AAEuB,QAAVpC,UAAU,CAACuC,cAAD,EAAyBnD,WAAzB,EAAqE;AAC3F,UAAML,WAAW,GAAG,MAAM,KAAKL,IAAL,CAAU8D,kBAAV,CAA6BD,cAA7B,CAA1B;AACA,UAAME,OAAO,GAAG,MAAM,KAAKjE,QAAL,CAAckE,iBAAd,CAAgC,CAAC3D,WAAD,CAAhC,EAA+C;AAAE4D,MAAAA,OAAO,EAAE,KAAKjE,IAAL,CAAU6C;AAArB,KAA/C,EAA4EnC,WAA5E,CAAtB;AACA,UAAMW,OAAO,GAAG0C,OAAO,CAACG,eAAR,CAAwB5C,UAAxB,CAAmCjB,WAAnC,CAAhB;AAEA,QAAI,CAACgB,OAAL,EAAc,MAAM,IAAI8C,KAAJ,CAAW,yBAAwB9D,WAAY,EAA/C,CAAN;AACd,WAAOgB,OAAP;AACD;;AAxGiB","sourcesContent":["import _ from 'lodash';\nimport { ComponentFactory } from '@teambit/component';\nimport { ComponentResult, ArtifactDefinition } from '@teambit/builder';\nimport { Capsule, IsolatorMain } from '@teambit/isolator';\nimport { ScopeMain } from '@teambit/scope';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport { Packer as LegacyPacker, PackWriteOptions, PackOptions } from '@teambit/legacy/dist/pack';\nimport { Logger } from '@teambit/logger';\nimport mapSeries from 'p-map-series';\n\n// @ts-ignore (for some reason the tsc -w not found this)\nimport { ScopeNotFound } from './exceptions/scope-not-found';\n\nexport { PackOptions };\n\nexport type PackResult = Omit<ComponentResult, 'component'>;\nexport type PackResultWithId = PackResult & {\n  id: string;\n};\n\nconst DEFAULT_TAR_DIR_IN_CAPSULE = 'package-tar';\nexport const TAR_FILE_ARTIFACT_NAME = 'package tar file';\n\nexport class Packer {\n  legacyPacker: LegacyPacker;\n  constructor(\n    private isolator: IsolatorMain,\n    private logger: Logger,\n    private host: ComponentFactory,\n    private scope?: ScopeMain\n  ) {\n    this.legacyPacker = new LegacyPacker(this.logger);\n  }\n\n  async packComponent(\n    componentId: string,\n    scopePath: string | undefined,\n    options: PackOptions\n  ): Promise<PackResultWithId> {\n    // By default do not load scope from cache when packing\n    const loadScopeFromCache =\n      options && options.loadScopeFromCache !== undefined ? !!options.loadScopeFromCache : false;\n    const legacyScope = scopePath ? await LegacyScope.load(scopePath, loadScopeFromCache) : this.scope?.legacyScope;\n    if (!legacyScope) {\n      throw new ScopeNotFound(scopePath);\n    }\n    // Or the scope we are operate on is legacy, or the host (workspace) is legacy\n    const isLegacyScope = (scopePath && legacyScope.isLegacy) || this.host.isLegacy;\n\n    // Handle legacy\n    if (isLegacyScope) {\n      const res = await this.legacyPacker.pack(componentId, legacyScope, options);\n      // @ts-ignore\n      return Object.assign({}, res, { id: componentId });\n    }\n\n    const capsule = await this.getCapsule(componentId, legacyScope);\n    const res = await this.packCapsule(capsule, options.writeOptions, options.dryRun);\n\n    return Object.assign({}, _.omit(res, ['component']), { id: componentId });\n  }\n\n  async packMultipleCapsules(\n    capsules: Capsule[],\n    writeOptions: PackWriteOptions = { override: true },\n    dryRun = false,\n    omitFullTarPath = false\n  ): Promise<ComponentResult[]> {\n    const description = `packing components${dryRun ? ' (dry-run)' : ''}`;\n    const longProcessLogger = this.logger.createLongProcessLogger(description, capsules.length);\n    const results = mapSeries(capsules, (capsule) => {\n      longProcessLogger.logProgress(capsule.component.id.toString());\n      return this.packCapsule(capsule, writeOptions, dryRun, omitFullTarPath);\n    });\n    longProcessLogger.end();\n    return results;\n  }\n\n  async packCapsule(\n    capsule: Capsule,\n    writeOptions: PackWriteOptions = { override: true },\n    dryRun = false,\n    omitFullTarPath = false\n  ): Promise<ComponentResult> {\n    const concreteWriteOpts = writeOptions;\n    // Set the package-tar as out dir to easily read the tar later\n    concreteWriteOpts.outDir = concreteWriteOpts.outDir ?? DEFAULT_TAR_DIR_IN_CAPSULE;\n    const packResult = await this.legacyPacker.npmPack(\n      capsule.path,\n      concreteWriteOpts.outDir || capsule.path,\n      concreteWriteOpts.override,\n      dryRun\n    );\n    const component = capsule.component;\n    const fieldsToRemove: string[] = [];\n    if (omitFullTarPath) {\n      fieldsToRemove.push('tarPath');\n    }\n    // TODO: @gilad please make sure to fix this type error now that I added lodash types\n    const metadata = _(packResult.metadata).omitBy(_.isUndefined).omit(fieldsToRemove).value() as any;\n\n    return {\n      component,\n      metadata,\n      errors: packResult.errors,\n      warnings: packResult.warnings,\n      startTime: packResult.startTime,\n      endTime: packResult.endTime,\n    };\n  }\n\n  getArtifactDefInCapsule(outDir?: string): ArtifactDefinition {\n    const rootDir = outDir || DEFAULT_TAR_DIR_IN_CAPSULE;\n    const def: ArtifactDefinition = {\n      name: TAR_FILE_ARTIFACT_NAME,\n      globPatterns: [`${rootDir}/*.tgz`],\n    };\n    return def;\n  }\n\n  private async getCapsule(componentIdStr: string, legacyScope: LegacyScope): Promise<Capsule> {\n    const componentId = await this.host.resolveComponentId(componentIdStr);\n    const network = await this.isolator.isolateComponents([componentId], { baseDir: this.host.path }, legacyScope);\n    const capsule = network.seedersCapsules.getCapsule(componentId);\n\n    if (!capsule) throw new Error(`capsule not found for ${componentId}`);\n    return capsule;\n  }\n}\n"]}