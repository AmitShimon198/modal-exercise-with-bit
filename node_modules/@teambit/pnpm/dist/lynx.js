"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.install = install;
exports.resolveRemoteVersion = resolveRemoteVersion;

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _parsePackageName() {
  const data = _interopRequireDefault(require("parse-package-name"));

  _parsePackageName = function () {
    return data;
  };

  return data;
}

function _defaultReporter() {
  const data = _interopRequireDefault(require("@pnpm/default-reporter"));

  _defaultReporter = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@pnpm/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _storeConnectionManager() {
  const data = require("@pnpm/store-connection-manager");

  _storeConnectionManager = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _supi() {
  const data = require("supi");

  _supi = function () {
    return data;
  };

  return data;
}

function _client() {
  const data = _interopRequireDefault(require("@pnpm/client"));

  _client = function () {
    return data;
  };

  return data;
}

function _pickRegistryForPackage() {
  const data = _interopRequireDefault(require("@pnpm/pick-registry-for-package"));

  _pickRegistryForPackage = function () {
    return data;
  };

  return data;
}

function _nerfDart() {
  const data = _interopRequireDefault(require("nerf-dart"));

  _nerfDart = function () {
    return data;
  };

  return data;
}

function _readConfig() {
  const data = require("./read-config");

  _readConfig = function () {
    return data;
  };

  return data;
}

// import createClient from '@pnpm/client'
// import { createFetchFromRegistry } from '@pnpm/fetch';
// import execa from 'execa';
// import createFetcher from '@pnpm/tarball-fetcher';
// import { ReporterFunction } from 'supi/lib/types';
// import { createResolver } from './create-resolver';
// import {isValidPath} from '@teambit/legacy/dist/utils';
// import {createResolver} from '@pnpm/default-resolver';
// TODO: DO NOT DELETE - uncomment when this is solved https://github.com/pnpm/pnpm/issues/2910
// function getReporter(logger: Logger): ReporterFunction {
//   return ((logObj) => {
//     // TODO: print correctly not the entire object
//     logger.console(logObj)
//   });
// }
async function createStoreController(storeDir, registries, proxyConfig = {}) {
  // const fetchFromRegistry = createFetchFromRegistry({});
  // const getCredentials = () => ({ authHeaderValue: '', alwaysAuth: false });
  // const resolver: ResolveFunction = createResolver(fetchFromRegistry, getCredentials, {
  //   metaCache: new Map(),
  //   storeDir,
  // });
  // const fetcher = createFetcher(fetchFromRegistry, getCredentials, {});
  // const { resolve, fetchers } = createClient({
  //   // authConfig,
  //   metaCache: new Map(),
  //   // retry: retryOpts,
  //   storeDir,
  //   // ...resolveOpts,
  //   // ...fetchOpts,
  // })
  // const storeController = await createStore(resolve, fetchers, {
  //   storeDir,
  //   verifyStoreIntegrity: true,
  // });
  // const pnpmConfig = await readConfig();
  const authConfig = getAuthConfig(registries);
  const opts = {
    storeDir,
    rawConfig: authConfig,
    verifyStoreIntegrity: true,
    httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
    httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
    ca: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.ca,
    cert: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.cert,
    key: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.key,
    noProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.noProxy,
    strictSsl: proxyConfig.strictSSL
  };
  const {
    ctrl
  } = await (0, _storeConnectionManager().createNewStoreController)(opts);
  return ctrl;
}

async function generateResolverAndFetcher(storeDir, registries, proxyConfig = {}) {
  const pnpmConfig = await (0, _readConfig().readConfig)();
  const authConfig = getAuthConfig(registries);
  const opts = {
    authConfig: Object.assign({}, pnpmConfig.config.rawConfig, authConfig),
    storeDir,
    httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
    httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
    ca: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.ca,
    cert: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.cert,
    key: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.key,
    noProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.noProxy,
    strictSSL: proxyConfig.strictSSL
  };
  const result = (0, _client().default)(opts);
  return result;
}

async function install(rootPathToManifest, pathsToManifests, storeDir, registries, proxyConfig = {}, // eslint-disable-next-line @typescript-eslint/no-unused-vars
logger) {
  const packagesToBuild = []; // supi will use this to install the packages

  const workspacePackages = {}; // supi will use this to link packages to each other
  // This will create local link by pnpm to a component exists in the ws.
  // it will later deleted by the link process
  // we keep it here to better support case like this:
  // compA@1.0.0 uses compB@1.0.0
  // I have compB@2.0.0 in my workspace
  // now I install compA@1.0.0
  // compA is hoisted to the root and install B@1.0.0 hoisted to the root as well
  // now we will make link to B@2.0.0 and A will break
  // with this we will have a link to the local B by pnpm so it will install B@1.0.0 inside A
  // then when overriding the link, A will still works
  // This is the rational behind not deleting this completely, but need further check that it really works
  // eslint-disable-next-line

  for (const rootDir in pathsToManifests) {
    const manifest = pathsToManifests[rootDir];
    packagesToBuild.push({
      buildIndex: 0,
      // workspace components should be installed before the root
      manifest,
      rootDir,
      mutation: 'install'
    });
    workspacePackages[manifest.name] = workspacePackages[manifest.name] || {};
    workspacePackages[manifest.name][manifest.version] = {
      dir: rootDir,
      manifest
    };
  }

  packagesToBuild.push({
    buildIndex: 1,
    // install the root package after the workspace components were installed
    manifest: rootPathToManifest.manifest,
    mutation: 'install',
    rootDir: rootPathToManifest.rootDir
  });
  const registriesMap = getRegistriesMap(registries);
  const authConfig = getAuthConfig(registries);
  const storeController = await createStoreController(storeDir, registries, proxyConfig);
  const opts = {
    storeDir,
    dir: rootPathToManifest.rootDir,
    storeController,
    update: true,
    workspacePackages,
    registries: registriesMap,
    rawConfig: authConfig // TODO: uncomment when this is solved https://github.com/pnpm/pnpm/issues/2910
    // reporter: logger ? getReporter(logger) : undefined,

  };
  (0, _defaultReporter().default)({
    context: {
      argv: []
    },
    reportingOptions: {
      appendOnly: false,
      // logLevel: 'error' as LogLevel,
      // streamLifecycleOutput: opts.config.stream,
      throttleProgress: 200
    },
    streamParser: _logger().streamParser
  });
  await (0, _supi().mutateModules)(packagesToBuild, opts);
}

async function resolveRemoteVersion(packageName, rootDir, storeDir, registries, proxyConfig = {}) {
  const {
    resolve
  } = await generateResolverAndFetcher(storeDir, registries, proxyConfig);
  const resolveOpts = {
    projectDir: rootDir,
    registry: ''
  };

  try {
    const parsedPackage = (0, _parsePackageName().default)(packageName);
    const registriesMap = getRegistriesMap(registries);
    const registry = (0, _pickRegistryForPackage().default)(registriesMap, parsedPackage.name);
    const wantedDep = {
      alias: parsedPackage.name,
      pref: parsedPackage.version
    };
    const isValidRange = parsedPackage.version ? !!_semver().default.validRange(parsedPackage.version) : false;
    resolveOpts.registry = registry;
    const val = await resolve(wantedDep, resolveOpts);
    const version = isValidRange ? parsedPackage.version : val.manifest.version; // const { stdout } = await execa('npm', ['view', packageName, 'version'], {});

    return {
      packageName: val.manifest.name,
      version,
      isSemver: true,
      resolvedVia: val.resolvedVia
    };
  } catch (e) {
    var _e$message;

    if (!((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.includes('is not a valid string'))) {
      throw e;
    } // The provided package is probably a git url or path to a folder


    const wantedDep = {
      alias: undefined,
      pref: packageName
    };
    const val = await resolve(wantedDep, resolveOpts);
    return {
      packageName: val.manifest.name,
      version: val.normalizedPref,
      isSemver: false,
      resolvedVia: val.resolvedVia
    };
  }
}

function getRegistriesMap(registries) {
  const registriesMap = {
    default: registries.defaultRegistry.uri || _dependencyResolver().NPM_REGISTRY
  };
  Object.entries(registries.scopes).forEach(([registryName, registry]) => {
    registriesMap[`@${registryName}`] = registry.uri;
  });
  return registriesMap;
}

function getAuthConfig(registries) {
  const res = {};
  res.registry = registries.defaultRegistry.uri;

  if (registries.defaultRegistry.alwaysAuth) {
    res['always-auth'] = true;
  }

  const defaultAuthTokens = getAuthTokenForRegistry(registries.defaultRegistry, true);
  defaultAuthTokens.forEach(({
    keyName,
    val
  }) => {
    res[keyName] = val;
  });
  Object.entries(registries.scopes).forEach(([, registry]) => {
    const authTokens = getAuthTokenForRegistry(registry);
    authTokens.forEach(({
      keyName,
      val
    }) => {
      res[keyName] = val;
    });

    if (registry.alwaysAuth) {
      const nerfed = (0, _nerfDart().default)(registry.uri);
      const alwaysAuthKeyName = `${nerfed}:always-auth`;
      res[alwaysAuthKeyName] = true;
    }
  });
  return res;
}

function getAuthTokenForRegistry(registry, isDefault = false) {
  const nerfed = (0, _nerfDart().default)(registry.uri);

  if (registry.originalAuthType === 'authToken') {
    return [{
      keyName: `${nerfed}:_authToken`,
      val: registry.originalAuthValue || ''
    }];
  }

  if (registry.originalAuthType === 'auth') {
    return [{
      keyName: isDefault ? '_auth' : `${nerfed}:_auth`,
      val: registry.originalAuthValue || ''
    }];
  }

  if (registry.originalAuthType === 'user-pass') {
    var _registry$originalAut, _registry$originalAut2;

    return [{
      keyName: `${nerfed}:username`,
      val: ((_registry$originalAut = registry.originalAuthValue) === null || _registry$originalAut === void 0 ? void 0 : _registry$originalAut.split(':')[0]) || ''
    }, {
      keyName: `${nerfed}:_password`,
      val: ((_registry$originalAut2 = registry.originalAuthValue) === null || _registry$originalAut2 === void 0 ? void 0 : _registry$originalAut2.split(':')[1]) || ''
    }];
  }

  return [];
}

//# sourceMappingURL=lynx.js.map