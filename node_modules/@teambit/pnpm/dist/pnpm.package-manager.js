"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PnpmPackageManager = void 0;

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _userHome() {
  const data = _interopRequireDefault(require("user-home"));

  _userHome = function () {
    return data;
  };

  return data;
}

const defaultStoreDir = (0, _path().join)(_userHome().default, '.pnpm-store');

class PnpmPackageManager {
  constructor(depResolver, pkg, logger) {
    this.depResolver = depResolver;
    this.pkg = pkg;
    this.logger = logger;
  }

  async install(rootDir, rootPolicy, componentDirectoryMap, installOptions = {}) {
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      install
    } = require('./lynx');

    const storeDir = installOptions !== null && installOptions !== void 0 && installOptions.cacheRootDir ? (0, _path().join)(installOptions === null || installOptions === void 0 ? void 0 : installOptions.cacheRootDir, '.pnpm-store') : defaultStoreDir;
    const components = componentDirectoryMap.toArray().map(([component]) => component);
    const options = {
      filterComponentsFromManifests: true,
      createManifestForComponentsWithoutDependencies: true,
      dedupe: installOptions.dedupe,
      dependencyFilterFn: installOptions.dependencyFilterFn
    };
    const workspaceManifest = await this.depResolver.getWorkspaceManifest(undefined, undefined, rootPolicy, rootDir, components, options);
    const rootManifest = workspaceManifest.toJson({
      includeDir: true,
      copyPeerToRuntime: installOptions.copyPeerToRuntimeOnRoot
    });
    const componentsManifests = this.computeComponentsManifests(componentDirectoryMap, workspaceManifest.componentsManifestsMap, // In case of not deduping we want to install peers inside the components
    // !options.dedupe
    installOptions.copyPeerToRuntimeOnComponents);
    this.logger.debug('root manifest for installation', rootManifest);
    this.logger.debug('components manifests for installation', componentsManifests);
    this.logger.setStatusLine('installing dependencies using pnpm'); // turn off the logger because it interrupts the pnpm output

    this.logger.off();
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    await install(rootManifest, componentsManifests, storeDir, registries, proxyConfig, this.logger);
    this.logger.on(); // Make a divider row to improve output

    this.logger.console('-------------------------');
    this.logger.consoleSuccess('installing dependencies using pnpm');
  }

  computeComponentsManifests(componentDirectoryMap, componentsManifestsFromWorkspace, copyPeerToRuntime = false) {
    return componentDirectoryMap.toArray().reduce((acc, [component, dir]) => {
      const packageName = this.pkg.getPackageName(component);

      if (componentsManifestsFromWorkspace.has(packageName)) {
        var _componentsManifestsF;

        acc[dir] = (_componentsManifestsF = componentsManifestsFromWorkspace.get(packageName)) === null || _componentsManifestsF === void 0 ? void 0 : _componentsManifestsF.toJson({
          copyPeerToRuntime
        });
      }

      return acc;
    }, {});
  }

  async resolveRemoteVersion(packageName, options) {
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      resolveRemoteVersion
    } = require('./lynx');

    const storeDir = options !== null && options !== void 0 && options.cacheRootDir ? (0, _path().join)(options === null || options === void 0 ? void 0 : options.cacheRootDir, '.pnpm-store') : defaultStoreDir;
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    return resolveRemoteVersion(packageName, options.rootDir, storeDir, registries, proxyConfig);
  }

  async getProxyConfig() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getProxyConfig
    } = require('./get-proxy-config');

    return getProxyConfig();
  }

  async getRegistries() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getRegistries
    } = require('./get-registries');

    const pnpmRegistry = await getRegistries();
    const defaultRegistry = new (_dependencyResolver().Registry)(pnpmRegistry.default.uri, pnpmRegistry.default.alwaysAuth, pnpmRegistry.default.authHeaderValue, pnpmRegistry.default.originalAuthType, pnpmRegistry.default.originalAuthValue);
    const pnpmScoped = (0, _lodash().omit)(pnpmRegistry, ['default']);
    const scopesRegistries = Object.keys(pnpmScoped).reduce((acc, scopedRegName) => {
      const scopedReg = pnpmScoped[scopedRegName];
      const name = scopedRegName.replace('@', '');
      acc[name] = new (_dependencyResolver().Registry)(scopedReg.uri, scopedReg.alwaysAuth, scopedReg.authHeaderValue, scopedReg.originalAuthType, scopedReg.originalAuthValue);
      return acc;
    }, {}); // Add bit registry server if not exist

    if (!scopesRegistries.bit) {
      scopesRegistries.bit = new (_dependencyResolver().Registry)(_dependencyResolver().BIT_DEV_REGISTRY, true);
    }

    return new (_dependencyResolver().Registries)(defaultRegistry, scopesRegistries);
  }

}

exports.PnpmPackageManager = PnpmPackageManager;

//# sourceMappingURL=pnpm.package-manager.js.map