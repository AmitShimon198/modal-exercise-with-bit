"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreviewTask = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

class PreviewTask {
  constructor(
  /**
   * bundler extension.
   */
  bundler,
  /**
   * preview extension.
   */
  preview) {
    this.bundler = bundler;
    this.preview = preview;
    (0, _defineProperty2().default)(this, "aspectId", 'teambit.preview/preview');
    (0, _defineProperty2().default)(this, "name", 'GeneratePreview');
    (0, _defineProperty2().default)(this, "location", 'end');
  }

  async execute(context) {
    const defs = this.preview.getDefs();
    const url = `/preview/${context.envRuntime.id}`;
    const bundlingStrategy = this.preview.getBundlingStrategy();
    const targets = await bundlingStrategy.computeTargets(context, defs, this);
    const bundlerContext = Object.assign(context, {
      targets,
      entry: [],
      publicPath: this.getPreviewDirectory(context),
      rootPath: url
    });
    const bundler = await context.env.getBundler(bundlerContext, []);
    const bundlerResults = await bundler.run();
    return bundlingStrategy.computeResults(bundlerContext, bundlerResults, this);
  }

  async computePaths(capsule, defs, context) {
    const previewMain = await this.preview.writePreviewRuntime(context);
    const moduleMapsPromise = defs.map(async previewDef => {
      const moduleMap = await previewDef.getModuleMap([capsule.component]);
      const paths = this.getPathsFromMap(capsule, moduleMap, context);
      const template = previewDef.renderTemplatePath ? await previewDef.renderTemplatePath(context) : 'undefined';
      const link = this.preview.writeLink(previewDef.prefix, paths, previewDef.renderTemplatePath ? await previewDef.renderTemplatePath(context) : undefined, capsule.path);
      const files = (0, _lodash().flatten)(paths.toArray().map(([, file]) => file)).concat([link]);
      if (template) return files.concat([template]);
      return files;
    });
    const moduleMaps = await Promise.all(moduleMapsPromise);
    return (0, _lodash().flatten)(moduleMaps.concat([previewMain]));
  }

  getPreviewDirectory(context) {
    const outputPath = (0, _path().resolve)(`${context.id}/public`);
    return outputPath;
  }

  getPathsFromMap(capsule, moduleMap, context) {
    const compiler = context.env.getCompiler(context);
    return moduleMap.map(files => {
      return files.map(file => (0, _path().join)(capsule.path, compiler.getDistPathBySrcPath(file.relative)));
    });
  }

}

exports.PreviewTask = PreviewTask;

//# sourceMappingURL=preview.task.js.map