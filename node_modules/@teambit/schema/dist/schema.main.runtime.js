"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _schema() {
  const data = require("./schema.aspect");

  _schema = function () {
    return data;
  };

  return data;
}

// import { Workspace, WorkspaceAspect } from '@teambit/workspace';

/**
 * extension for extracting component schemas.
 */
class SchemaMain {
  constructor(
  /**
   * parsers slot.
   */
  parserSlot, envs, config) {
    this.parserSlot = parserSlot;
    this.envs = envs;
    this.config = config;
  }
  /**
   * get the default parser.
   */


  getDefaultParser() {
    return this.parserSlot.get(this.config.defaultParser);
  }
  /**
   * parse a module into a component schema.
   */


  parseModule(path) {
    const parsers = this.parserSlot.toArray();
    let maybeParser = parsers.find(([, parser]) => {
      const match = path.match(parser.extension);
      return match;
    });

    if (!maybeParser) {
      maybeParser = [this.config.defaultParser, this.getDefaultParser()];
    }

    const [, parser] = maybeParser;
    return parser.parseModule(path);
  }
  /**
   * get a schema of a component.
   * @param component target component.
   */


  async getSchema(component) {
    const env = this.envs.getEnv(component).env;

    if (typeof env.getSchemaExtractor === 'undefined') {
      throw new Error(`No SchemaExtractor defined for ${env.name}`);
    }

    const schemaExtractor = env.getSchemaExtractor();
    await schemaExtractor.extract(component);
    return {
      exports: []
    };
  }
  /**
   * register a new parser.
   */


  registerParser(parser) {
    this.parserSlot.register(parser);
    return this;
  }

  static async provider([envs], config, [parserSlot]) {
    const schema = new SchemaMain(parserSlot, envs, config); // workspace.onComponentLoad(async (component) => {
    //   const apiSchema = await schema.getSchema(component);
    //   return {};
    // });

    return schema;
  }

}

exports.SchemaMain = SchemaMain;
(0, _defineProperty2().default)(SchemaMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(SchemaMain, "dependencies", [_envs().EnvsAspect]);
(0, _defineProperty2().default)(SchemaMain, "defaultConfig", {
  defaultParser: 'teambit.typescript/typescript'
});
(0, _defineProperty2().default)(SchemaMain, "slots", [_harmony().Slot.withType()]);

_schema().SchemaAspect.addRuntime(SchemaMain);

//# sourceMappingURL=schema.main.runtime.js.map