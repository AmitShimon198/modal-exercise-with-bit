import type { AspectLoaderMain } from '@teambit/aspect-loader';
import { TaskResultsList, BuilderData } from '@teambit/builder';
import { AspectDefinition } from '@teambit/aspect-loader';
import { CLIMain } from '@teambit/cli';
import type { ComponentMain, ComponentMap } from '@teambit/component';
import { Component, ComponentFactory, ComponentID, Snap, State } from '@teambit/component';
import type { GraphqlMain } from '@teambit/graphql';
import { Harmony, SlotRegistry, ExtensionManifest, Aspect } from '@teambit/harmony';
import { IsolatorMain } from '@teambit/isolator';
import { LoggerMain, Logger } from '@teambit/logger';
import { ExpressMain } from '@teambit/express';
import type { UiMain } from '@teambit/ui';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { BitId } from '@teambit/legacy-bit-id';
import { BitIds as ComponentsIds } from '@teambit/legacy/dist/bit-id';
import { ModelComponent, Lane } from '@teambit/legacy/dist/scope/models';
import LegacyScope, { LegacyOnTagResult, OnTagOpts } from '@teambit/legacy/dist/scope/scope';
import { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';
import { PersistOptions } from '@teambit/legacy/dist/scope/types';
import LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';
import { Remotes } from '@teambit/legacy/dist/remotes';
import { FETCH_OPTIONS } from '@teambit/legacy/dist/api/scope/lib/fetch';
import { ObjectList } from '@teambit/legacy/dist/scope/objects/object-list';
import { AuthData } from '@teambit/legacy/dist/scope/network/http/http';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import { ScopeComponentLoader } from './scope-component-loader';
declare type TagRegistry = SlotRegistry<OnTag>;
declare type ManifestOrAspect = ExtensionManifest | Aspect;
export declare type OnTagResults = {
    builderDataMap: ComponentMap<BuilderData>;
    pipeResults: TaskResultsList[];
};
export declare type OnTag = (components: Component[], options?: OnTagOpts) => Promise<OnTagResults>;
declare type RemoteEventMetadata = {
    auth?: AuthData;
    headers?: {};
};
declare type RemoteEvent<Data> = (data: Data, metadata: RemoteEventMetadata, errors?: Array<string | Error>) => Promise<void>;
declare type OnPostPutData = {
    ids: ComponentID[];
    lanes: Lane[];
};
declare type OnPostDeleteData = {
    ids: ComponentID[];
};
declare type OnPreFetchObjectData = {
    ids: string[];
    fetchOptions: FETCH_OPTIONS;
};
declare type OnPostPut = RemoteEvent<OnPostPutData>;
declare type OnPostExport = RemoteEvent<OnPostPutData>;
declare type OnPostDelete = RemoteEvent<OnPostDeleteData>;
declare type OnPostObjectsPersist = RemoteEvent<undefined>;
declare type OnPreFetchObjects = RemoteEvent<OnPreFetchObjectData>;
export declare type OnPostPutSlot = SlotRegistry<OnPostPut>;
export declare type OnPostDeleteSlot = SlotRegistry<OnPostDelete>;
export declare type OnPostExportSlot = SlotRegistry<OnPostExport>;
export declare type OnPostObjectsPersistSlot = SlotRegistry<OnPostObjectsPersist>;
export declare type OnPreFetchObjectsSlot = SlotRegistry<OnPreFetchObjects>;
export declare type ScopeConfig = {
    httpTimeOut: number;
    description?: string;
    icon?: string;
    backgroundIconColor?: string;
};
export declare class ScopeMain implements ComponentFactory {
    private harmony;
    readonly legacyScope: LegacyScope;
    readonly componentExtension: ComponentMain;
    readonly config: ScopeConfig;
    private tagRegistry;
    private postPutSlot;
    private postDeleteSlot;
    private postExportSlot;
    private postObjectsPersist;
    preFetchObjects: OnPreFetchObjectsSlot;
    private isolator;
    private aspectLoader;
    private logger;
    componentLoader: ScopeComponentLoader;
    constructor(harmony: Harmony, legacyScope: LegacyScope, componentExtension: ComponentMain, config: ScopeConfig, tagRegistry: TagRegistry, postPutSlot: OnPostPutSlot, postDeleteSlot: OnPostDeleteSlot, postExportSlot: OnPostExportSlot, postObjectsPersist: OnPostObjectsPersistSlot, preFetchObjects: OnPreFetchObjectsSlot, isolator: IsolatorMain, aspectLoader: AspectLoaderMain, logger: Logger);
    get name(): string;
    get icon(): string | undefined;
    get backgroundIconColor(): string | undefined;
    get description(): string | undefined;
    get path(): string;
    get isLegacy(): boolean;
    onTag(tagFn: OnTag): void;
    reloadAspectsWithNewVersion(components: ConsumerComponent[]): Promise<void>;
    getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;
    clearCache(): void;
    builderDataMapToLegacyOnTagResults(builderDataComponentMap: ComponentMap<BuilderData>): LegacyOnTagResult[];
    onPostPut(postPutFn: OnPostPut): this;
    onPostDelete(postDeleteFn: OnPostDelete): this;
    registerOnPostExport(postExportFn: OnPostExport): this;
    registerOnPreFetchObjects(preFetchObjectsFn: OnPreFetchObjects): this;
    registerOnPostObjectsPersist(postObjectsPersistFn: OnPostObjectsPersist): this;
    fetch(ids: ComponentsIds): void;
    persist(components: Component[], options: PersistOptions): void;
    delete({ ids, force, lanes }: {
        ids: string[];
        force: boolean;
        lanes: boolean;
    }, headers?: Record<string, any>): Promise<import("@teambit/legacy/dist/scope/removed-components").RemovedObjectSerialized>;
    toObjectList(): Promise<ObjectList>;
    private toJs;
    private parseLocalAspect;
    private findRuntime;
    private loadAspectFromPath;
    private localAspects;
    loadAspects(ids: string[], throwOnError?: boolean): Promise<void>;
    getManifestsGraphRecursively(ids: string[], visited?: string[], throwOnError?: boolean): Promise<ManifestOrAspect[]>;
    private getNonLoadedAspects;
    private resolveLocalAspects;
    getResolvedAspects(components: Component[], { skipIfExists }?: {
        skipIfExists?: boolean | undefined;
    }): Promise<RequireableComponent[]>;
    requireAspects(components: Component[], throwOnError?: boolean): Promise<Array<ExtensionManifest | Aspect>>;
    getAspectCapsulePath(): string;
    private resolveUserAspects;
    resolveAspects(runtimeName?: string, componentIds?: ComponentID[]): Promise<AspectDefinition[]>;
    getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph>;
    import(ids: ComponentID[], useCache?: boolean, throwIfNotExist?: boolean): Promise<Component[]>;
    get(id: ComponentID): Promise<Component | undefined>;
    getFromConsumerComponent(consumerComponent: ConsumerComponent): Promise<Component>;
    getRemoteComponent(id: ComponentID): Promise<Component>;
    list(filter?: {
        offset: number;
        limit: number;
    }, includeCache?: boolean): Promise<Component[]>;
    listInvalid(): Promise<never[]>;
    listIds(includeCache?: boolean): Promise<ComponentID[]>;
    hasId(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    exists(modelComponent: ModelComponent): boolean;
    getMany(ids: ComponentID[], throwIfNotExist?: boolean): Promise<Component[]>;
    loadMany(ids: ComponentID[]): Promise<Component[]>;
    getOrThrow(id: ComponentID): Promise<Component>;
    getState(id: ComponentID, hash: string): Promise<State>;
    getSnap(id: ComponentID, hash: string): Promise<Snap>;
    getLogs(id: ComponentID): Promise<ComponentLog[]>;
    resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;
    resolveMultipleComponentIds(ids: Array<string | ComponentID | BitId>): Promise<ComponentID[]>;
    byPattern(patterns: string[], scope?: string): Promise<Component[]>;
    getExactVersionBySemverRange(id: ComponentID, range: string): Promise<string | undefined>;
    resumeExport(exportId: string, remotes: string[]): Promise<string[]>;
    resolveId(id: string): Promise<ComponentID>;
    _legacyRemotes(): Promise<Remotes>;
    load(id: ComponentID): Promise<Component | undefined>;
    loadComponentsAspect(component: Component): Promise<void>;
    static slots: (((registerFn: () => string) => SlotRegistry<OnTag>) | ((registerFn: () => string) => SlotRegistry<OnPostPut>) | ((registerFn: () => string) => SlotRegistry<OnPostObjectsPersist>) | ((registerFn: () => string) => SlotRegistry<OnPreFetchObjects>))[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static defaultConfig: ScopeConfig;
    static provider([componentExt, ui, graphql, cli, isolator, aspectLoader, express, loggerMain]: [
        ComponentMain,
        UiMain,
        GraphqlMain,
        CLIMain,
        IsolatorMain,
        AspectLoaderMain,
        ExpressMain,
        LoggerMain
    ], config: ScopeConfig, [tagSlot, postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersistSlot, preFetchObjectsSlot]: [
        TagRegistry,
        OnPostPutSlot,
        OnPostDeleteSlot,
        OnPostExportSlot,
        OnPostObjectsPersistSlot,
        OnPreFetchObjectsSlot
    ], harmony: Harmony): Promise<ScopeMain | undefined>;
}
export {};
