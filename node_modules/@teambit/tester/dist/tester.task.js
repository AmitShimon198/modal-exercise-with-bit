"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TesterTask = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _compiler() {
  const data = require("@teambit/compiler");

  _compiler = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _junitGenerator() {
  const data = require("./utils/junit-generator");

  _junitGenerator = function () {
    return data;
  };

  return data;
}

const JUNIT_PATH = '__bit_junit.xml';
/**
 * tester build task. Allows to test components during component build.
 */

class TesterTask {
  constructor(aspectId, devFiles) {
    this.aspectId = aspectId;
    this.devFiles = devFiles;
    (0, _defineProperty2().default)(this, "name", 'TestComponents');
    (0, _defineProperty2().default)(this, "dependencies", [_compiler().CompilerAspect.id]);
  }

  async execute(context) {
    const tester = context.env.getTester();

    const componentsSpecFiles = _component().ComponentMap.as(context.components, component => {
      return (0, _utils().detectTestFiles)(component, this.devFiles);
    });

    const testCount = componentsSpecFiles.toArray().reduce((acc, [, specs]) => acc + specs.length, 0);
    if (testCount === 0) return {
      artifacts: [],
      componentsResults: []
    };

    const specFilesWithCapsule = _component().ComponentMap.as(context.components, component => {
      const componentSpecFiles = componentsSpecFiles.get(component);
      if (!componentSpecFiles) throw new Error('capsule not found');
      const [, specs] = componentSpecFiles;
      return specs.map(specFile => {
        const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
        if (!capsule) throw new Error('capsule not found');
        const compiler = context.env.getCompiler();
        const distPath = compiler.getDistPathBySrcPath(specFile.relative); // TODO: fix spec type file need to capsule will return files with type AbstractVinyl

        return {
          path: (0, _path().join)(capsule.path, distPath),
          relative: distPath
        };
      });
    });

    const testerContext = Object.assign(context, {
      release: true,
      specFiles: specFilesWithCapsule,
      rootPath: context.capsuleNetwork.capsulesRootDir,
      patterns: specFilesWithCapsule
    }); // TODO: remove after fix AbstractVinyl on capsule
    // @ts-ignore

    const testsResults = await tester.test(testerContext); // write junit files

    await Promise.all(testsResults.components.map(async compResult => {
      const junit = (0, _junitGenerator().testsResultsToJUnitFormat)([compResult]);
      const capsule = context.capsuleNetwork.graphCapsules.getCapsule(compResult.componentId);

      if (!capsule) {
        throw new Error(`unable to find ${compResult.componentId.toString()} in capsules`);
      }

      await _fsExtra().default.writeFile((0, _path().join)(capsule.path, JUNIT_PATH), junit);
      await this.writeNpmIgnore(capsule.path);
    }));
    return {
      artifacts: [{
        name: 'junit',
        globPatterns: [JUNIT_PATH]
      }],
      // @ts-ignore
      componentsResults: testsResults.components.map(componentTests => {
        var _componentTests$resul, _context$capsuleNetwo;

        const componentErrors = (_componentTests$resul = componentTests.results) === null || _componentTests$resul === void 0 ? void 0 : _componentTests$resul.testFiles.reduce((errors, file) => {
          var _file$error;

          if (file !== null && file !== void 0 && (_file$error = file.error) !== null && _file$error !== void 0 && _file$error.failureMessage) {
            errors.push(file.error.failureMessage);
          }

          file.tests.forEach(test => {
            if (test.error) errors.push(test.error);
            if (test.failure) errors.push(test.failure);
          });
          return errors;
        }, []);
        const component = (_context$capsuleNetwo = context.capsuleNetwork.graphCapsules.getCapsule(componentTests.componentId)) === null || _context$capsuleNetwo === void 0 ? void 0 : _context$capsuleNetwo.component;

        if (!component) {
          throw new Error(`unable to find ${componentTests.componentId.toString()} in capsules`);
        }

        return {
          component,
          metadata: {
            tests: componentTests.results
          },
          errors: componentErrors
        };
      })
    };
  }

  async writeNpmIgnore(dir) {
    const NPM_IGNORE_FILE = '.npmignore';
    const npmIgnorePath = (0, _path().join)(dir, NPM_IGNORE_FILE);
    const npmIgnoreEntriesStr = `\n${JUNIT_PATH}\n`;
    await _fsExtra().default.appendFile(npmIgnorePath, npmIgnoreEntriesStr);
  }

}

exports.TesterTask = TesterTask;

//# sourceMappingURL=tester.task.js.map