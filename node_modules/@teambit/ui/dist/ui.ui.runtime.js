"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UiUI = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = require("@teambit/graphql");

  _graphql = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _reactRouter() {
  const data = require("@teambit/react-router");

  _reactRouter = function () {
    return data;
  };

  return data;
}

function _uiFoundationUiRendering() {
  const data = require("@teambit/ui-foundation.ui.rendering.html");

  _uiFoundationUiRendering = function () {
    return data;
  };

  return data;
}

function _webpackMerge() {
  const data = require("webpack-merge");

  _webpackMerge = function () {
    return data;
  };

  return data;
}

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function () {
    return data;
  };

  return data;
}

function _reactDom() {
  const data = _interopRequireDefault(require("react-dom"));

  _reactDom = function () {
    return data;
  };

  return data;
}

function _server() {
  const data = _interopRequireDefault(require("react-dom/server"));

  _server = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = _interopRequireDefault(require("lodash.compact"));

  _lodash = function () {
    return data;
  };

  return data;
}

function _compose() {
  const data = require("./compose");

  _compose = function () {
    return data;
  };

  return data;
}

function _ui() {
  const data = require("./ui.aspect");

  _ui = function () {
    return data;
  };

  return data;
}

function _clientContext() {
  const data = require("./ui/client-context");

  _clientContext = function () {
    return data;
  };

  return data;
}

/**
 * extension
 */
class UiUI {
  constructor(
  /**
   * react-router extension.
   */
  router,
  /**
   * ui root registry.
   */
  uiRootSlot,
  /** slot for overlay ui elements */
  hudSlot,
  /** hooks into the ssr render process */
  lifecycleSlot) {
    this.router = router;
    this.uiRootSlot = uiRootSlot;
    this.hudSlot = hudSlot;
    this.lifecycleSlot = lifecycleSlot;
    (0, _defineProperty2().default)(this, "registerHudItem", element => {
      this.hudSlot.register(element);
    });
  }
  /** render and rehydrate client-side */


  async render(rootExtension) {
    const rootFactory = this.getRoot(rootExtension);
    if (!rootFactory) throw new Error(`root: ${rootExtension} was not found`);
    const uiRoot = rootFactory();
    const initialLocation = `${window.location.pathname}${window.location.search}${window.location.hash}`;
    const routes = this.router.renderRoutes(uiRoot.routes, {
      initialLocation
    });
    const hudItems = this.hudSlot.values();
    const lifecycleHooks = this.lifecycleSlot.toArray(); // TODO - extract the logic from here down as reusable ssr machine

    const deserializedState = await this.deserialize(lifecycleHooks);
    let renderContexts = await this.triggerBrowserInit(lifecycleHooks, deserializedState);
    const reactContexts = this.getReactContexts(lifecycleHooks, renderContexts);

    const app = /*#__PURE__*/_react().default.createElement(_compose().Compose, {
      components: reactContexts
    }, /*#__PURE__*/_react().default.createElement(_clientContext().ClientContext, null, hudItems, routes));

    renderContexts = await this.triggerBeforeHydrateHook(renderContexts, lifecycleHooks, app);
    const mountPoint = document.getElementById(_uiFoundationUiRendering().mountPointId); // .render() already runs `.hydrate()` behind the scenes.
    // in the future, we may want to replace it with .hydrate()

    _reactDom().default.render(app, mountPoint);

    await this.triggerHydrateHook(renderContexts, lifecycleHooks, mountPoint); // remove ssr only styles

    (0, _uiFoundationUiRendering().ssrCleanup)();
  }
  /** render dehydrated server-side */


  async renderSsr(rootExtension, {
    assets,
    browser,
    server
  } = {}) {
    const rootFactory = this.getRoot(rootExtension);
    if (!rootFactory) throw new Error(`root: ${rootExtension} was not found`);
    const uiRoot = rootFactory();
    const routes = this.router.renderRoutes(uiRoot.routes, {
      initialLocation: browser === null || browser === void 0 ? void 0 : browser.location.url
    });
    const hudItems = this.hudSlot.values(); // create array once to keep consistent indexes

    const lifecycleHooks = this.lifecycleSlot.toArray(); // TODO - extract the logic from here down as reusable ssr machine
    // (1) init

    let renderContexts = await this.triggerServerInit(lifecycleHooks, browser, server);
    const reactContexts = this.getReactContexts(lifecycleHooks, renderContexts); // (2) make (virtual) dom

    const app = /*#__PURE__*/_react().default.createElement(_uiFoundationUiRendering().MountPoint, null, /*#__PURE__*/_react().default.createElement(_compose().Compose, {
      components: reactContexts
    }, /*#__PURE__*/_react().default.createElement(_clientContext().ClientContext, null, hudItems, routes))); // (3) render


    renderContexts = await this.onBeforeRender(renderContexts, lifecycleHooks, app);

    const renderedApp = _server().default.renderToString(app); // (3) render html-template


    const realtimeAssets = await this.serialize(lifecycleHooks, renderContexts, app); // @ts-ignore // TODO upgrade 'webpack-merge'

    const totalAssets = (0, _webpackMerge().merge)(assets, realtimeAssets);

    const html = /*#__PURE__*/_react().default.createElement(_uiFoundationUiRendering().Html, {
      assets: totalAssets,
      withDevTools: true,
      fullHeight: true,
      ssr: true
    });

    const renderedHtml = `<!DOCTYPE html>${_server().default.renderToStaticMarkup(html)}`;

    const fullHtml = _uiFoundationUiRendering().Html.fillContent(renderedHtml, renderedApp); // (4) serve


    return fullHtml;
  }
  /** adds elements to the Heads Up Display */


  /**
   * adds global context at the ui root
   * @deprecated replace with `.registerRenderHooks({ reactContext })`.
   */
  registerContext(context) {
    this.lifecycleSlot.register({
      reactContext: context
    });
  }

  registerRoot(uiRoot) {
    return this.uiRootSlot.register(uiRoot);
  }

  registerRenderHooks(hooks) {
    return this.lifecycleSlot.register(hooks);
  }

  triggerBrowserInit(lifecycleHooks, deserializedState) {
    return Promise.all(lifecycleHooks.map(([, hooks], idx) => {
      var _hooks$browserInit;

      return (_hooks$browserInit = hooks.browserInit) === null || _hooks$browserInit === void 0 ? void 0 : _hooks$browserInit.call(hooks, deserializedState[idx]);
    }));
  }

  triggerServerInit(lifecycleHooks, browser, server) {
    return Promise.all(lifecycleHooks.map(([, hooks]) => {
      var _hooks$serverInit;

      return (_hooks$serverInit = hooks.serverInit) === null || _hooks$serverInit === void 0 ? void 0 : _hooks$serverInit.call(hooks, {
        browser,
        server
      });
    }));
  }

  getReactContexts(lifecycleHooks, renderContexts) {
    return (0, _lodash().default)(lifecycleHooks.map(([, hooks], idx) => {
      const renderCtx = renderContexts[idx];
      const props = {
        renderCtx
      };
      return hooks.reactContext ? [hooks.reactContext, props] : undefined;
    }));
  }

  async onBeforeRender(renderContexts, lifecycleHooks, app) {
    await Promise.all(lifecycleHooks.map(async ([, hooks], idx) => {
      var _hooks$onBeforeRender;

      const ctx = renderContexts[idx];
      const nextCtx = await ((_hooks$onBeforeRender = hooks.onBeforeRender) === null || _hooks$onBeforeRender === void 0 ? void 0 : _hooks$onBeforeRender.call(hooks, ctx, app));
      return nextCtx || ctx;
    }));
    return renderContexts;
  }

  triggerBeforeHydrateHook(renderContexts, lifecycleHooks, app) {
    return Promise.all(lifecycleHooks.map(async ([, hooks], idx) => {
      var _hooks$onBeforeHydrat;

      const ctx = renderContexts[idx];
      const nextCtx = await ((_hooks$onBeforeHydrat = hooks.onBeforeHydrate) === null || _hooks$onBeforeHydrat === void 0 ? void 0 : _hooks$onBeforeHydrat.call(hooks, ctx, app));
      return nextCtx || ctx;
    }));
  }

  async triggerHydrateHook(renderContexts, lifecycleHooks, mountPoint) {
    await Promise.all(lifecycleHooks.map(([, hooks], idx) => {
      var _hooks$onHydrate;

      return (_hooks$onHydrate = hooks.onHydrate) === null || _hooks$onHydrate === void 0 ? void 0 : _hooks$onHydrate.call(hooks, renderContexts[idx], mountPoint);
    }));
  }

  async serialize(lifecycleHooks, renderContexts, app) {
    const json = {};
    await Promise.all(lifecycleHooks.map(async ([key, hooks], idx) => {
      var _hooks$serialize;

      const renderCtx = renderContexts[idx];
      const result = await ((_hooks$serialize = hooks.serialize) === null || _hooks$serialize === void 0 ? void 0 : _hooks$serialize.call(hooks, renderCtx, app));
      if (!result) return;
      if (result.json) json[key] = result.json;
    })); // more assets will be available in the future

    return {
      json
    };
  }

  async deserialize(lifecycleHooks) {
    const rawAssets = _uiFoundationUiRendering().Html.popAssets();

    const deserialized = await Promise.all(lifecycleHooks.map(async ([key, hooks]) => {
      try {
        var _hooks$deserialize;

        const raw = rawAssets.get(key);
        return (_hooks$deserialize = hooks.deserialize) === null || _hooks$deserialize === void 0 ? void 0 : _hooks$deserialize.call(hooks, raw);
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error(`failed deserializing server state for aspect ${key}`, e);
        return undefined;
      }
    }));
    return deserialized;
  }

  getRoot(rootExtension) {
    return this.uiRootSlot.get(rootExtension);
  }

  static async provider([GraphqlUi, router], config, [uiRootSlot, hudSlot, renderLifecycleSlot]) {
    const uiUi = new UiUI(router, uiRootSlot, hudSlot, renderLifecycleSlot);
    uiUi.registerRenderHooks(GraphqlUi.renderHooks);
    return uiUi;
  }

}

exports.UiUI = UiUI;
(0, _defineProperty2().default)(UiUI, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(UiUI, "dependencies", [_graphql().GraphqlAspect, _reactRouter().ReactRouterAspect]);
(0, _defineProperty2().default)(UiUI, "runtime", _ui().UIRuntime);

_ui().UIAspect.addRuntime(UiUI);

//# sourceMappingURL=ui.ui.runtime.js.map