"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariantsMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _consumerOverrides() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/consumer-overrides"));

  _consumerOverrides = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _workspaceModules() {
  const data = require("@teambit/workspace.modules.match-pattern");

  _workspaceModules = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _variants() {
  const data = require("./variants.aspect");

  _variants = function () {
    return data;
  };

  return data;
}

const INTERNAL_FIELDS = ['propagate', 'exclude', 'defaultScope'];

class VariantsMain {
  constructor(patterns) {
    this.patterns = patterns;
    (0, _defineProperty2().default)(this, "_loadedLegacy", void 0);
    this._loadedLegacy = _consumerOverrides().default.load(this.patterns);
    this.validateConfig();
  }

  validateConfig() {
    (0, _lodash().forEach)(this.patterns, (patternConfig, pattern) => {
      if (patternConfig.defaultScope && !(0, _legacyBitId().isValidScopeName)(patternConfig.defaultScope)) {
        throw new (_legacyBitId().InvalidScopeName)(patternConfig.defaultScope, undefined, pattern);
      }
    });
  }

  raw() {
    return this.patterns;
  }
  /**
   * Get all the patterns defined in the variants section of the workspace as the legacy ConsumerOverrides format
   */


  legacy() {
    // return ConsumerOverrides.load(this.patterns);
    return this._loadedLegacy;
  }
  /**
   * Gets the config for specific component after merge all matching patterns of the component dir and id in the variants section
   * @param rootDir
   */


  byRootDirAndName(rootDir, componentName) {
    const matches = [];
    (0, _lodash().forEach)(this.patterns, (patternConfig, pattern) => {
      const match = (0, _workspaceModules().isMatchPattern)(rootDir, componentName, pattern); // Ignore matches with exclude matches

      if (match.match && !match.excluded) {
        matches.push({
          config: patternConfig,
          specificity: match.maxSpecificity
        });
      }
    });
    const sortedMatches = (0, _workspaceModules().sortMatchesBySpecificity)(matches);
    let defaultScope;
    let propagate = true;
    const extensionsToMerge = [];
    sortedMatches.forEach(match => {
      defaultScope = defaultScope || match.config.defaultScope;

      if (propagate) {
        extensionsToMerge.push(getExtensionFromPatternRawConfig(match.config));
      }

      if (match.config.propagate === false) {
        propagate = false;
      }
    });

    const mergedExtensions = _extensionData().ExtensionDataList.mergeConfigs(extensionsToMerge);

    const result = {
      defaultScope,
      extensions: mergedExtensions,
      propagate,
      maxSpecificity: sortedMatches.length ? sortedMatches[0].specificity : -1
    };
    return result;
  }

  static async provider(_deps, config) {
    return new VariantsMain(config);
  }

}

exports.VariantsMain = VariantsMain;
(0, _defineProperty2().default)(VariantsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(VariantsMain, "dependencies", []);

function getExtensionFromPatternRawConfig(config) {
  const rawExtensions = (0, _lodash().omit)(config, INTERNAL_FIELDS);

  const extensions = _extensionData().ExtensionDataList.fromConfigObject(rawExtensions);

  return extensions;
}

_variants().VariantsAspect.addRuntime(VariantsMain);

//# sourceMappingURL=variants.main.runtime.js.map