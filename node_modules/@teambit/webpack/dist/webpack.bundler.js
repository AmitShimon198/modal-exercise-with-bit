"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebpackBundler = void 0;

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

class WebpackBundler {
  constructor(
  /**
   * targets to bundle.
   */
  targets,
  /**
   * webpack configuration.
   */
  configs, logger, webpack) {
    this.targets = targets;
    this.configs = configs;
    this.logger = logger;
    this.webpack = webpack;
  }

  async run() {
    const compilers = this.configs.map(config => this.webpack(config));
    const longProcessLogger = this.logger.createLongProcessLogger('running Webpack bundler', compilers.length);
    const componentOutput = await (0, _pMapSeries().default)(compilers, compiler => {
      const components = this.getComponents(compiler.outputPath);
      longProcessLogger.logProgress(components.map(component => component.id.toString()).join(', '));
      return new Promise(resolve => {
        // TODO: split to multiple processes to reduce time and configure concurrent builds.
        // @see https://github.com/trivago/parallel-webpack
        return compiler.run((err, stats) => {
          if (err) {
            return resolve({
              errors: [`${err.toString()}\n${err.stack}`],
              components
            });
          }

          if (!stats) throw new (_bitError().BitError)('unknown build error');
          const info = stats.toJson();
          return resolve({
            errors: info.errors,
            outputPath: stats.compilation.outputOptions.path,
            components,
            warnings: info.warnings
          });
        });
      });
    });
    longProcessLogger.end();
    return componentOutput;
  }

  getComponents(outputPath) {
    const splitPath = outputPath.split('/');
    splitPath.pop();
    const path = splitPath.join('/');
    const target = this.targets.find(targetCandidate => {
      return path === targetCandidate.outputPath;
    });

    if (!target) {
      throw new Error(`Could not find component id for path "${path}"`);
    }

    return target.components;
  }

}

exports.WebpackBundler = WebpackBundler;

//# sourceMappingURL=webpack.bundler.js.map