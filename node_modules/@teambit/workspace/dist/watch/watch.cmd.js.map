{"version":3,"sources":["watch.cmd.tsx"],"names":["WatchCommand","constructor","pubsub","logger","watcher","onAll","event","path","console","onStart","onReady","workspace","watchPathsSortByComponent","verbose","chalk","yellow","config","name","format","onChange","filePath","buildResults","duration","length","onAdd","onUnlink","p","onError","err","type","CompilerErrorEvent","TYPE","data","error","registerToEvents","sub","CompilerAspect","id","eventsListener","report","cliArgs","watch","msgs"],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport moment from 'moment';\n\nimport { Command, CommandOptions } from '@teambit/cli';\nimport type { Logger } from '@teambit/logger';\nimport type { BitBaseEvent, PubsubMain } from '@teambit/pubsub';\n\n// import IDs and events\nimport { CompilerAspect, CompilerErrorEvent } from '@teambit/compiler';\n\nimport { Watcher } from './watcher';\nimport { formatCompileResults, formatWatchPathsSortByComponent } from './output-formatter';\nimport { OnComponentEventResult } from '../on-component-events';\n\nexport class WatchCommand implements Command {\n  msgs = {\n    onAll: (event, path) => this.logger.console(`Event: \"${event}\". Path: ${path}`),\n    onStart: () => {},\n    onReady: (workspace, watchPathsSortByComponent, verbose) => {\n      if (verbose) {\n        this.logger.console(formatWatchPathsSortByComponent(watchPathsSortByComponent));\n      }\n      this.logger.console(\n        chalk.yellow(\n          `Watching for component changes in workspace ${workspace.config.name} (${moment().format('HH:mm:ss')})...\\n`\n        )\n      );\n    },\n    onChange: (filePath: string, buildResults: OnComponentEventResult[], verbose: boolean, duration) => {\n      if (!buildResults.length) {\n        this.logger.console(`The file ${filePath} has been changed, but nothing to compile.\\n\\n`);\n        return;\n      }\n      this.logger.console(`The file ${filePath} has been changed.\\n\\n`);\n      this.logger.console(formatCompileResults(buildResults, verbose));\n      this.logger.console(`Finished. (${duration}ms)`);\n      this.logger.console(chalk.yellow(`Watching for component changes (${moment().format('HH:mm:ss')})...`));\n    },\n    onAdd: (filePath: string, buildResults: OnComponentEventResult[], verbose: boolean, duration) => {\n      this.logger.console(`The file ${filePath} has been added.\\n\\n`);\n      this.logger.console(formatCompileResults(buildResults, verbose));\n      this.logger.console(`Finished. (${duration}ms)`);\n      this.logger.console(chalk.yellow(`Watching for component changes (${moment().format('HH:mm:ss')})...`));\n    },\n    onUnlink: (p) => {\n      this.logger.console(`file ${p} has been removed`);\n    },\n    onError: (err) => {\n      this.logger.console(`Watcher error ${err}`);\n    },\n  };\n\n  name = 'watch';\n  description = 'watch a set of components';\n  alias = '';\n  group = 'development';\n  shortDescription = '';\n  options = [['v', 'verbose', 'showing npm verbose output for inspection and prints stack trace']] as CommandOptions;\n\n  constructor(\n    /**\n     * logger extension.\n     */\n    private pubsub: PubsubMain,\n\n    /**\n     * logger extension.\n     */\n    private logger: Logger,\n\n    /**\n     * watcher extension.\n     */\n    private watcher: Watcher\n  ) {\n    this.registerToEvents();\n  }\n\n  private registerToEvents() {\n    this.pubsub.sub(CompilerAspect.id, this.eventsListener);\n  }\n\n  private eventsListener = (event: BitBaseEvent<any>) => {\n    switch (event.type) {\n      case CompilerErrorEvent.TYPE:\n        this.logger.console(`Watcher error ${event.data.error}, 'error'`);\n        break;\n      default:\n    }\n  };\n\n  async report(cliArgs: [], { verbose = false }: { verbose?: boolean }) {\n    await this.watcher.watch({ msgs: this.msgs, verbose });\n    return 'watcher terminated';\n  }\n}\n"]}