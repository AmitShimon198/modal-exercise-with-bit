"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Watcher = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _chokidar() {
  const data = _interopRequireDefault(require("chokidar"));

  _chokidar = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require("../");

  _ = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("../events");

  _events = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class Watcher {
  constructor(workspace, pubsub, trackDirs = {}, verbose = false, multipleWatchers = []) {
    this.workspace = workspace;
    this.pubsub = pubsub;
    this.trackDirs = trackDirs;
    this.verbose = verbose;
    this.multipleWatchers = multipleWatchers;
    (0, _defineProperty2().default)(this, "fsWatcher", void 0);
  }

  async watch(opts) {
    this.verbose = Boolean(opts.verbose);
    await this.watchAll({
      msgs: opts.msgs,
      verbose: this.verbose
    });
  }

  get consumer() {
    return this.workspace.consumer;
  }

  async watchAll(opts) {
    var _opts$msgs;

    // TODO: run build in the beginning of process (it's work like this in other envs)
    const _verbose = (opts === null || opts === void 0 ? void 0 : opts.verbose) || false;

    await this.createWatcher();
    const watcher = this.fsWatcher;
    opts === null || opts === void 0 ? void 0 : (_opts$msgs = opts.msgs) === null || _opts$msgs === void 0 ? void 0 : _opts$msgs.onStart(this.workspace);
    return new Promise((resolve, reject) => {
      // prefix your command with "BIT_LOG=*" to see all watch events
      if (process.env.BIT_LOG) {
        var _opts$msgs2, _opts$msgs3;

        if (opts !== null && opts !== void 0 && (_opts$msgs2 = opts.msgs) !== null && _opts$msgs2 !== void 0 && _opts$msgs2.onAll) watcher.on('all', opts === null || opts === void 0 ? void 0 : (_opts$msgs3 = opts.msgs) === null || _opts$msgs3 === void 0 ? void 0 : _opts$msgs3.onAll);
      }

      watcher.on('ready', () => {
        var _opts$msgs4;

        opts === null || opts === void 0 ? void 0 : (_opts$msgs4 = opts.msgs) === null || _opts$msgs4 === void 0 ? void 0 : _opts$msgs4.onReady(this.workspace, this.trackDirs, _verbose);
      }); // eslint-disable-next-line @typescript-eslint/no-misused-promises

      watcher.on('change', async filePath => {
        var _opts$msgs5;

        const startTime = new Date().getTime();
        const buildResults = (await this.handleChange(filePath)) || [];
        const duration = new Date().getTime() - startTime;
        opts === null || opts === void 0 ? void 0 : (_opts$msgs5 = opts.msgs) === null || _opts$msgs5 === void 0 ? void 0 : _opts$msgs5.onChange(filePath, buildResults, _verbose, duration);
      }); // eslint-disable-next-line @typescript-eslint/no-misused-promises

      watcher.on('add', async filePath => {
        var _opts$msgs6;

        const startTime = new Date().getTime();
        const buildResults = (await this.handleChange(filePath)) || [];
        const duration = new Date().getTime() - startTime;
        opts === null || opts === void 0 ? void 0 : (_opts$msgs6 = opts.msgs) === null || _opts$msgs6 === void 0 ? void 0 : _opts$msgs6.onAdd(filePath, buildResults, _verbose, duration);
      }); // eslint-disable-next-line @typescript-eslint/no-misused-promises

      watcher.on('unlink', async p => {
        var _opts$msgs7;

        opts === null || opts === void 0 ? void 0 : (_opts$msgs7 = opts.msgs) === null || _opts$msgs7 === void 0 ? void 0 : _opts$msgs7.onUnlink(p);
        await this.handleChange(p);
      });
      watcher.on('error', err => {
        var _opts$msgs8;

        opts === null || opts === void 0 ? void 0 : (_opts$msgs8 = opts.msgs) === null || _opts$msgs8 === void 0 ? void 0 : _opts$msgs8.onError(err);
        reject(err);
      });
    });
  }

  async handleChange(filePath) {
    try {
      if (filePath.endsWith(_constants().BIT_MAP)) {
        const buildResults = await this.handleBitmapChanges();
        this.completeWatch();
        return buildResults;
      }

      const componentId = await this.getComponentIdAndClearItsCache(filePath);

      if (!componentId) {
        _logger().default.debug(`file ${filePath} is not part of any component, ignoring it`);

        return this.completeWatch();
      }

      const buildResults = await this.executeWatchOperationsOnComponent(componentId);
      this.completeWatch();
      return buildResults;
    } catch (err) {
      const msg = `watcher found an error while handling ${filePath}`;

      _logger().default.error(msg, err);

      _logger().default.console(`${msg}, ${err.message}`);

      return [];
    }
  }
  /**
   * if .bitmap has change, it's possible that a new component has added. trigger onComponentAdd.
   */


  async handleBitmapChanges() {
    const previewsTrackDirs = _objectSpread({}, this.trackDirs);

    await this.workspace._reloadConsumer();
    await this.setTrackDirs();
    const newDirs = (0, _lodash().difference)(Object.keys(this.trackDirs), Object.keys(previewsTrackDirs));
    const removedDirs = (0, _lodash().difference)(Object.keys(previewsTrackDirs), Object.keys(this.trackDirs));
    const results = [];

    if (newDirs.length) {
      this.fsWatcher.add(newDirs);
      const addResults = await (0, _pMapSeries().default)(newDirs, dir => this.executeWatchOperationsOnComponent(this.trackDirs[dir], false));
      results.push(...addResults.flat());
    }

    if (removedDirs.length) {
      await this.fsWatcher.unwatch(removedDirs);
      await (0, _pMapSeries().default)(removedDirs, dir => this.executeWatchOperationsOnRemove(previewsTrackDirs[dir]));
    }

    return results;
  }

  async executeWatchOperationsOnRemove(componentId) {
    _logger().default.debug(`running OnComponentRemove hook for ${_chalk().default.bold(componentId.toString())}`);

    this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentRemovedEvent(componentId.toString()));
    await this.workspace.triggerOnComponentRemove(componentId);
  }

  async executeWatchOperationsOnComponent(componentId, isChange = true) {
    if (this.isComponentWatchedExternally(componentId)) {
      // update capsule, once done, it automatically triggers the external watcher
      await this.workspace.get(componentId);
      return [];
    }

    const idStr = componentId.toString();

    if (isChange) {
      _logger().default.debug(`running OnComponentChange hook for ${_chalk().default.bold(idStr)}`);

      this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentChangeEvent(idStr, 'OnComponentChange'));
    } else {
      _logger().default.debug(`running OnComponentAdd hook for ${_chalk().default.bold(idStr)}`);

      this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentAddEvent(idStr, 'OnComponentAdd'));
    }

    let buildResults;

    try {
      buildResults = isChange ? await this.workspace.triggerOnComponentChange(componentId) : await this.workspace.triggerOnComponentAdd(componentId);
    } catch (err) {
      // do not exist the watch process on errors, just print them
      _logger().default.console(err.message || err);

      return [];
    }

    if (buildResults && buildResults.length) {
      return buildResults;
    }

    _logger().default.console(`${idStr} doesn't have a compiler, nothing to build`);

    return [];
  }

  creatOnComponentRemovedEvent(idStr) {
    return new (_events().OnComponentRemovedEvent)(Date.now(), idStr);
  }

  creatOnComponentChangeEvent(idStr, hook) {
    return new (_events().OnComponentChangeEvent)(Date.now(), idStr, hook);
  }

  creatOnComponentAddEvent(idStr, hook) {
    return new (_events().OnComponentAddEvent)(Date.now(), idStr, hook);
  }

  completeWatch() {
    _loader().default.stop();

    return [];
  }

  isComponentWatchedExternally(componentId) {
    const watcherData = this.multipleWatchers.find(m => m.componentIds.find(id => id.isEqual(componentId._legacy)));

    if (watcherData) {
      _logger().default.debug(`${componentId.toString()} is watched by ${watcherData.compilerId.toString()}`);

      return true;
    }

    return false;
  }
  /**
   * if a file was added/remove, once the component is loaded, it changes .bitmap, and then the
   * entire cache is invalidated and the consumer is reloaded.
   * when a file just changed, no need to reload the consumer, it is enough to just delete the
   * component from the cache (both, workspace and consumer)
   */


  async getComponentIdAndClearItsCache(filePath) {
    const relativeFile = (0, _utils().pathNormalizeToLinux)(this.consumer.getPathRelativeToConsumer(filePath));
    const trackDir = this.findTrackDirByFilePathRecursively(relativeFile);

    if (!trackDir) {
      // the file is not part of any component. If it was a new component, or a new file of
      // existing component, then, handleBitmapChanges() should deal with it.
      return null;
    }

    const componentId = this.trackDirs[trackDir];
    this.workspace.clearComponentCache(componentId);
    const component = await this.workspace.get(componentId);
    const componentMap = component.state._consumer.componentMap;

    if (componentMap.getFilesRelativeToConsumer().find(p => p === relativeFile)) {
      return componentId;
    } // the file is inside the component dir but it's ignored. (e.g. it's in IGNORE_LIST)


    return null;
  }

  findTrackDirByFilePathRecursively(filePath) {
    if (this.trackDirs[filePath]) return filePath;
    const parentDir = (0, _path().dirname)(filePath);
    if (parentDir === filePath) return null;
    return this.findTrackDirByFilePathRecursively(parentDir);
  }

  async createWatcher() {
    const pathsToWatch = await this.getPathsToWatch();
    this.fsWatcher = _chokidar().default.watch(pathsToWatch, {
      ignoreInitial: true,
      // Using the function way since the regular way not working as expected
      // It might be solved when upgrading to chokidar > 3.0.0
      // See:
      // https://github.com/paulmillr/chokidar/issues/773
      // https://github.com/paulmillr/chokidar/issues/492
      // https://github.com/paulmillr/chokidar/issues/724
      ignored: path => {
        // Ignore package.json temporarily since it cerates endless loop since it's re-written after each build
        if (path.includes(`${_path().sep}node_modules${_path().sep}`) || path.includes(`${_path().sep}package.json`)) {
          return true;
        }

        return false;
      },
      persistent: true,
      useFsEvents: false
    });
  }

  async setTrackDirs() {
    this.trackDirs = {};
    const componentsFromBitMap = this.consumer.bitMap.getAllComponents([_constants().COMPONENT_ORIGINS.AUTHORED, _constants().COMPONENT_ORIGINS.IMPORTED]);
    await Promise.all(componentsFromBitMap.map(async componentMap => {
      const bitId = componentMap.id;
      const trackDir = componentMap.getTrackDir();
      if (!trackDir) throw new Error(`${bitId.toString()} has no rootDir, which is invalid in Harmony`);
      const componentId = await this.workspace.resolveComponentId(bitId);
      this.trackDirs[trackDir] = componentId;
    }));
  }

  async getPathsToWatch() {
    await this.setTrackDirs();
    const paths = [...Object.keys(this.trackDirs), _constants().BIT_MAP];
    const pathsAbsolute = paths.map(dir => this.consumer.toAbsolutePath(dir));
    return pathsAbsolute;
  }

}

exports.Watcher = Watcher;

//# sourceMappingURL=watcher.js.map