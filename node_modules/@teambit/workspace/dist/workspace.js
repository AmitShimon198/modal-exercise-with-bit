"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Workspace = exports.ComponentRemoved = exports.ComponentChanged = exports.ComponentAdded = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _aspectLoader() {
  const data = require("@teambit/aspect-loader");

  _aspectLoader = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _workspaceModules() {
  const data = require("@teambit/workspace.modules.match-pattern");

  _workspaceModules = function () {
    return data;
  };

  return data;
}

function _harmonyModules() {
  const data = require("@teambit/harmony.modules.requireable-component");

  _harmonyModules = function () {
    return data;
  };

  return data;
}

function _harmonyModules2() {
  const data = require("@teambit/harmony.modules.resolved-component");

  _harmonyModules2 = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("@teambit/legacy/dist/api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _consumer2() {
  const data = require("@teambit/legacy/dist/consumer");

  _consumer2 = function () {
    return data;
  };

  return data;
}

function _addComponents() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/add-components"));

  _addComponents = function () {
    return data;
  };

  return data;
}

function _exceptions2() {
  const data = require("@teambit/legacy/dist/scope/exceptions");

  _exceptions2 = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _noComponentDir() {
  const data = require("@teambit/legacy/dist/consumer/component/exceptions/no-component-dir");

  _noComponentDir = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("@teambit/legacy/dist/scope/graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _component2() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component"));

  _component2 = function () {
    return data;
  };

  return data;
}

function _componentConfigFile() {
  const data = require("./component-config-file");

  _componentConfigFile = function () {
    return data;
  };

  return data;
}

function _exceptions3() {
  const data = require("./exceptions");

  _exceptions3 = function () {
    return data;
  };

  return data;
}

function _watcher() {
  const data = require("./watch/watcher");

  _watcher = function () {
    return data;
  };

  return data;
}

function _componentStatus() {
  const data = require("./workspace-component/component-status");

  _componentStatus = function () {
    return data;
  };

  return data;
}

function _workspaceComponentLoader() {
  const data = require("./workspace-component/workspace-component-loader");

  _workspaceComponentLoader = function () {
    return data;
  };

  return data;
}

function _incorrectEnvAspect() {
  const data = require("./exceptions/incorrect-env-aspect");

  _incorrectEnvAspect = function () {
    return data;
  };

  return data;
}

const ComponentAdded = 'componentAdded';
exports.ComponentAdded = ComponentAdded;
const ComponentChanged = 'componentChanged';
exports.ComponentChanged = ComponentChanged;
const ComponentRemoved = 'componentRemoved';
exports.ComponentRemoved = ComponentRemoved;
const DEFAULT_VENDOR_DIR = 'vendor';
/**
 * API of the Bit Workspace
 */

class Workspace {
  constructor(
  /**
   * private pubsub.
   */
  pubsub, config,
  /**
   * private access to the legacy consumer instance.
   */
  consumer,
  /**
   * access to the workspace `Scope` instance
   */
  scope,
  /**
   * access to the `ComponentProvider` instance
   */
  componentAspect, isolator, dependencyResolver, variants, aspectLoader, logger, componentList = new (_componentsList().default)(consumer),
  /**
   * private reference to the instance of Harmony.
   */
  harmony,
  /**
   * on component load slot.
   */
  onComponentLoadSlot,
  /**
   * on component change slot.
   */
  onComponentChangeSlot, envs,
  /**
   * on component add slot.
   */
  onComponentAddSlot, onComponentRemoveSlot, graphql) {
    var _this$config;

    this.pubsub = pubsub;
    this.config = config;
    this.consumer = consumer;
    this.scope = scope;
    this.componentAspect = componentAspect;
    this.isolator = isolator;
    this.dependencyResolver = dependencyResolver;
    this.variants = variants;
    this.aspectLoader = aspectLoader;
    this.logger = logger;
    this.componentList = componentList;
    this.harmony = harmony;
    this.onComponentLoadSlot = onComponentLoadSlot;
    this.onComponentChangeSlot = onComponentChangeSlot;
    this.envs = envs;
    this.onComponentAddSlot = onComponentAddSlot;
    this.onComponentRemoveSlot = onComponentRemoveSlot;
    this.graphql = graphql;
    (0, _defineProperty2().default)(this, "priority", true);
    (0, _defineProperty2().default)(this, "owner", void 0);
    (0, _defineProperty2().default)(this, "componentsScopeDirsMap", void 0);
    (0, _defineProperty2().default)(this, "componentLoader", void 0);
    (0, _defineProperty2().default)(this, "watcher", new (_watcher().Watcher)(this, this.pubsub));
    // TODO: refactor - prefer to avoid code inside the constructor.
    this.owner = (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.defaultOwner;
    this.componentLoader = new (_workspaceComponentLoader().WorkspaceComponentLoader)(this, logger, dependencyResolver, envs);
    this.validateConfig();
  }

  validateConfig() {
    const defaultScope = this.config.defaultScope;
    if (this.consumer.isLegacy) return;
    if (!defaultScope) throw new Error('defaultScope is missing');
    if (!(0, _legacyBitId().isValidScopeName)(defaultScope)) throw new (_legacyBitId().InvalidScopeName)(defaultScope);
  }
  /**
   * watcher api.
   */


  /**
   * root path of the Workspace.
   */
  get path() {
    return this.consumer.getPath();
  }
  /** get the `node_modules` folder of this workspace */


  get modulesPath() {
    return _path().default.join(this.path, 'node_modules');
  }

  get isLegacy() {
    return this.consumer.isLegacy;
  }

  onComponentLoad(loadFn) {
    this.onComponentLoadSlot.register(loadFn);
    return this;
  }

  registerOnComponentChange(onComponentChangeFunc) {
    this.onComponentChangeSlot.register(onComponentChangeFunc);
    return this;
  }

  registerOnComponentAdd(onComponentAddFunc) {
    this.onComponentAddSlot.register(onComponentAddFunc);
    return this;
  }

  registerOnComponentRemove(onComponentRemoveFunc) {
    this.onComponentRemoveSlot.register(onComponentRemoveFunc);
    return this;
  }
  /**
   * name of the workspace as configured in either `workspace.json`.
   * defaults to workspace root directory name.
   */


  get name() {
    if (this.config.name) return this.config.name;
    const tokenizedPath = this.path.split('/');
    return tokenizedPath[tokenizedPath.length - 1];
  }

  get icon() {
    return this.config.icon;
  }

  async hasModifiedDependencies(component) {
    const componentsList = new (_componentsList().default)(this.consumer);
    const listAutoTagPendingComponents = await componentsList.listAutoTagPendingComponents();
    const isAutoTag = listAutoTagPendingComponents.find(consumerComponent => consumerComponent.id.isEqualWithoutVersion(component.id._legacy));
    if (isAutoTag) return true;
    return false;
  }
  /**
   * get Component issues
   */


  getComponentIssues(component) {
    return component.state._consumer.issues || null;
  }
  /**
   * provides status of all components in the workspace.
   */


  async getComponentStatus(component) {
    const status = await this.consumer.getComponentStatusById(component.id._legacy);
    const hasModifiedDependencies = await this.hasModifiedDependencies(component);
    return _componentStatus().ComponentStatus.fromLegacy(status, hasModifiedDependencies, component.isOutdated());
  }
  /**
   * list all workspace components.
   */


  async list(filter) {
    const legacyIds = this.consumer.bitMap.getAllIdsAvailableOnLane();
    const ids = await this.resolveMultipleComponentIds(legacyIds);
    return this.getMany(filter && filter.limit ? (0, _lodash().slice)(ids, filter.offset, filter.offset + filter.limit) : ids);
  }
  /**
   * list all invalid components.
   * (see the invalid criteria in ConsumerComponent.isComponentInvalidByErrorType())
   */


  async listInvalid() {
    const legacyIds = this.consumer.bitMap.getAllIdsAvailableOnLane();
    const ids = await this.resolveMultipleComponentIds(legacyIds);
    return this.componentLoader.getInvalid(ids);
  }
  /**
   * get ids of all workspace components.
   */


  async listIds() {
    return this.resolveMultipleComponentIds(this.consumer.bitmapIdsFromCurrentLane);
  }
  /**
   * Check if a specific id exist in the workspace
   * @param componentId
   */


  async hasId(componentId) {
    const ids = await this.listIds();
    const found = ids.find(id => {
      return id.isEqual(componentId);
    });
    return !!found;
  }
  /**
   * whether or not a workspace has a component with the given name
   */


  async hasName(name) {
    const ids = await this.listIds();
    return Boolean(ids.find(id => id.fullName === name));
  }
  /**
   * Check if a specific id exist in the workspace or in the scope
   * @param componentId
   */


  async hasIdNested(componentId, includeCache = true) {
    const found = await this.hasId(componentId);
    if (found) return found;
    return this.scope.hasIdNested(componentId, includeCache);
  }
  /**
   * list all modified components in the workspace.
   */


  async modified() {
    const ids = await this.componentList.listModifiedComponents(false);
    const componentIds = ids.map(_component().ComponentID.fromLegacy);
    return this.getMany(componentIds);
  }
  /**
   * list all new components in the workspace.
   */


  async newComponents() {
    const ids = await this.componentList.listNewComponents(false);
    const componentIds = ids.map(_component().ComponentID.fromLegacy);
    return this.getMany(componentIds);
  }
  /**
   * get all workspace component-ids, include vendor components.
   * (exclude nested dependencies in case dependencies are saved as components and not packages)
   */


  getAllComponentIds() {
    const bitIds = this.consumer.bitMap.getAuthoredAndImportedBitIds();
    return this.resolveMultipleComponentIds(bitIds);
  }

  async getNewAndModifiedIds() {
    const ids = await this.componentList.listTagPendingComponents();
    return this.resolveMultipleComponentIds(ids);
  }

  async getLogs(id) {
    return this.scope.getLogs(id);
  }

  async getLegacyGraph(ids) {
    if (!ids || ids.length < 1) ids = await this.listIds();
    const legacyIds = ids.map(id => id._legacy);
    const legacyGraph = await (0, _componentsGraph().buildOneGraphForComponents)(legacyIds, this.consumer);
    return legacyGraph;
  }

  async loadCapsules(bitIds) {
    // throw new Error("Method not implemented.");
    const components = await this.load(bitIds);
    return components.map(comp => comp.capsule);
  }
  /**
   * fully load components, including dependency resolution and prepare them for runtime.
   * @todo: remove the string option, use only BitId
   */


  async load(ids) {
    const componentIds = await this.resolveMultipleComponentIds(ids);
    const components = await this.getMany(componentIds);
    const network = await this.isolator.isolateComponents(components.map(c => c.id));
    const resolvedComponents = components.map(component => {
      const capsule = network.graphCapsules.getCapsule(component.id);
      if (!capsule) throw new Error(`unable to find capsule for ${component.id.toString()}`);
      return new (_harmonyModules2().ResolvedComponent)(component, capsule);
    });
    return resolvedComponents;
  }

  async createAspectList(extensionDataList) {
    const entiresP = extensionDataList.map(async entry => {
      return new (_component().AspectEntry)(await this.resolveComponentId(entry.id), entry);
    });
    const entries = await Promise.all(entiresP);
    return this.componentAspect.createAspectListFromEntries(entries);
  }
  /**
   * get a component from workspace
   * @param id component ID
   */


  async get(componentId, forCapsule = false, legacyComponent, useCache = true, storeInCache = true) {
    this.logger.debug(`get ${componentId.toString()}`);
    return this.componentLoader.get(componentId, forCapsule, legacyComponent, useCache, storeInCache);
  } // TODO: @gilad we should refactor this asap into to the envs aspect.


  async getEnvSystemDescriptor(component) {
    const env = this.envs.calculateEnv(component);

    if (env.env.__getDescriptor && typeof env.env.__getDescriptor === 'function') {
      var _services;

      const systemDescriptor = await env.env.__getDescriptor(); // !important persist services only on the env itself.

      let services;
      if (this.envs.isEnvRegistered(component.id.toString())) services = this.envs.getServices(env);
      const icon = this.aspectLoader.getDescriptor(env.id).icon || env.env.icon;
      return {
        type: systemDescriptor.type,
        id: env.id,
        name: env.name,
        icon,
        description: env.description,
        services: (_services = services) === null || _services === void 0 ? void 0 : _services.toObject()
      };
    }

    return {};
  }

  clearCache() {
    this.logger.debug('clearing the workspace and scope caches');
    this.componentLoader.clearCache();
    this.scope.clearCache();
    this.componentList = new (_componentsList().default)(this.consumer);
  }

  clearComponentCache(id) {
    this.componentLoader.clearComponentCache(id);
    this.consumer.componentLoader.clearOneComponentCache(id._legacy);
    this.componentList = new (_componentsList().default)(this.consumer);
  }

  async triggerOnComponentChange(id) {
    const component = await this.get(id); // if a new file was added, upon component-load, its .bitmap entry is updated to include the
    // new file. write these changes to the .bitmap file so then other processes have access to
    // this new file. If the .bitmap wasn't change, it won't do anything.

    await this.writeBitMap();
    const onChangeEntries = this.onComponentChangeSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]

    const results = [];
    await (0, _pMapSeries().default)(onChangeEntries, async ([extension, onChangeFunc]) => {
      const onChangeResult = await onChangeFunc(component);
      results.push({
        extensionId: extension,
        results: onChangeResult
      });
    }); // TODO: find way to standardize event names.

    await this.graphql.pubsub.publish(ComponentChanged, {
      componentChanged: {
        component
      }
    });
    return results;
  }

  async triggerOnComponentAdd(id) {
    const component = await this.get(id);
    const onAddEntries = this.onComponentAddSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]

    const results = [];
    await (0, _pMapSeries().default)(onAddEntries, async ([extension, onAddFunc]) => {
      const onAddResult = await onAddFunc(component);
      results.push({
        extensionId: extension,
        results: onAddResult
      });
    });
    await this.graphql.pubsub.publish(ComponentAdded, {
      componentAdded: {
        component
      }
    });
    return results;
  }

  async triggerOnComponentRemove(id) {
    const onRemoveEntries = this.onComponentRemoveSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]

    const results = [];
    await (0, _pMapSeries().default)(onRemoveEntries, async ([extension, onRemoveFunc]) => {
      const onRemoveResult = await onRemoveFunc(id);
      results.push({
        extensionId: extension,
        results: onRemoveResult
      });
    });
    await this.graphql.pubsub.publish(ComponentRemoved, {
      componentRemoved: {
        componentIds: [id.toObject()]
      }
    });
    return results;
  }

  getState(id, hash) {
    return this.scope.getState(id, hash);
  }

  getSnap(id, hash) {
    return this.scope.getSnap(id, hash);
  }

  getCurrentLaneId() {
    return this.consumer.getCurrentLaneId();
  }

  getDefaultExtensions() {
    if (!this.config.extensions) {
      return new (_extensionData().ExtensionDataList)();
    }

    return _extensionData().ExtensionDataList.fromConfigObject(this.config.extensions);
  }

  async ejectConfig(id, options) {
    const componentId = await this.resolveComponentId(id);
    const component = await this.scope.get(componentId);
    const aspects = component !== null && component !== void 0 && component.state.aspects ? await this.resolveScopeAspectListIds(component === null || component === void 0 ? void 0 : component.state.aspects) : await this.createAspectList(new (_extensionData().ExtensionDataList)());
    const componentDir = this.componentDir(id, {
      ignoreVersion: true
    });
    const componentConfigFile = new (_componentConfigFile().ComponentConfigFile)(componentId, aspects, options.propagate);
    await componentConfigFile.write(componentDir, {
      override: options.override
    });
    return {
      configPath: _componentConfigFile().ComponentConfigFile.composePath(componentDir)
    };
  }

  async resolveScopeAspectListIds(aspectListFromScope) {
    const resolvedList = await aspectListFromScope.pmap(async entry => {
      if (entry.id.scope !== this.scope.name) {
        return entry;
      }

      const newId = await this.resolveComponentId(entry.id.fullName);
      const newEntry = new (_component().AspectEntry)(newId, entry.legacy);
      return newEntry;
    });
    return resolvedList;
  }
  /**
   * load components into the workspace through a variants pattern.
   * @param pattern variants.
   * @param scope scope name.
   */


  async byPattern(pattern, scope = '**') {
    const ids = await this.listIds();
    const finalPattern = `${scope}/${pattern || '**'}`;
    const targetIds = ids.filter(id => {
      const spec = (0, _workspaceModules().isMatchNamespacePatternItem)(id.toStringWithoutVersion(), finalPattern);
      return spec.match;
    });
    const components = await this.getMany(targetIds);
    return components;
  }

  async getMany(ids, forCapsule = false) {
    return this.componentLoader.getMany(ids, forCapsule);
  }

  getManyByLegacy(components) {
    return (0, _pMapSeries().default)(components, async component => {
      const id = await this.resolveComponentId(component.id);
      return this.get(id, undefined, component);
    });
  }
  /**
   * This will make sure to fetch the objects prior to load them
   * do not use it if you are not sure you need it.
   * It will influence the performance
   * currently it used only for get many of aspects
   * @param ids
   * @param forCapsule
   */


  async importAndGetMany(ids, forCapsule = false) {
    await this.scope.import(ids);
    return this.componentLoader.getMany(ids, forCapsule);
  }
  /**
   * @deprecated use this.track() instead
   * track a new component. (practically, add it to .bitmap).
   *
   * @param componentPaths component paths relative to the workspace dir
   * @param id if not set, will be concluded from the filenames
   * @param main if not set, will try to guess according to some strategies and throws if failed
   * @param override whether add details to an existing component or re-define it
   */


  async add(componentPaths, id, main, override = false) {
    const addComponent = new (_addComponents().default)({
      consumer: this.consumer
    }, {
      componentPaths,
      id,
      main,
      override
    });
    const addResults = await addComponent.add(); // @todo: the legacy commands have `consumer.onDestroy()` on command completion, it writes the
    //  .bitmap file. workspace needs a similar mechanism. once done, remove the next line.

    await this.consumer.bitMap.write(this.consumer.componentFsCache);
    return addResults;
  }
  /**
   * add a new component to the .bitmap file.
   * this method only adds the records in memory but doesn't persist to the filesystem.
   * to write the .bitmap file once completed, run "await this.writeBitMap();"
   */


  async track(trackData) {
    const addComponent = new (_addComponents().default)({
      consumer: this.consumer
    }, {
      componentPaths: [trackData.rootDir],
      id: trackData.componentName,
      main: trackData.mainFile,
      override: false
    });
    const result = await addComponent.add();
    const addedComponent = result.addedComponents[0];
    const componentName = (addedComponent === null || addedComponent === void 0 ? void 0 : addedComponent.id.name) || trackData.componentName;
    const files = (addedComponent === null || addedComponent === void 0 ? void 0 : addedComponent.files.map(f => f.relativePath)) || [];
    return {
      componentName,
      files,
      warnings: result.warnings
    };
  }

  async write(rootPath, component) {
    await Promise.all(component.filesystem.files.map(async file => {
      const pathToWrite = _path().default.join(this.path, rootPath, file.path);

      await _fsExtra().default.outputFile(pathToWrite, file.contents);
    }));
  }

  async writeBitMap() {
    await this.consumer.writeBitMap();
  }
  /**
   * Get the component root dir in the file system (relative to workspace or full)
   * @param componentId
   * @param relative return the path relative to the workspace or full path
   */


  componentDir(componentId, bitMapOptions, options = {
    relative: false
  }) {
    return this.componentDirFromLegacyId(componentId._legacy, bitMapOptions, options);
  }

  componentDirFromLegacyId(bitId, bitMapOptions, options = {
    relative: false
  }) {
    const componentMap = this.consumer.bitMap.getComponent(bitId, bitMapOptions);
    const relativeComponentDir = componentMap.getComponentDir();

    if (!relativeComponentDir) {
      throw new (_noComponentDir().NoComponentDir)(bitId.toString());
    }

    if (options.relative) {
      return relativeComponentDir;
    }

    return _path().default.join(this.path, relativeComponentDir);
  }

  componentDirToAbsolute(relativeComponentDir) {
    return _path().default.join(this.path, relativeComponentDir);
  }

  async componentDefaultScope(componentId) {
    const relativeComponentDir = this.componentDir(componentId, {
      ignoreVersion: true
    }, {
      relative: true
    });
    return this.componentDefaultScopeFromComponentDirAndName(relativeComponentDir, componentId.fullName);
  }

  async componentDefaultScopeFromComponentDirAndName(relativeComponentDir, name) {
    const componentConfigFile = await this.componentConfigFileFromComponentDirAndName(relativeComponentDir, name);

    if (componentConfigFile && componentConfigFile.defaultScope) {
      return componentConfigFile.defaultScope;
    }

    return this.componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(relativeComponentDir, name);
  }

  get defaultScope() {
    return this.config.defaultScope;
  }

  async componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(relativeComponentDir, name) {
    const variantConfig = this.variants.byRootDirAndName(relativeComponentDir, name);

    if (variantConfig && variantConfig.defaultScope) {
      return variantConfig.defaultScope;
    }

    const isVendor = this.isVendorComponentByComponentDir(relativeComponentDir);

    if (!isVendor) {
      return this.config.defaultScope;
    }

    return undefined;
  }
  /**
   * Calculate the component config based on:
   * the component.json file in the component folder
   * matching pattern in the variants config
   * defaults extensions from workspace config
   *
   * @param {ComponentID} componentId
   * @param {Component} [componentFromScope]
   * @returns {Promise<ExtensionDataList>}
   * @memberof Workspace
   */


  async componentExtensions(componentId, componentFromScope) {
    var _componentFromScope$c, _componentConfigFile$, _variantConfig$propag;

    // TODO: consider caching this result
    let configFileExtensions;
    let variantsExtensions;
    let wsDefaultExtensions;
    const mergeFromScope = true;
    const scopeExtensions = (componentFromScope === null || componentFromScope === void 0 ? void 0 : (_componentFromScope$c = componentFromScope.config) === null || _componentFromScope$c === void 0 ? void 0 : _componentFromScope$c.extensions) || new (_extensionData().ExtensionDataList)();
    const componentConfigFile = await this.componentConfigFile(componentId);

    if (componentConfigFile) {
      configFileExtensions = componentConfigFile.aspects.toLegacy(); // do not merge from scope data when there is component config file
      // mergeFromScope = false;
    }

    const relativeComponentDir = this.componentDir(componentId, {
      ignoreVersion: true
    }, {
      relative: true
    });
    const variantConfig = this.variants.byRootDirAndName(relativeComponentDir, componentId.fullName);

    if (variantConfig) {
      variantsExtensions = variantConfig.extensions; // Do not merge from scope when there is specific variant (which is not *) that match the component
      // if (variantConfig.maxSpecificity > 0) {
      //   mergeFromScope = false;
      // }
    }

    const isVendor = this.isVendorComponentByComponentDir(relativeComponentDir);

    if (!isVendor) {
      wsDefaultExtensions = this.getDefaultExtensions();
    } // We don't stop on each step because we want to merge the default scope even if propagate=false but the default scope is not defined


    const extensionsToMerge = [];

    if (configFileExtensions) {
      extensionsToMerge.push(configFileExtensions);
    }

    let continuePropagating = (_componentConfigFile$ = componentConfigFile === null || componentConfigFile === void 0 ? void 0 : componentConfigFile.propagate) !== null && _componentConfigFile$ !== void 0 ? _componentConfigFile$ : true;

    if (variantsExtensions && continuePropagating) {
      // Put it in the start to make sure the config file is stronger
      extensionsToMerge.push(variantsExtensions);
    }

    continuePropagating = continuePropagating && ((_variantConfig$propag = variantConfig === null || variantConfig === void 0 ? void 0 : variantConfig.propagate) !== null && _variantConfig$propag !== void 0 ? _variantConfig$propag : true); // Do not apply default extensions on the default extensions (it will create infinite loop when loading them)

    const isDefaultExtension = wsDefaultExtensions.findExtension(componentId.toString(), true, true);

    if (wsDefaultExtensions && continuePropagating && !isDefaultExtension) {
      // Put it in the start to make sure the config file is stronger
      extensionsToMerge.push(wsDefaultExtensions);
    } // It's before the scope extensions, since there is no need to resolve extensions from scope they are already resolved
    // await Promise.all(extensionsToMerge.map((extensions) => this.resolveExtensionsList(extensions)));


    if (mergeFromScope && continuePropagating) {
      extensionsToMerge.push(scopeExtensions);
    } // It's important to do this resolution before the merge, otherwise we have issues with extensions
    // coming from scope with local scope name, as opposed to the same extension comes from the workspace with default scope name


    const promises = extensionsToMerge.map(list => this.resolveExtensionListIds(list));
    await Promise.all(promises);

    let mergedExtensions = _extensionData().ExtensionDataList.mergeConfigs(extensionsToMerge).filterRemovedExtensions(); // remove self from merged extensions


    const selfInMergedExtensions = mergedExtensions.findExtension(componentId._legacy.toStringWithoutScopeAndVersion(), true, true);

    if (selfInMergedExtensions && selfInMergedExtensions.extensionId) {
      mergedExtensions = mergedExtensions.remove(selfInMergedExtensions.extensionId);
    }

    return mergedExtensions;
  }
  /**
   * This will mutate the entries with extensionId prop to have resolved legacy id
   * This should be worked on the extension data list not the new aspect list
   * @param extensionList
   */


  async resolveExtensionListIds(extensionList) {
    const promises = extensionList.map(async entry => {
      if (entry.extensionId) {
        const id = await this.resolveComponentId(entry.extensionId);
        entry.extensionId = id._legacy;
      }

      return entry;
    });
    await Promise.all(promises);
    return extensionList;
  }

  isVendorComponentByComponentDir(relativeComponentDir) {
    var _this$config$vendor;

    const vendorDir = ((_this$config$vendor = this.config.vendor) === null || _this$config$vendor === void 0 ? void 0 : _this$config$vendor.directory) || DEFAULT_VENDOR_DIR;

    if ((0, _utils().pathIsInside)(relativeComponentDir, vendorDir)) {
      return true;
    } // TODO: implement


    return false;
  }
  /**
   * return the component config from its folder (component.json)
   * @param componentId
   */


  async componentConfigFile(id) {
    const relativeComponentDir = this.componentDir(id, {
      ignoreVersion: true
    }, {
      relative: true
    });
    return this.componentConfigFileFromComponentDirAndName(relativeComponentDir, id.fullName);
  }

  async componentConfigFileFromComponentDirAndName(relativeComponentDir, name) {
    let componentConfigFile;

    if (relativeComponentDir) {
      const absComponentDir = this.componentDirToAbsolute(relativeComponentDir);
      const defaultScopeFromVariantsOrWs = await this.componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(relativeComponentDir, name);
      componentConfigFile = await _componentConfigFile().ComponentConfigFile.load(absComponentDir, this.createAspectList.bind(this), defaultScopeFromVariantsOrWs);
    }

    return componentConfigFile;
  }

  async getGraphWithoutCore(components) {
    const ids = components.map(component => component.id._legacy);
    const coreAspectsStringIds = this.aspectLoader.getCoreAspectIds();
    const coreAspectsComponentIds = coreAspectsStringIds.map(id => _legacyBitId().BitId.parse(id, true));

    const coreAspectsBitIds = _bitId().BitIds.fromArray(coreAspectsComponentIds.map(id => id.changeScope(null))); // const aspectsIds = components.reduce((acc, curr) => {
    //   const currIds = curr.state.aspects.ids;
    //   acc = acc.concat(currIds);
    //   return acc;
    // }, [] as any);
    // const otherDependenciesMap = components.reduce((acc, curr) => {
    //   // const currIds = curr.state.dependencies.dependencies.map(dep => dep.id.toString());
    //   const currMap = curr.state.dependencies.getIdsMap();
    //   Object.assign(acc, currMap);
    //   return acc;
    // }, {});
    // const depsWhichAreNotAspects = difference(Object.keys(otherDependenciesMap), aspectsIds);
    // const depsWhichAreNotAspectsBitIds = depsWhichAreNotAspects.map((strId) => otherDependenciesMap[strId]);
    // We only want to load into the graph components which are aspects and not regular dependencies
    // This come to solve a circular loop when an env aspect use an aspect (as regular dep) and the aspect use the env aspect as its env
    // TODO: @gilad it causes many issues we need to find a better solution. removed for now.


    const ignoredIds = coreAspectsBitIds.concat([]);
    return (0, _componentsGraph().buildOneGraphForComponents)(ids, this.consumer, undefined, _bitId().BitIds.fromArray(ignoredIds));
  }
  /**
   * load aspects from the workspace and if not exists in the workspace, load from the scope.
   * keep in mind that the graph may have circles.
   */


  async loadAspects(ids = [], throwOnError = false) {
    this.logger.debug(`loading ${ids.length} aspects`);
    const notLoadedIds = ids.filter(id => !this.aspectLoader.isAspectLoaded(id));
    if (!notLoadedIds.length) return;
    const coreAspectsStringIds = this.aspectLoader.getCoreAspectIds();
    const idsWithoutCore = (0, _lodash().difference)(notLoadedIds, coreAspectsStringIds);
    const componentIds = await this.resolveMultipleComponentIds(idsWithoutCore);
    const components = await this.importAndGetAspects(componentIds);
    const graph = await this.getGraphWithoutCore(components);
    const allIdsP = graph.nodes().map(async id => {
      return this.resolveComponentId(id);
    });
    const allIds = await Promise.all(allIdsP);
    const allComponents = await this.getMany(allIds);
    const aspects = allComponents.filter(component => {
      var _component$config$ext;

      let data = (_component$config$ext = component.config.extensions.findExtension(_envs().EnvsAspect.id)) === null || _component$config$ext === void 0 ? void 0 : _component$config$ext.data;

      if (!data) {
        // TODO: remove this once we re-export old components used to store the data here
        data = component.state.aspects.get('teambit.workspace/workspace');
      }

      if (!data) return false;

      if (data.type !== 'aspect' && idsWithoutCore.includes(component.id.toString())) {
        const err = new (_incorrectEnvAspect().IncorrectEnvAspect)(component.id.toString(), data.type, data.id);

        if (data.id === _envs().DEFAULT_ENV) {
          // when cloning a project, or when the node-modules dir is deleted, nothing works and all
          // components are default to the DEFAULT_ENV, which is node-env. we must allow "bit
          // install" to prepare the workspace and let the proper the envs to be loaded
          this.logger.error(err.message);
        } else {
          throw err;
        }
      }

      return data.type === 'aspect';
    }); // no need to filter core aspects as they are not included in the graph
    // here we are trying to load extensions from the workspace.

    const {
      workspaceComps,
      scopeComps
    } = await this.groupComponentsByWorkspaceAndScope(aspects); // load the scope first because we might need it for custom envs that extend external aspects

    const scopeIds = scopeComps.map(aspect => aspect.id.toString());
    await this.scope.loadAspects(scopeIds, throwOnError);
    const workspaceAspects = await this.requireComponents(workspaceComps);
    await this.aspectLoader.loadRequireableExtensions(workspaceAspects, throwOnError);
  }

  async resolveAspects(runtimeName, componentIds) {
    let missingPaths = false;
    const stringIds = [];
    const idsToResolve = componentIds ? componentIds.map(id => id.toString()) : this.harmony.extensionsIds;
    const coreAspectsIds = this.aspectLoader.getCoreAspectIds();
    const userAspectsIds = (0, _lodash().difference)(idsToResolve, coreAspectsIds);
    const componentIdsToResolve = await this.resolveMultipleComponentIds(userAspectsIds);
    const {
      workspaceIds,
      scopeIds
    } = await this.groupIdsByWorkspaceAndScope(componentIdsToResolve);
    const wsComponents = await this.getMany(workspaceIds);
    const aspectDefs = await this.aspectLoader.resolveAspects(wsComponents, async component => {
      stringIds.push(component.id._legacy.toString());
      const localPath = this.getComponentPackagePath(component.state._consumer);
      const isExist = await _fsExtra().default.pathExists(localPath);

      if (!isExist) {
        missingPaths = true;
      }

      return {
        aspectPath: localPath,
        runtimePath: runtimeName ? await this.aspectLoader.getRuntimePath(component, localPath, runtimeName) : null
      };
    });
    let scopeAspectDefs = [];

    if (scopeIds.length) {
      scopeAspectDefs = await this.scope.resolveAspects(runtimeName, scopeIds);
    }

    let coreAspectDefs = await Promise.all(coreAspectsIds.map(async coreId => {
      const rawDef = await (0, _aspectLoader().getAspectDef)(coreId, runtimeName);
      return this.aspectLoader.loadDefinition(rawDef);
    })); // due to lack of workspace and scope runtimes. TODO: fix after adding them.

    if (runtimeName) {
      coreAspectDefs = coreAspectDefs.filter(coreAspect => {
        return coreAspect.runtimePath;
      });
    }

    if (missingPaths) {
      await (0, _consumer().link)(stringIds, false);
    }

    const allDefs = aspectDefs.concat(coreAspectDefs).concat(scopeAspectDefs);
    const uniqDefs = (0, _lodash().uniqBy)(allDefs, def => `${def.aspectPath}-${def.runtimePath}`);
    let defs = uniqDefs;

    if (runtimeName) {
      defs = defs.filter(def => def.runtimePath);
    }

    return defs;
  }

  async groupIdsByWorkspaceAndScope(ids) {
    const workspaceIds = [];
    const scopeIds = [];
    await Promise.all(ids.map(async id => {
      const existOnWorkspace = await this.hasId(id);
      existOnWorkspace ? workspaceIds.push(id) : scopeIds.push(id);
    }));
    return {
      workspaceIds,
      scopeIds
    };
  }

  async groupComponentsByWorkspaceAndScope(components) {
    const workspaceComps = [];
    const scopeComps = [];
    await Promise.all(components.map(async component => {
      const existOnWorkspace = await this.hasId(component.id);
      existOnWorkspace ? workspaceComps.push(component) : scopeComps.push(component);
    }));
    return {
      workspaceComps,
      scopeComps
    };
  }
  /**
   * Load all unloaded extensions from a list
   * @param extensions list of extensions with config to load
   */


  async loadExtensions(extensions, throwOnError = false) {
    const extensionsIdsP = extensions.map(async extensionEntry => {
      // Core extension
      if (!extensionEntry.extensionId) {
        return extensionEntry.stringId;
      }

      const id = await this.resolveComponentId(extensionEntry.extensionId); // return this.resolveComponentId(extensionEntry.extensionId);

      return id.toString();
    });
    const extensionsIds = await Promise.all(extensionsIdsP);
    const loadedExtensions = this.harmony.extensionsIds;
    const extensionsToLoad = (0, _lodash().difference)(extensionsIds, loadedExtensions);
    if (!extensionsToLoad.length) return;
    await this.loadAspects(extensionsToLoad, throwOnError);
  }
  /**
   * Provides a cache folder, unique per key.
   * Return value may be undefined, if workspace folder is unconventional (bare-scope, no node_modules, etc)
   */


  getTempDir(
  /*
   * unique key, i.e. aspect or component id
   */
  id) {
    const PREFIX = 'bit';

    const cacheDir = _path().default.join(this.modulesPath, '.cache', PREFIX, id); // maybe should also check it's a folder and has write permissions


    if (!_fsExtra().default.existsSync(cacheDir)) {
      _fsExtra().default.mkdirSync(cacheDir, {
        recursive: true
      });
    }

    return cacheDir;
  }

  async requireComponents(components) {
    let missingPaths = false;
    const stringIds = [];
    const resolveP = components.map(async component => {
      stringIds.push(component.id._legacy.toString());
      const localPath = this.getComponentPackagePath(component);
      const isExist = await _fsExtra().default.pathExists(localPath);

      if (!isExist) {
        missingPaths = true;
      }

      const requireFunc = async () => {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        const aspect = require(localPath); // require aspect runtimes


        const runtimePath = await this.aspectLoader.getRuntimePath(component, localPath, _cli().MainRuntime.name); // eslint-disable-next-line global-require, import/no-dynamic-require

        if (runtimePath) require(runtimePath);
        return aspect;
      };

      return new (_harmonyModules().RequireableComponent)(component, requireFunc);
    });
    const resolved = await Promise.all(resolveP); // Make sure to link missing components

    if (missingPaths) {
      await (0, _consumer().link)(stringIds, false);
    }

    return resolved;
  }

  async getComponentsDirectory(ids) {
    const components = ids.length ? await this.getMany(ids) : await this.list();
    return _component().ComponentMap.as(components, component => this.componentDir(component.id));
  }
  /**
   * Install dependencies for all components in the workspace
   *
   * @returns
   * @memberof Workspace
   */


  async install(packages, options) {
    var _options$copyPeerToRu, _options$copyPeerToRu2;

    if (packages && packages.length) {
      if (!(options !== null && options !== void 0 && options.variants) && (options === null || options === void 0 ? void 0 : options.lifecycleType) === 'dev') {
        throw new (_exceptions3().DependencyTypeNotSupportedInPolicy)(options === null || options === void 0 ? void 0 : options.lifecycleType);
      }

      this.logger.debug(`installing the following packages: ${packages.join()}`);
      const resolver = this.dependencyResolver.getVersionResolver();
      const resolvedPackagesP = packages.map(packageName => resolver.resolveRemoteVersion(packageName, {
        rootDir: this.path
      }));
      const resolvedPackages = await Promise.all(resolvedPackagesP);
      const newWorkspacePolicyEntries = [];
      resolvedPackages.forEach(resolvedPackage => {
        if (resolvedPackage.version) {
          const versionWithPrefix = this.dependencyResolver.getVersionWithSavePrefix(resolvedPackage.version, options === null || options === void 0 ? void 0 : options.savePrefix);
          newWorkspacePolicyEntries.push({
            dependencyId: resolvedPackage.packageName,
            value: {
              version: versionWithPrefix
            },
            lifecycleType: (options === null || options === void 0 ? void 0 : options.lifecycleType) || 'runtime'
          });
        }
      });

      if (!(options !== null && options !== void 0 && options.variants)) {
        var _options$updateExisti;

        this.dependencyResolver.addToRootPolicy(newWorkspacePolicyEntries, {
          updateExisting: (_options$updateExisti = options === null || options === void 0 ? void 0 : options.updateExisting) !== null && _options$updateExisti !== void 0 ? _options$updateExisti : false
        });
      } else {// TODO: implement
      }

      await this.dependencyResolver.persistConfig(this.path);
    }

    if (options !== null && options !== void 0 && options.import) {
      this.logger.setStatusLine('importing missing objects');
      await this.importObjects();
      this.logger.consoleSuccess();
    }

    this.logger.console(`installing dependencies in workspace using ${_chalk().default.cyan(this.dependencyResolver.getPackageManagerName())}`);
    this.logger.debug(`installing dependencies in workspace with options`, options);
    this.clearCache(); // TODO: pass get install options

    const installer = this.dependencyResolver.getInstaller({});
    const compDirMap = await this.getComponentsDirectory([]);
    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();
    const depsFilterFn = await this.generateFilterFnForDepsFromLocalRemote();
    const pmInstallOptions = {
      dedupe: options === null || options === void 0 ? void 0 : options.dedupe,
      copyPeerToRuntimeOnRoot: (_options$copyPeerToRu = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnRoot) !== null && _options$copyPeerToRu !== void 0 ? _options$copyPeerToRu : true,
      copyPeerToRuntimeOnComponents: (_options$copyPeerToRu2 = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnComponents) !== null && _options$copyPeerToRu2 !== void 0 ? _options$copyPeerToRu2 : false,
      dependencyFilterFn: depsFilterFn
    };
    await installer.install(this.path, mergedRootPolicy, compDirMap, {
      installTeambitBit: false
    }, pmInstallOptions); // TODO: this make duplicate
    // this.logger.consoleSuccess();
    // TODO: add the links results to the output

    await this.link({
      linkTeambitBit: true,
      legacyLink: true,
      linkCoreAspects: true,
      linkNestedDepsInNM: !this.isLegacy
    });
    await this.consumer.componentFsCache.deleteAllDependenciesDataCache();
    return compDirMap;
  }

  async link(options) {
    const compDirMap = await this.getComponentsDirectory([]);
    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();
    const linker = this.dependencyResolver.getLinker({
      rootDir: this.path,
      linkingOptions: options
    });
    const res = await linker.link(this.path, mergedRootPolicy, compDirMap, options);
    return res;
  }
  /**
   * Generate a filter to pass to the installer
   * This will filter deps which are come from remotes which defined in scope.json
   * those components comes from local remotes, usually doesn't have a package in a registry
   * so no reason to try to install them (it will fail)
   */


  async generateFilterFnForDepsFromLocalRemote() {
    // TODO: once scope create a new API for this, replace it with the new one
    const remotes = await this.scope._legacyRemotes();
    return dependencyList => {
      const filtered = dependencyList.filter(dep => {
        if (!(dep instanceof _dependencyResolver().ComponentDependency)) {
          return true;
        }

        if (remotes.isHub(dep.componentId.scope)) {
          return true;
        }

        return false;
      });
      return filtered;
    };
  }
  /**
   * same as `this.importAndGetMany()` with a specific error handling of ComponentNotFound
   */


  async importAndGetAspects(componentIds) {
    try {
      return await this.importAndGetMany(componentIds);
    } catch (err) {
      if (err instanceof _exceptions2().ComponentNotFound) {
        var _config$workspaceConf;

        const config = this.harmony.get('teambit.harmony/config');
        const configStr = JSON.stringify(((_config$workspaceConf = config.workspaceConfig) === null || _config$workspaceConf === void 0 ? void 0 : _config$workspaceConf.raw) || {});

        if (configStr.includes(err.id)) {
          throw new (_bitError().BitError)(`error: a component "${err.id}" was not found
your workspace.jsonc has this component-id set. you might want to remove/change it.`);
        }
      }

      throw err;
    }
  } // TODO: replace with a proper import API on the workspace


  async importObjects() {
    const importOptions = {
      ids: [],
      verbose: false,
      merge: false,
      objectsOnly: true,
      withEnvironments: false,
      override: false,
      writeDists: false,
      writeConfig: false,
      installNpmPackages: false,
      writePackageJson: false,
      importDependenciesDirectly: false,
      importDependents: false
    };

    try {
      const res = await (0, _consumer().importAction)({
        tester: false,
        compiler: false
      }, importOptions, []);
      return res;
    } catch (err) {
      // TODO: this is a hack since the legacy throw an error, we should provide a way to not throw this error from the legacy
      if (err instanceof _exceptions().NothingToImport) {
        // Do not write nothing to import warning
        return undefined;
      }

      throw err;
    }
  }
  /**
   * this should be rarely in-use.
   * it's currently used by watch extension as a quick workaround to load .bitmap and the components
   */


  async _reloadConsumer() {
    this.consumer = await (0, _consumer2().loadConsumer)(this.path, true);
    this.clearCache();
  }

  getComponentPackagePath(component) {
    const packageName = (0, _componentIdToPackageName().default)(component instanceof _component2().default ? component : component.state._consumer);
    return _path().default.join(this.modulesPath, packageName);
  } // TODO: should we return here the dir as it defined (aka components) or with /{name} prefix (as it used in legacy)


  get defaultDirectory() {
    return this.config.defaultDirectory;
  }

  get legacyDefaultDirectory() {
    if (this.defaultDirectory && !this.defaultDirectory.includes('{name}')) {
      return `${this.defaultDirectory}/{name}`;
    }

    return this.defaultDirectory;
  }
  /**
   * Transform the id to ComponentId and get the exact id as appear in bitmap
   *
   * @param {(string | ComponentID | BitId)} id
   * @returns {Promise<ComponentID>}
   * @memberof Workspace
   */


  async resolveComponentId(id) {
    // This is required in case where you have in your workspace a component with the same name as a core aspect
    // let's say you have component called react-native (which is eventually my-org.my-scope/react-native)
    // and you set teambit.react/react-native as your env
    // bit will get here with the string teambit.react/react-native and will try to resolve it from the workspace
    // during this it will find the my-org.my-scope/react-native which is incorrect as the core one doesn't exist in the
    // workspace
    if (this.aspectLoader.isCoreAspect(id.toString())) {
      return _component().ComponentID.fromString(id.toString());
    }

    let legacyId = this.consumer.getParsedIdIfExist(id.toString(), true, true);

    if (!legacyId) {
      try {
        const idWithVersion = id.toString();
        const [idWithoutVersion, version] = id.toString().split('@');

        const _bitMapId = this.consumer.getParsedIdIfExist(idWithoutVersion, false, true); // This logic is very specific, and very sensitive for changes please do not touch this without consulting with @ran or @gilad
        // example (partial list) cases which should be handled are:
        // use case 1 - ws component provided with the local scope name:
        // source id        : my-scope1/my-name1
        // bitmap res (_id) : my-name1 (comp is tagged but not exported)
        // local scope name : my-scope1
        // scope content    : my-name1
        // expected result  : my-name1
        // use case 2 - component with same name exist in ws and scope (but with different scope name)
        // source id        : my-scope2/my-name1
        // bitmap res (_id) : my-name1 (comp exist in ws but it's actually different component)
        // local scope name : my-scope1
        // scope content    : my-scope2/my-name1
        // expected result  : my-scope2/my-name1
        // use case 3 - component with same name exist in ws and scope (but with different scope name) - source provided without scope name
        // source id        : my-name1
        // bitmap res (_id) : my-name1 (comp exist in ws but it's actually different component)
        // local scope name : my-scope1
        // scope content    : my-scope1/my-name1 and my-scope2/my-name1
        // expected result  : my-name1 (get the name from the bitmap)
        // use case 4 - component with the same name and different scope are imported into the ws
        // source id        : my-name1
        // bitmap res (_id) : my-scope2/my-name1 (comp exist in ws from different scope (imported))
        // local scope name : my-scope1
        // scope content    : my-scope2/my-name1
        // expected result  : my-scope2/my-name1 (get the name from the bitmap)
        // No entry in bitmap at all, search for the original input id


        if (!_bitMapId) {
          return await this.scope.resolveComponentId(id.toString());
        }

        const _bitMapIdWithoutVersion = _bitMapId.toStringWithoutVersion();

        const _bitMapIdWithVersion = _bitMapId.changeVersion(version).toString(); // The id in the bitmap has prefix which is not in the source id - the bitmap entry has scope name
        // Handle use case 4


        if (_bitMapIdWithoutVersion.endsWith(idWithoutVersion) && _bitMapIdWithoutVersion !== idWithoutVersion) {
          return await this.scope.resolveComponentId(_bitMapIdWithVersion);
        } // The id in the bitmap doesn't have scope, the source id has scope
        // Handle use case 2 and use case 1


        if (idWithoutVersion.endsWith(_bitMapIdWithoutVersion) && _bitMapIdWithoutVersion !== idWithoutVersion) {
          if (id.toString().startsWith(this.scope.name)) {
            // Handle use case 1 - the provided id has scope name same as the local scope name
            // we want to send it as it appear in the bitmap
            return await this.scope.resolveComponentId(_bitMapIdWithVersion);
          } // Handle use case 2 - the provided id has scope which is not the local scope
          // we want to search by the source id


          return await this.scope.resolveComponentId(idWithVersion);
        } // Handle use case 3


        return await this.scope.resolveComponentId(idWithVersion);
      } catch (error) {
        legacyId = _legacyBitId().BitId.parse(id.toString(), true);
        return _component().ComponentID.fromLegacy(legacyId);
      }
    }

    const relativeComponentDir = this.componentDirFromLegacyId(legacyId, undefined, {
      relative: true
    });
    const defaultScope = await this.componentDefaultScopeFromComponentDirAndName(relativeComponentDir, legacyId.toStringWithoutScopeAndVersion());
    return _component().ComponentID.fromLegacy(legacyId, defaultScope);
  }

  async resolveMultipleComponentIds(ids) {
    return Promise.all(ids.map(async id => this.resolveComponentId(id)));
  }
  /**
   * This will mutate the original extensions list and resolve it's ids
   *
   * @param {ExtensionDataList} extensions
   * @returns {Promise<void[]>}
   * @memberof Workspace
   */


  resolveExtensionsList(extensions) {
    const resolveMergedExtensionsP = extensions.map(async extensionEntry => {
      if (extensionEntry.extensionId) {
        // const hasVersion = extensionEntry.extensionId.hasVersion();
        // const useBitmapVersion = !hasVersion;
        // const resolvedId = await this.resolveComponentId(extensionEntry.extensionId, true, useBitmapVersion);
        // Assuming extensionId always has scope - do not allow extension id without scope
        const resolvedId = await this.resolveComponentId(extensionEntry.extensionId);
        extensionEntry.extensionId = resolvedId._legacy;
      }
    });
    return Promise.all(resolveMergedExtensionsP);
  }
  /**
   * This will mutate the original extensions list and make sure all extensions has the ids with the scope / default scope
   *
   * @param {ExtensionDataList} extensions
   * @returns {Promise<void[]>}
   * @memberof Workspace
   */


  addDefaultScopeToExtensionsList(extensions) {
    const resolveMergedExtensionsP = extensions.map(async extensionEntry => {
      if (extensionEntry.extensionId && !extensionEntry.extensionId.hasScope()) {
        const componentId = _component().ComponentID.fromLegacy(extensionEntry.extensionId);

        const defaultScope = await this.componentDefaultScope(componentId);
        extensionEntry.extensionId = extensionEntry.extensionId.changeScope(defaultScope);
      }
    });
    return Promise.all(resolveMergedExtensionsP);
  }

}

exports.Workspace = Workspace;
var _default = Workspace;
exports.default = _default;

//# sourceMappingURL=workspace.js.map