{"version":3,"sources":["workspace.ts"],"names":["ComponentAdded","ComponentChanged","ComponentRemoved","DEFAULT_VENDOR_DIR","Workspace","constructor","pubsub","config","consumer","scope","componentAspect","isolator","dependencyResolver","variants","aspectLoader","logger","componentList","ComponentsList","harmony","onComponentLoadSlot","onComponentChangeSlot","envs","onComponentAddSlot","onComponentRemoveSlot","graphql","Watcher","owner","defaultOwner","componentLoader","WorkspaceComponentLoader","validateConfig","defaultScope","isLegacy","Error","InvalidScopeName","path","getPath","modulesPath","join","onComponentLoad","loadFn","register","registerOnComponentChange","onComponentChangeFunc","registerOnComponentAdd","onComponentAddFunc","registerOnComponentRemove","onComponentRemoveFunc","name","tokenizedPath","split","length","icon","hasModifiedDependencies","component","componentsList","listAutoTagPendingComponents","isAutoTag","find","consumerComponent","id","isEqualWithoutVersion","_legacy","getComponentIssues","state","_consumer","issues","getComponentStatus","status","getComponentStatusById","ComponentStatus","fromLegacy","isOutdated","list","filter","legacyIds","bitMap","getAllIdsAvailableOnLane","ids","resolveMultipleComponentIds","getMany","limit","offset","listInvalid","getInvalid","listIds","bitmapIdsFromCurrentLane","hasId","componentId","found","isEqual","hasName","Boolean","fullName","hasIdNested","includeCache","modified","listModifiedComponents","componentIds","map","ComponentID","newComponents","listNewComponents","getAllComponentIds","bitIds","getAuthoredAndImportedBitIds","getNewAndModifiedIds","listTagPendingComponents","getLogs","getLegacyGraph","legacyGraph","loadCapsules","components","load","comp","capsule","network","isolateComponents","c","resolvedComponents","graphCapsules","getCapsule","toString","ResolvedComponent","createAspectList","extensionDataList","entiresP","entry","AspectEntry","resolveComponentId","entries","Promise","all","createAspectListFromEntries","get","forCapsule","legacyComponent","useCache","storeInCache","debug","getEnvSystemDescriptor","env","calculateEnv","__getDescriptor","systemDescriptor","services","isEnvRegistered","getServices","getDescriptor","type","description","toObject","clearCache","clearComponentCache","clearOneComponentCache","triggerOnComponentChange","writeBitMap","onChangeEntries","toArray","results","extension","onChangeFunc","onChangeResult","push","extensionId","publish","componentChanged","triggerOnComponentAdd","onAddEntries","onAddFunc","onAddResult","componentAdded","triggerOnComponentRemove","onRemoveEntries","onRemoveFunc","onRemoveResult","componentRemoved","getState","hash","getSnap","getCurrentLaneId","getDefaultExtensions","extensions","ExtensionDataList","fromConfigObject","ejectConfig","options","aspects","resolveScopeAspectListIds","componentDir","ignoreVersion","componentConfigFile","ComponentConfigFile","propagate","write","override","configPath","composePath","aspectListFromScope","resolvedList","pmap","newId","newEntry","legacy","byPattern","pattern","finalPattern","targetIds","spec","toStringWithoutVersion","match","getManyByLegacy","undefined","importAndGetMany","import","add","componentPaths","main","addComponent","AddComponents","addResults","componentFsCache","track","trackData","rootDir","componentName","mainFile","result","addedComponent","addedComponents","files","f","relativePath","warnings","rootPath","filesystem","file","pathToWrite","fs","outputFile","contents","bitMapOptions","relative","componentDirFromLegacyId","bitId","componentMap","getComponent","relativeComponentDir","getComponentDir","NoComponentDir","componentDirToAbsolute","componentDefaultScope","componentDefaultScopeFromComponentDirAndName","componentConfigFileFromComponentDirAndName","componentDefaultScopeFromComponentDirAndNameWithoutConfigFile","variantConfig","byRootDirAndName","isVendor","isVendorComponentByComponentDir","componentExtensions","componentFromScope","configFileExtensions","variantsExtensions","wsDefaultExtensions","mergeFromScope","scopeExtensions","toLegacy","extensionsToMerge","continuePropagating","isDefaultExtension","findExtension","promises","resolveExtensionListIds","mergedExtensions","mergeConfigs","filterRemovedExtensions","selfInMergedExtensions","toStringWithoutScopeAndVersion","remove","extensionList","vendorDir","vendor","directory","absComponentDir","defaultScopeFromVariantsOrWs","bind","getGraphWithoutCore","coreAspectsStringIds","getCoreAspectIds","coreAspectsComponentIds","BitId","parse","coreAspectsBitIds","BitIds","fromArray","changeScope","ignoredIds","concat","loadAspects","throwOnError","notLoadedIds","isAspectLoaded","idsWithoutCore","importAndGetAspects","graph","allIdsP","nodes","allIds","allComponents","data","EnvsAspect","includes","err","IncorrectEnvAspect","DEFAULT_ENV","error","message","workspaceComps","scopeComps","groupComponentsByWorkspaceAndScope","scopeIds","aspect","workspaceAspects","requireComponents","loadRequireableExtensions","resolveAspects","runtimeName","missingPaths","stringIds","idsToResolve","extensionsIds","coreAspectsIds","userAspectsIds","componentIdsToResolve","workspaceIds","groupIdsByWorkspaceAndScope","wsComponents","aspectDefs","localPath","getComponentPackagePath","isExist","pathExists","aspectPath","runtimePath","getRuntimePath","scopeAspectDefs","coreAspectDefs","coreId","rawDef","loadDefinition","coreAspect","allDefs","uniqDefs","def","defs","existOnWorkspace","loadExtensions","extensionsIdsP","extensionEntry","stringId","loadedExtensions","extensionsToLoad","getTempDir","PREFIX","cacheDir","existsSync","mkdirSync","recursive","resolveP","requireFunc","require","MainRuntime","RequireableComponent","resolved","getComponentsDirectory","ComponentMap","as","install","packages","lifecycleType","DependencyTypeNotSupportedInPolicy","resolver","getVersionResolver","resolvedPackagesP","packageName","resolveRemoteVersion","resolvedPackages","newWorkspacePolicyEntries","forEach","resolvedPackage","version","versionWithPrefix","getVersionWithSavePrefix","savePrefix","dependencyId","value","addToRootPolicy","updateExisting","persistConfig","setStatusLine","importObjects","consoleSuccess","console","chalk","cyan","getPackageManagerName","installer","getInstaller","compDirMap","mergedRootPolicy","getWorkspacePolicy","depsFilterFn","generateFilterFnForDepsFromLocalRemote","pmInstallOptions","dedupe","copyPeerToRuntimeOnRoot","copyPeerToRuntimeOnComponents","dependencyFilterFn","installTeambitBit","link","linkTeambitBit","legacyLink","linkCoreAspects","linkNestedDepsInNM","deleteAllDependenciesDataCache","linker","getLinker","linkingOptions","res","remotes","_legacyRemotes","dependencyList","filtered","dep","ComponentDependency","isHub","ComponentNotFound","configStr","JSON","stringify","workspaceConfig","raw","BitError","importOptions","verbose","merge","objectsOnly","withEnvironments","writeDists","writeConfig","installNpmPackages","writePackageJson","importDependenciesDirectly","importDependents","tester","compiler","NothingToImport","_reloadConsumer","ConsumerComponent","defaultDirectory","legacyDefaultDirectory","isCoreAspect","fromString","legacyId","getParsedIdIfExist","idWithVersion","idWithoutVersion","_bitMapId","_bitMapIdWithoutVersion","_bitMapIdWithVersion","changeVersion","endsWith","startsWith","resolveExtensionsList","resolveMergedExtensionsP","resolvedId","addDefaultScopeToExtensionsList","hasScope"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAYA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAUA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAUA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMO,MAAMA,cAAc,GAAG,gBAAvB;;AACA,MAAMC,gBAAgB,GAAG,kBAAzB;;AACA,MAAMC,gBAAgB,GAAG,kBAAzB;;AA4BP,MAAMC,kBAAkB,GAAG,QAA3B;AAEA;AACA;AACA;;AACO,MAAMC,SAAN,CAA4C;AAKjDC,EAAAA,WAAW;AACT;AACJ;AACA;AACYC,EAAAA,MAJC,EAMDC,MANC;AAOT;AACJ;AACA;AACWC,EAAAA,QAVE;AAYT;AACJ;AACA;AACaC,EAAAA,KAfA;AAiBT;AACJ;AACA;AACYC,EAAAA,eApBC,EAsBDC,QAtBC,EAwBDC,kBAxBC,EA0BDC,QA1BC,EA4BDC,YA5BC,EA8BDC,MA9BC,EAgCDC,aAA6B,GAAG,KAAIC,yBAAJ,EAAmBT,QAAnB,CAhC/B;AAkCT;AACJ;AACA;AACYU,EAAAA,OArCC;AAuCT;AACJ;AACA;AACWC,EAAAA,mBA1CE;AA4CT;AACJ;AACA;AACYC,EAAAA,qBA/CC,EAiDDC,IAjDC;AAmDT;AACJ;AACA;AACYC,EAAAA,kBAtDC,EAwDDC,qBAxDC,EA0DDC,OA1DC,EA2DT;AAAA;;AAAA,SAvDQlB,MAuDR,GAvDQA,MAuDR;AAAA,SArDQC,MAqDR,GArDQA,MAqDR;AAAA,SAjDOC,QAiDP,GAjDOA,QAiDP;AAAA,SA5CSC,KA4CT,GA5CSA,KA4CT;AAAA,SAvCQC,eAuCR,GAvCQA,eAuCR;AAAA,SArCQC,QAqCR,GArCQA,QAqCR;AAAA,SAnCQC,kBAmCR,GAnCQA,kBAmCR;AAAA,SAjCQC,QAiCR,GAjCQA,QAiCR;AAAA,SA/BQC,YA+BR,GA/BQA,YA+BR;AAAA,SA7BQC,MA6BR,GA7BQA,MA6BR;AAAA,SA3BQC,aA2BR,GA3BQA,aA2BR;AAAA,SAtBQE,OAsBR,GAtBQA,OAsBR;AAAA,SAjBOC,mBAiBP,GAjBOA,mBAiBP;AAAA,SAZQC,qBAYR,GAZQA,qBAYR;AAAA,SAVQC,IAUR,GAVQA,IAUR;AAAA,SALQC,kBAKR,GALQA,kBAKR;AAAA,SAHQC,qBAGR,GAHQA,qBAGR;AAAA,SADQC,OACR,GADQA,OACR;AAAA,sDA/DS,IA+DT;AAAA;AAAA;AAAA;AAAA,qDAiBiB,KAAIC,kBAAJ,EAAY,IAAZ,EAAkB,KAAKnB,MAAvB,CAjBjB;AACA;AACA,SAAKoB,KAAL,mBAAa,KAAKnB,MAAlB,iDAAa,aAAaoB,YAA1B;AACA,SAAKC,eAAL,GAAuB,KAAIC,oDAAJ,EAA6B,IAA7B,EAAmCd,MAAnC,EAA2CH,kBAA3C,EAA+DS,IAA/D,CAAvB;AACA,SAAKS,cAAL;AACD;;AAEOA,EAAAA,cAAc,GAAG;AACvB,UAAMC,YAAY,GAAG,KAAKxB,MAAL,CAAYwB,YAAjC;AACA,QAAI,KAAKvB,QAAL,CAAcwB,QAAlB,EAA4B;AAC5B,QAAI,CAACD,YAAL,EAAmB,MAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACnB,QAAI,CAAC,qCAAiBF,YAAjB,CAAL,EAAqC,MAAM,KAAIG,+BAAJ,EAAqBH,YAArB,CAAN;AACtC;AAED;AACF;AACA;;;AAGE;AACF;AACA;AACU,MAAJI,IAAI,GAAG;AACT,WAAO,KAAK3B,QAAL,CAAc4B,OAAd,EAAP;AACD;AAED;;;AACuB,MAAXC,WAAW,GAAG;AACxB,WAAOF,gBAAKG,IAAL,CAAU,KAAKH,IAAf,EAAqB,cAArB,CAAP;AACD;;AAEW,MAARH,QAAQ,GAAY;AACtB,WAAO,KAAKxB,QAAL,CAAcwB,QAArB;AACD;;AAEDO,EAAAA,eAAe,CAACC,MAAD,EAA0B;AACvC,SAAKrB,mBAAL,CAAyBsB,QAAzB,CAAkCD,MAAlC;AACA,WAAO,IAAP;AACD;;AAEDE,EAAAA,yBAAyB,CAACC,qBAAD,EAA2C;AAClE,SAAKvB,qBAAL,CAA2BqB,QAA3B,CAAoCE,qBAApC;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,sBAAsB,CAACC,kBAAD,EAAqC;AACzD,SAAKvB,kBAAL,CAAwBmB,QAAxB,CAAiCI,kBAAjC;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,yBAAyB,CAACC,qBAAD,EAA2C;AAClE,SAAKxB,qBAAL,CAA2BkB,QAA3B,CAAoCM,qBAApC;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACU,MAAJC,IAAI,GAAG;AACT,QAAI,KAAKzC,MAAL,CAAYyC,IAAhB,EAAsB,OAAO,KAAKzC,MAAL,CAAYyC,IAAnB;AACtB,UAAMC,aAAa,GAAG,KAAKd,IAAL,CAAUe,KAAV,CAAgB,GAAhB,CAAtB;AACA,WAAOD,aAAa,CAACA,aAAa,CAACE,MAAd,GAAuB,CAAxB,CAApB;AACD;;AAEO,MAAJC,IAAI,GAAG;AACT,WAAO,KAAK7C,MAAL,CAAY6C,IAAnB;AACD;;AAE4B,QAAvBC,uBAAuB,CAACC,SAAD,EAAuB;AAClD,UAAMC,cAAc,GAAG,KAAItC,yBAAJ,EAAmB,KAAKT,QAAxB,CAAvB;AACA,UAAMgD,4BAA4B,GAAG,MAAMD,cAAc,CAACC,4BAAf,EAA3C;AACA,UAAMC,SAAS,GAAGD,4BAA4B,CAACE,IAA7B,CAAmCC,iBAAD,IAClDA,iBAAiB,CAACC,EAAlB,CAAqBC,qBAArB,CAA2CP,SAAS,CAACM,EAAV,CAAaE,OAAxD,CADgB,CAAlB;AAGA,QAAIL,SAAJ,EAAe,OAAO,IAAP;AACf,WAAO,KAAP;AACD;AAED;AACF;AACA;;;AACEM,EAAAA,kBAAkB,CAACT,SAAD,EAA0C;AAC1D,WAAOA,SAAS,CAACU,KAAV,CAAgBC,SAAhB,CAA0BC,MAA1B,IAAoC,IAA3C;AACD;AAED;AACF;AACA;;;AAC0B,QAAlBC,kBAAkB,CAACb,SAAD,EAAiD;AACvE,UAAMc,MAAM,GAAG,MAAM,KAAK5D,QAAL,CAAc6D,sBAAd,CAAqCf,SAAS,CAACM,EAAV,CAAaE,OAAlD,CAArB;AACA,UAAMT,uBAAuB,GAAG,MAAM,KAAKA,uBAAL,CAA6BC,SAA7B,CAAtC;AACA,WAAOgB,mCAAgBC,UAAhB,CAA2BH,MAA3B,EAAmCf,uBAAnC,EAA4DC,SAAS,CAACkB,UAAV,EAA5D,CAAP;AACD;AAED;AACF;AACA;;;AACY,QAAJC,IAAI,CAACC,MAAD,EAAmE;AAC3E,UAAMC,SAAS,GAAG,KAAKnE,QAAL,CAAcoE,MAAd,CAAqBC,wBAArB,EAAlB;AACA,UAAMC,GAAG,GAAG,MAAM,KAAKC,2BAAL,CAAiCJ,SAAjC,CAAlB;AACA,WAAO,KAAKK,OAAL,CAAaN,MAAM,IAAIA,MAAM,CAACO,KAAjB,GAAyB,qBAAMH,GAAN,EAAWJ,MAAM,CAACQ,MAAlB,EAA0BR,MAAM,CAACQ,MAAP,GAAgBR,MAAM,CAACO,KAAjD,CAAzB,GAAmFH,GAAhG,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACmB,QAAXK,WAAW,GAAgC;AAC/C,UAAMR,SAAS,GAAG,KAAKnE,QAAL,CAAcoE,MAAd,CAAqBC,wBAArB,EAAlB;AACA,UAAMC,GAAG,GAAG,MAAM,KAAKC,2BAAL,CAAiCJ,SAAjC,CAAlB;AACA,WAAO,KAAK/C,eAAL,CAAqBwD,UAArB,CAAgCN,GAAhC,CAAP;AACD;AAED;AACF;AACA;;;AACe,QAAPO,OAAO,GAA2B;AACtC,WAAO,KAAKN,2BAAL,CAAiC,KAAKvE,QAAL,CAAc8E,wBAA/C,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACa,QAALC,KAAK,CAACC,WAAD,EAA6C;AACtD,UAAMV,GAAG,GAAG,MAAM,KAAKO,OAAL,EAAlB;AACA,UAAMI,KAAK,GAAGX,GAAG,CAACpB,IAAJ,CAAUE,EAAD,IAAQ;AAC7B,aAAOA,EAAE,CAAC8B,OAAH,CAAWF,WAAX,CAAP;AACD,KAFa,CAAd;AAGA,WAAO,CAAC,CAACC,KAAT;AACD;AAED;AACF;AACA;;;AACe,QAAPE,OAAO,CAAC3C,IAAD,EAAiC;AAC5C,UAAM8B,GAAG,GAAG,MAAM,KAAKO,OAAL,EAAlB;AACA,WAAOO,OAAO,CAACd,GAAG,CAACpB,IAAJ,CAAUE,EAAD,IAAQA,EAAE,CAACiC,QAAH,KAAgB7C,IAAjC,CAAD,CAAd;AACD;AAED;AACF;AACA;AACA;;;AACmB,QAAX8C,WAAW,CAACN,WAAD,EAA2BO,YAAY,GAAG,IAA1C,EAAkE;AACjF,UAAMN,KAAK,GAAG,MAAM,KAAKF,KAAL,CAAWC,WAAX,CAApB;AACA,QAAIC,KAAJ,EAAW,OAAOA,KAAP;AACX,WAAO,KAAKhF,KAAL,CAAWqF,WAAX,CAAuBN,WAAvB,EAAoCO,YAApC,CAAP;AACD;AAED;AACF;AACA;;;AACgB,QAARC,QAAQ,GAAG;AACf,UAAMlB,GAAQ,GAAG,MAAM,KAAK9D,aAAL,CAAmBiF,sBAAnB,CAA0C,KAA1C,CAAvB;AACA,UAAMC,YAAY,GAAGpB,GAAG,CAACqB,GAAJ,CAAQC,yBAAY7B,UAApB,CAArB;AACA,WAAO,KAAKS,OAAL,CAAakB,YAAb,CAAP;AACD;AAED;AACF;AACA;;;AACqB,QAAbG,aAAa,GAAG;AACpB,UAAMvB,GAAQ,GAAG,MAAM,KAAK9D,aAAL,CAAmBsF,iBAAnB,CAAqC,KAArC,CAAvB;AACA,UAAMJ,YAAY,GAAGpB,GAAG,CAACqB,GAAJ,CAAQC,yBAAY7B,UAApB,CAArB;AACA,WAAO,KAAKS,OAAL,CAAakB,YAAb,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEK,EAAAA,kBAAkB,GAA2B;AAC3C,UAAMC,MAAM,GAAG,KAAKhG,QAAL,CAAcoE,MAAd,CAAqB6B,4BAArB,EAAf;AACA,WAAO,KAAK1B,2BAAL,CAAiCyB,MAAjC,CAAP;AACD;;AAEyB,QAApBE,oBAAoB,GAA2B;AACnD,UAAM5B,GAAG,GAAG,MAAM,KAAK9D,aAAL,CAAmB2F,wBAAnB,EAAlB;AACA,WAAO,KAAK5B,2BAAL,CAAiCD,GAAjC,CAAP;AACD;;AAEY,QAAP8B,OAAO,CAAChD,EAAD,EAA2C;AACtD,WAAO,KAAKnD,KAAL,CAAWmG,OAAX,CAAmBhD,EAAnB,CAAP;AACD;;AAEmB,QAAdiD,cAAc,CAAC/B,GAAD,EAA4C;AAC9D,QAAI,CAACA,GAAD,IAAQA,GAAG,CAAC3B,MAAJ,GAAa,CAAzB,EAA4B2B,GAAG,GAAG,MAAM,KAAKO,OAAL,EAAZ;AAE5B,UAAMV,SAAS,GAAGG,GAAG,CAACqB,GAAJ,CAASvC,EAAD,IAAQA,EAAE,CAACE,OAAnB,CAAlB;AAEA,UAAMgD,WAAW,GAAG,MAAM,mDAA2BnC,SAA3B,EAAsC,KAAKnE,QAA3C,CAA1B;AACA,WAAOsG,WAAP;AACD;;AAEiB,QAAZC,YAAY,CAACP,MAAD,EAAmB;AACnC;AACA,UAAMQ,UAAU,GAAG,MAAM,KAAKC,IAAL,CAAUT,MAAV,CAAzB;AACA,WAAOQ,UAAU,CAACb,GAAX,CAAgBe,IAAD,IAAUA,IAAI,CAACC,OAA9B,CAAP;AACD;AACD;AACF;AACA;AACA;;;AACY,QAAJF,IAAI,CAACnC,GAAD,EAA2D;AACnE,UAAMoB,YAAY,GAAG,MAAM,KAAKnB,2BAAL,CAAiCD,GAAjC,CAA3B;AACA,UAAMkC,UAAU,GAAG,MAAM,KAAKhC,OAAL,CAAakB,YAAb,CAAzB;AACA,UAAMkB,OAAO,GAAG,MAAM,KAAKzG,QAAL,CAAc0G,iBAAd,CAAgCL,UAAU,CAACb,GAAX,CAAgBmB,CAAD,IAAOA,CAAC,CAAC1D,EAAxB,CAAhC,CAAtB;AACA,UAAM2D,kBAAkB,GAAGP,UAAU,CAACb,GAAX,CAAgB7C,SAAD,IAAe;AACvD,YAAM6D,OAAO,GAAGC,OAAO,CAACI,aAAR,CAAsBC,UAAtB,CAAiCnE,SAAS,CAACM,EAA3C,CAAhB;AACA,UAAI,CAACuD,OAAL,EAAc,MAAM,IAAIlF,KAAJ,CAAW,8BAA6BqB,SAAS,CAACM,EAAV,CAAa8D,QAAb,EAAwB,EAAhE,CAAN;AACd,aAAO,KAAIC,oCAAJ,EAAsBrE,SAAtB,EAAiC6D,OAAjC,CAAP;AACD,KAJ0B,CAA3B;AAKA,WAAOI,kBAAP;AACD;;AAE4B,QAAhBK,gBAAgB,CAACC,iBAAD,EAAuC;AAClE,UAAMC,QAAQ,GAAGD,iBAAiB,CAAC1B,GAAlB,CAAsB,MAAO4B,KAAP,IAAiB;AACtD,aAAO,KAAIC,wBAAJ,EAAgB,MAAM,KAAKC,kBAAL,CAAwBF,KAAK,CAACnE,EAA9B,CAAtB,EAAyDmE,KAAzD,CAAP;AACD,KAFgB,CAAjB;AAIA,UAAMG,OAAsB,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYN,QAAZ,CAArC;AACA,WAAO,KAAKpH,eAAL,CAAqB2H,2BAArB,CAAiDH,OAAjD,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACW,QAAHI,GAAG,CACP9C,WADO,EAEP+C,UAAU,GAAG,KAFN,EAGPC,eAHO,EAIPC,QAAQ,GAAG,IAJJ,EAKPC,YAAY,GAAG,IALR,EAMa;AACpB,SAAK3H,MAAL,CAAY4H,KAAZ,CAAmB,OAAMnD,WAAW,CAACkC,QAAZ,EAAuB,EAAhD;AACA,WAAO,KAAK9F,eAAL,CAAqB0G,GAArB,CAAyB9C,WAAzB,EAAsC+C,UAAtC,EAAkDC,eAAlD,EAAmEC,QAAnE,EAA6EC,YAA7E,CAAP;AACD,GA/SgD,CAiTjD;;;AAC4B,QAAtBE,sBAAsB,CAACtF,SAAD,EAA4C;AACtE,UAAMuF,GAAG,GAAG,KAAKxH,IAAL,CAAUyH,YAAV,CAAuBxF,SAAvB,CAAZ;;AACA,QAAIuF,GAAG,CAACA,GAAJ,CAAQE,eAAR,IAA2B,OAAOF,GAAG,CAACA,GAAJ,CAAQE,eAAf,KAAmC,UAAlE,EAA8E;AAAA;;AAC5E,YAAMC,gBAAgB,GAAG,MAAMH,GAAG,CAACA,GAAJ,CAAQE,eAAR,EAA/B,CAD4E,CAE5E;;AACA,UAAIE,QAAJ;AACA,UAAI,KAAK5H,IAAL,CAAU6H,eAAV,CAA0B5F,SAAS,CAACM,EAAV,CAAa8D,QAAb,EAA1B,CAAJ,EAAwDuB,QAAQ,GAAG,KAAK5H,IAAL,CAAU8H,WAAV,CAAsBN,GAAtB,CAAX;AACxD,YAAMzF,IAAI,GAAG,KAAKtC,YAAL,CAAkBsI,aAAlB,CAAgCP,GAAG,CAACjF,EAApC,EAAwCR,IAAxC,IAAgDyF,GAAG,CAACA,GAAJ,CAAQzF,IAArE;AAEA,aAAO;AACLiG,QAAAA,IAAI,EAAEL,gBAAgB,CAACK,IADlB;AAELzF,QAAAA,EAAE,EAAEiF,GAAG,CAACjF,EAFH;AAGLZ,QAAAA,IAAI,EAAE6F,GAAG,CAAC7F,IAHL;AAILI,QAAAA,IAJK;AAKLkG,QAAAA,WAAW,EAAET,GAAG,CAACS,WALZ;AAMLL,QAAAA,QAAQ,eAAEA,QAAF,8CAAE,UAAUM,QAAV;AANL,OAAP;AAQD;;AAED,WAAO,EAAP;AACD;;AAEDC,EAAAA,UAAU,GAAG;AACX,SAAKzI,MAAL,CAAY4H,KAAZ,CAAkB,yCAAlB;AACA,SAAK/G,eAAL,CAAqB4H,UAArB;AACA,SAAK/I,KAAL,CAAW+I,UAAX;AACA,SAAKxI,aAAL,GAAqB,KAAIC,yBAAJ,EAAmB,KAAKT,QAAxB,CAArB;AACD;;AAEDiJ,EAAAA,mBAAmB,CAAC7F,EAAD,EAAkB;AACnC,SAAKhC,eAAL,CAAqB6H,mBAArB,CAAyC7F,EAAzC;AACA,SAAKpD,QAAL,CAAcoB,eAAd,CAA8B8H,sBAA9B,CAAqD9F,EAAE,CAACE,OAAxD;AACA,SAAK9C,aAAL,GAAqB,KAAIC,yBAAJ,EAAmB,KAAKT,QAAxB,CAArB;AACD;;AAE6B,QAAxBmJ,wBAAwB,CAAC/F,EAAD,EAAqD;AACjF,UAAMN,SAAS,GAAG,MAAM,KAAKgF,GAAL,CAAS1E,EAAT,CAAxB,CADiF,CAEjF;AACA;AACA;;AACA,UAAM,KAAKgG,WAAL,EAAN;AACA,UAAMC,eAAe,GAAG,KAAKzI,qBAAL,CAA2B0I,OAA3B,EAAxB,CANiF,CAMnB;;AAC9D,UAAMC,OAAqE,GAAG,EAA9E;AACA,UAAM,2BAAUF,eAAV,EAA2B,OAAO,CAACG,SAAD,EAAYC,YAAZ,CAAP,KAAqC;AACpE,YAAMC,cAAc,GAAG,MAAMD,YAAY,CAAC3G,SAAD,CAAzC;AACAyG,MAAAA,OAAO,CAACI,IAAR,CAAa;AAAEC,QAAAA,WAAW,EAAEJ,SAAf;AAA0BD,QAAAA,OAAO,EAAEG;AAAnC,OAAb;AACD,KAHK,CAAN,CARiF,CAajF;;AACA,UAAM,KAAK1I,OAAL,CAAalB,MAAb,CAAoB+J,OAApB,CAA4BpK,gBAA5B,EAA8C;AAAEqK,MAAAA,gBAAgB,EAAE;AAAEhH,QAAAA;AAAF;AAApB,KAA9C,CAAN;AACA,WAAOyG,OAAP;AACD;;AAE0B,QAArBQ,qBAAqB,CAAC3G,EAAD,EAAqD;AAC9E,UAAMN,SAAS,GAAG,MAAM,KAAKgF,GAAL,CAAS1E,EAAT,CAAxB;AACA,UAAM4G,YAAY,GAAG,KAAKlJ,kBAAL,CAAwBwI,OAAxB,EAArB,CAF8E,CAEtB;;AACxD,UAAMC,OAAqE,GAAG,EAA9E;AACA,UAAM,2BAAUS,YAAV,EAAwB,OAAO,CAACR,SAAD,EAAYS,SAAZ,CAAP,KAAkC;AAC9D,YAAMC,WAAW,GAAG,MAAMD,SAAS,CAACnH,SAAD,CAAnC;AACAyG,MAAAA,OAAO,CAACI,IAAR,CAAa;AAAEC,QAAAA,WAAW,EAAEJ,SAAf;AAA0BD,QAAAA,OAAO,EAAEW;AAAnC,OAAb;AACD,KAHK,CAAN;AAKA,UAAM,KAAKlJ,OAAL,CAAalB,MAAb,CAAoB+J,OAApB,CAA4BrK,cAA5B,EAA4C;AAAE2K,MAAAA,cAAc,EAAE;AAAErH,QAAAA;AAAF;AAAlB,KAA5C,CAAN;AACA,WAAOyG,OAAP;AACD;;AAE6B,QAAxBa,wBAAwB,CAAChH,EAAD,EAAqD;AACjF,UAAMiH,eAAe,GAAG,KAAKtJ,qBAAL,CAA2BuI,OAA3B,EAAxB,CADiF,CACnB;;AAC9D,UAAMC,OAAqE,GAAG,EAA9E;AACA,UAAM,2BAAUc,eAAV,EAA2B,OAAO,CAACb,SAAD,EAAYc,YAAZ,CAAP,KAAqC;AACpE,YAAMC,cAAc,GAAG,MAAMD,YAAY,CAAClH,EAAD,CAAzC;AACAmG,MAAAA,OAAO,CAACI,IAAR,CAAa;AAAEC,QAAAA,WAAW,EAAEJ,SAAf;AAA0BD,QAAAA,OAAO,EAAEgB;AAAnC,OAAb;AACD,KAHK,CAAN;AAKA,UAAM,KAAKvJ,OAAL,CAAalB,MAAb,CAAoB+J,OAApB,CAA4BnK,gBAA5B,EAA8C;AAAE8K,MAAAA,gBAAgB,EAAE;AAAE9E,QAAAA,YAAY,EAAE,CAACtC,EAAE,CAAC2F,QAAH,EAAD;AAAhB;AAApB,KAA9C,CAAN;AACA,WAAOQ,OAAP;AACD;;AAEDkB,EAAAA,QAAQ,CAACrH,EAAD,EAAkBsH,IAAlB,EAAgC;AACtC,WAAO,KAAKzK,KAAL,CAAWwK,QAAX,CAAoBrH,EAApB,EAAwBsH,IAAxB,CAAP;AACD;;AAEDC,EAAAA,OAAO,CAACvH,EAAD,EAAkBsH,IAAlB,EAAgC;AACrC,WAAO,KAAKzK,KAAL,CAAW0K,OAAX,CAAmBvH,EAAnB,EAAuBsH,IAAvB,CAAP;AACD;;AAEDE,EAAAA,gBAAgB,GAAgB;AAC9B,WAAO,KAAK5K,QAAL,CAAc4K,gBAAd,EAAP;AACD;;AAEDC,EAAAA,oBAAoB,GAAsB;AACxC,QAAI,CAAC,KAAK9K,MAAL,CAAY+K,UAAjB,EAA6B;AAC3B,aAAO,KAAIC,kCAAJ,GAAP;AACD;;AACD,WAAOA,mCAAkBC,gBAAlB,CAAmC,KAAKjL,MAAL,CAAY+K,UAA/C,CAAP;AACD;;AAEgB,QAAXG,WAAW,CAAC7H,EAAD,EAAkB8H,OAAlB,EAAuE;AACtF,UAAMlG,WAAW,GAAG,MAAM,KAAKyC,kBAAL,CAAwBrE,EAAxB,CAA1B;AACA,UAAMN,SAAS,GAAG,MAAM,KAAK7C,KAAL,CAAW6H,GAAX,CAAe9C,WAAf,CAAxB;AACA,UAAMmG,OAAO,GAAGrI,SAAS,SAAT,IAAAA,SAAS,WAAT,IAAAA,SAAS,CAAEU,KAAX,CAAiB2H,OAAjB,GACZ,MAAM,KAAKC,yBAAL,CAA+BtI,SAA/B,aAA+BA,SAA/B,uBAA+BA,SAAS,CAAEU,KAAX,CAAiB2H,OAAhD,CADM,GAEZ,MAAM,KAAK/D,gBAAL,CAAsB,KAAI2D,kCAAJ,GAAtB,CAFV;AAIA,UAAMM,YAAY,GAAG,KAAKA,YAAL,CAAkBjI,EAAlB,EAAsB;AAAEkI,MAAAA,aAAa,EAAE;AAAjB,KAAtB,CAArB;AACA,UAAMC,mBAAmB,GAAG,KAAIC,0CAAJ,EAAwBxG,WAAxB,EAAqCmG,OAArC,EAA8CD,OAAO,CAACO,SAAtD,CAA5B;AACA,UAAMF,mBAAmB,CAACG,KAApB,CAA0BL,YAA1B,EAAwC;AAAEM,MAAAA,QAAQ,EAAET,OAAO,CAACS;AAApB,KAAxC,CAAN;AACA,WAAO;AACLC,MAAAA,UAAU,EAAEJ,2CAAoBK,WAApB,CAAgCR,YAAhC;AADP,KAAP;AAGD;;AAEsC,QAAzBD,yBAAyB,CAACU,mBAAD,EAAuD;AAC5F,UAAMC,YAAY,GAAG,MAAMD,mBAAmB,CAACE,IAApB,CAAyB,MAAOzE,KAAP,IAAiB;AACnE,UAAIA,KAAK,CAACnE,EAAN,CAASnD,KAAT,KAAmB,KAAKA,KAAL,CAAWuC,IAAlC,EAAwC;AACtC,eAAO+E,KAAP;AACD;;AACD,YAAM0E,KAAK,GAAG,MAAM,KAAKxE,kBAAL,CAAwBF,KAAK,CAACnE,EAAN,CAASiC,QAAjC,CAApB;AACA,YAAM6G,QAAQ,GAAG,KAAI1E,wBAAJ,EAAgByE,KAAhB,EAAuB1E,KAAK,CAAC4E,MAA7B,CAAjB;AACA,aAAOD,QAAP;AACD,KAP0B,CAA3B;AAQA,WAAOH,YAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACiB,QAATK,SAAS,CAACC,OAAD,EAAkBpM,KAAK,GAAG,IAA1B,EAAsD;AACnE,UAAMqE,GAAG,GAAG,MAAM,KAAKO,OAAL,EAAlB;AACA,UAAMyH,YAAY,GAAI,GAAErM,KAAM,IAAGoM,OAAO,IAAI,IAAK,EAAjD;AACA,UAAME,SAAS,GAAGjI,GAAG,CAACJ,MAAJ,CAAYd,EAAD,IAAQ;AACnC,YAAMoJ,IAAI,GAAG,qDAA4BpJ,EAAE,CAACqJ,sBAAH,EAA5B,EAAyDH,YAAzD,CAAb;AACA,aAAOE,IAAI,CAACE,KAAZ;AACD,KAHiB,CAAlB;AAKA,UAAMlG,UAAU,GAAG,MAAM,KAAKhC,OAAL,CAAa+H,SAAb,CAAzB;AACA,WAAO/F,UAAP;AACD;;AAEY,QAAPhC,OAAO,CAACF,GAAD,EAA0ByD,UAAU,GAAG,KAAvC,EAAoE;AAC/E,WAAO,KAAK3G,eAAL,CAAqBoD,OAArB,CAA6BF,GAA7B,EAAkCyD,UAAlC,CAAP;AACD;;AAED4E,EAAAA,eAAe,CAACnG,UAAD,EAAwD;AACrE,WAAO,2BAAUA,UAAV,EAAsB,MAAO1D,SAAP,IAAqB;AAChD,YAAMM,EAAE,GAAG,MAAM,KAAKqE,kBAAL,CAAwB3E,SAAS,CAACM,EAAlC,CAAjB;AACA,aAAO,KAAK0E,GAAL,CAAS1E,EAAT,EAAawJ,SAAb,EAAwB9J,SAAxB,CAAP;AACD,KAHM,CAAP;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAhB+J,gBAAgB,CAACvI,GAAD,EAA0ByD,UAAU,GAAG,KAAvC,EAAoE;AACxF,UAAM,KAAK9H,KAAL,CAAW6M,MAAX,CAAkBxI,GAAlB,CAAN;AACA,WAAO,KAAKlD,eAAL,CAAqBoD,OAArB,CAA6BF,GAA7B,EAAkCyD,UAAlC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,QAAHgF,GAAG,CACPC,cADO,EAEP5J,EAFO,EAGP6J,IAHO,EAIPtB,QAAQ,GAAG,KAJJ,EAKoB;AAC3B,UAAMuB,YAAY,GAAG,KAAIC,wBAAJ,EAAkB;AAAEnN,MAAAA,QAAQ,EAAE,KAAKA;AAAjB,KAAlB,EAA+C;AAAEgN,MAAAA,cAAF;AAAkB5J,MAAAA,EAAlB;AAAsB6J,MAAAA,IAAtB;AAA4BtB,MAAAA;AAA5B,KAA/C,CAArB;AACA,UAAMyB,UAAU,GAAG,MAAMF,YAAY,CAACH,GAAb,EAAzB,CAF2B,CAG3B;AACA;;AACA,UAAM,KAAK/M,QAAL,CAAcoE,MAAd,CAAqBsH,KAArB,CAA2B,KAAK1L,QAAL,CAAcqN,gBAAzC,CAAN;AACA,WAAOD,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACa,QAALE,KAAK,CAACC,SAAD,EAA6C;AACtD,UAAML,YAAY,GAAG,KAAIC,wBAAJ,EACnB;AAAEnN,MAAAA,QAAQ,EAAE,KAAKA;AAAjB,KADmB,EAEnB;AAAEgN,MAAAA,cAAc,EAAE,CAACO,SAAS,CAACC,OAAX,CAAlB;AAAuCpK,MAAAA,EAAE,EAAEmK,SAAS,CAACE,aAArD;AAAoER,MAAAA,IAAI,EAAEM,SAAS,CAACG,QAApF;AAA8F/B,MAAAA,QAAQ,EAAE;AAAxG,KAFmB,CAArB;AAIA,UAAMgC,MAAM,GAAG,MAAMT,YAAY,CAACH,GAAb,EAArB;AACA,UAAMa,cAAc,GAAGD,MAAM,CAACE,eAAP,CAAuB,CAAvB,CAAvB;AACA,UAAMJ,aAAa,GAAG,CAAAG,cAAc,SAAd,IAAAA,cAAc,WAAd,YAAAA,cAAc,CAAExK,EAAhB,CAAmBZ,IAAnB,KAA4B+K,SAAS,CAACE,aAA5D;AACA,UAAMK,KAAK,GAAG,CAAAF,cAAc,SAAd,IAAAA,cAAc,WAAd,YAAAA,cAAc,CAAEE,KAAhB,CAAsBnI,GAAtB,CAA2BoI,CAAD,IAAOA,CAAC,CAACC,YAAnC,MAAoD,EAAlE;AACA,WAAO;AAAEP,MAAAA,aAAF;AAAiBK,MAAAA,KAAjB;AAAwBG,MAAAA,QAAQ,EAAEN,MAAM,CAACM;AAAzC,KAAP;AACD;;AAEU,QAALvC,KAAK,CAACwC,QAAD,EAAmBpL,SAAnB,EAAyC;AAClD,UAAM6E,OAAO,CAACC,GAAR,CACJ9E,SAAS,CAACqL,UAAV,CAAqBL,KAArB,CAA2BnI,GAA3B,CAA+B,MAAOyI,IAAP,IAAgB;AAC7C,YAAMC,WAAW,GAAG1M,gBAAKG,IAAL,CAAU,KAAKH,IAAf,EAAqBuM,QAArB,EAA+BE,IAAI,CAACzM,IAApC,CAApB;;AACA,YAAM2M,mBAAGC,UAAH,CAAcF,WAAd,EAA2BD,IAAI,CAACI,QAAhC,CAAN;AACD,KAHD,CADI,CAAN;AAMD;;AAEgB,QAAXpF,WAAW,GAAG;AAClB,UAAM,KAAKpJ,QAAL,CAAcoJ,WAAd,EAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEiC,EAAAA,YAAY,CACVrG,WADU,EAEVyJ,aAFU,EAGVvD,OAAO,GAAG;AAAEwD,IAAAA,QAAQ,EAAE;AAAZ,GAHA,EAIG;AACb,WAAO,KAAKC,wBAAL,CAA8B3J,WAAW,CAAC1B,OAA1C,EAAmDmL,aAAnD,EAAkEvD,OAAlE,CAAP;AACD;;AAEOyD,EAAAA,wBAAwB,CAC9BC,KAD8B,EAE9BH,aAF8B,EAG9BvD,OAAO,GAAG;AAAEwD,IAAAA,QAAQ,EAAE;AAAZ,GAHoB,EAIjB;AACb,UAAMG,YAAY,GAAG,KAAK7O,QAAL,CAAcoE,MAAd,CAAqB0K,YAArB,CAAkCF,KAAlC,EAAyCH,aAAzC,CAArB;AACA,UAAMM,oBAAoB,GAAGF,YAAY,CAACG,eAAb,EAA7B;;AACA,QAAI,CAACD,oBAAL,EAA2B;AACzB,YAAM,KAAIE,gCAAJ,EAAmBL,KAAK,CAAC1H,QAAN,EAAnB,CAAN;AACD;;AACD,QAAIgE,OAAO,CAACwD,QAAZ,EAAsB;AACpB,aAAOK,oBAAP;AACD;;AAED,WAAOpN,gBAAKG,IAAL,CAAU,KAAKH,IAAf,EAAqBoN,oBAArB,CAAP;AACD;;AAEDG,EAAAA,sBAAsB,CAACH,oBAAD,EAAiE;AACrF,WAAOpN,gBAAKG,IAAL,CAAU,KAAKH,IAAf,EAAqBoN,oBAArB,CAAP;AACD;;AAE0B,QAArBI,qBAAqB,CAACnK,WAAD,EAAwD;AACjF,UAAM+J,oBAAoB,GAAG,KAAK1D,YAAL,CAAkBrG,WAAlB,EAA+B;AAAEsG,MAAAA,aAAa,EAAE;AAAjB,KAA/B,EAAwD;AAAEoD,MAAAA,QAAQ,EAAE;AAAZ,KAAxD,CAA7B;AACA,WAAO,KAAKU,4CAAL,CAAkDL,oBAAlD,EAAwE/J,WAAW,CAACK,QAApF,CAAP;AACD;;AAEiD,QAA5C+J,4CAA4C,CAChDL,oBADgD,EAEhDvM,IAFgD,EAGnB;AAC7B,UAAM+I,mBAAmB,GAAG,MAAM,KAAK8D,0CAAL,CAAgDN,oBAAhD,EAAsEvM,IAAtE,CAAlC;;AACA,QAAI+I,mBAAmB,IAAIA,mBAAmB,CAAChK,YAA/C,EAA6D;AAC3D,aAAOgK,mBAAmB,CAAChK,YAA3B;AACD;;AACD,WAAO,KAAK+N,6DAAL,CAAmEP,oBAAnE,EAAyFvM,IAAzF,CAAP;AACD;;AAEe,MAAZjB,YAAY,GAAG;AACjB,WAAO,KAAKxB,MAAL,CAAYwB,YAAnB;AACD;;AAE0E,QAA7D+N,6DAA6D,CACzEP,oBADyE,EAEzEvM,IAFyE,EAG5C;AAC7B,UAAM+M,aAAa,GAAG,KAAKlP,QAAL,CAAcmP,gBAAd,CAA+BT,oBAA/B,EAAqDvM,IAArD,CAAtB;;AACA,QAAI+M,aAAa,IAAIA,aAAa,CAAChO,YAAnC,EAAiD;AAC/C,aAAOgO,aAAa,CAAChO,YAArB;AACD;;AACD,UAAMkO,QAAQ,GAAG,KAAKC,+BAAL,CAAqCX,oBAArC,CAAjB;;AACA,QAAI,CAACU,QAAL,EAAe;AACb,aAAO,KAAK1P,MAAL,CAAYwB,YAAnB;AACD;;AACD,WAAOqL,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC2B,QAAnB+C,mBAAmB,CAAC3K,WAAD,EAA2B4K,kBAA3B,EAAuF;AAAA;;AAC9G;AACA,QAAIC,oBAAJ;AACA,QAAIC,kBAAJ;AACA,QAAIC,mBAAJ;AACA,UAAMC,cAAc,GAAG,IAAvB;AACA,UAAMC,eAAe,GAAG,CAAAL,kBAAkB,SAAlB,IAAAA,kBAAkB,WAAlB,qCAAAA,kBAAkB,CAAE7P,MAApB,gFAA4B+K,UAA5B,KAA0C,KAAIC,kCAAJ,GAAlE;AAEA,UAAMQ,mBAAmB,GAAG,MAAM,KAAKA,mBAAL,CAAyBvG,WAAzB,CAAlC;;AACA,QAAIuG,mBAAJ,EAAyB;AACvBsE,MAAAA,oBAAoB,GAAGtE,mBAAmB,CAACJ,OAApB,CAA4B+E,QAA5B,EAAvB,CADuB,CAEvB;AACA;AACD;;AACD,UAAMnB,oBAAoB,GAAG,KAAK1D,YAAL,CAAkBrG,WAAlB,EAA+B;AAAEsG,MAAAA,aAAa,EAAE;AAAjB,KAA/B,EAAwD;AAAEoD,MAAAA,QAAQ,EAAE;AAAZ,KAAxD,CAA7B;AACA,UAAMa,aAAa,GAAG,KAAKlP,QAAL,CAAcmP,gBAAd,CAA+BT,oBAA/B,EAAqD/J,WAAW,CAACK,QAAjE,CAAtB;;AACA,QAAIkK,aAAJ,EAAmB;AACjBO,MAAAA,kBAAkB,GAAGP,aAAa,CAACzE,UAAnC,CADiB,CAEjB;AACA;AACA;AACA;AACD;;AACD,UAAM2E,QAAQ,GAAG,KAAKC,+BAAL,CAAqCX,oBAArC,CAAjB;;AACA,QAAI,CAACU,QAAL,EAAe;AACbM,MAAAA,mBAAmB,GAAG,KAAKlF,oBAAL,EAAtB;AACD,KA1B6G,CA2B9G;;;AACA,UAAMsF,iBAAsC,GAAG,EAA/C;;AACA,QAAIN,oBAAJ,EAA0B;AACxBM,MAAAA,iBAAiB,CAACxG,IAAlB,CAAuBkG,oBAAvB;AACD;;AACD,QAAIO,mBAAmB,4BAAG7E,mBAAH,aAAGA,mBAAH,uBAAGA,mBAAmB,CAAEE,SAAxB,yEAAqC,IAA5D;;AACA,QAAIqE,kBAAkB,IAAIM,mBAA1B,EAA+C;AAC7C;AACAD,MAAAA,iBAAiB,CAACxG,IAAlB,CAAuBmG,kBAAvB;AACD;;AACDM,IAAAA,mBAAmB,GAAGA,mBAAmB,8BAAKb,aAAL,aAAKA,aAAL,uBAAKA,aAAa,CAAE9D,SAApB,yEAAiC,IAAjC,CAAzC,CArC8G,CAsC9G;;AACA,UAAM4E,kBAAkB,GAAGN,mBAAmB,CAACO,aAApB,CAAkCtL,WAAW,CAACkC,QAAZ,EAAlC,EAA0D,IAA1D,EAAgE,IAAhE,CAA3B;;AACA,QAAI6I,mBAAmB,IAAIK,mBAAvB,IAA8C,CAACC,kBAAnD,EAAuE;AACrE;AACAF,MAAAA,iBAAiB,CAACxG,IAAlB,CAAuBoG,mBAAvB;AACD,KA3C6G,CA6C9G;AACA;;;AAEA,QAAIC,cAAc,IAAII,mBAAtB,EAA2C;AACzCD,MAAAA,iBAAiB,CAACxG,IAAlB,CAAuBsG,eAAvB;AACD,KAlD6G,CAoD9G;AACA;;;AACA,UAAMM,QAAQ,GAAGJ,iBAAiB,CAACxK,GAAlB,CAAuB1B,IAAD,IAAU,KAAKuM,uBAAL,CAA6BvM,IAA7B,CAAhC,CAAjB;AACA,UAAM0D,OAAO,CAACC,GAAR,CAAY2I,QAAZ,CAAN;;AAEA,QAAIE,gBAAgB,GAAG1F,mCAAkB2F,YAAlB,CAA+BP,iBAA/B,EAAkDQ,uBAAlD,EAAvB,CAzD8G,CA2D9G;;;AACA,UAAMC,sBAAsB,GAAGH,gBAAgB,CAACH,aAAjB,CAC7BtL,WAAW,CAAC1B,OAAZ,CAAoBuN,8BAApB,EAD6B,EAE7B,IAF6B,EAG7B,IAH6B,CAA/B;;AAKA,QAAID,sBAAsB,IAAIA,sBAAsB,CAAChH,WAArD,EAAkE;AAChE6G,MAAAA,gBAAgB,GAAGA,gBAAgB,CAACK,MAAjB,CAAwBF,sBAAsB,CAAChH,WAA/C,CAAnB;AACD;;AAED,WAAO6G,gBAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACuC,QAAvBD,uBAAuB,CAACO,aAAD,EAA+D;AAClG,UAAMR,QAAQ,GAAGQ,aAAa,CAACpL,GAAd,CAAkB,MAAO4B,KAAP,IAAiB;AAClD,UAAIA,KAAK,CAACqC,WAAV,EAAuB;AACrB,cAAMxG,EAAE,GAAG,MAAM,KAAKqE,kBAAL,CAAwBF,KAAK,CAACqC,WAA9B,CAAjB;AACArC,QAAAA,KAAK,CAACqC,WAAN,GAAoBxG,EAAE,CAACE,OAAvB;AACD;;AAED,aAAOiE,KAAP;AACD,KAPgB,CAAjB;AAQA,UAAMI,OAAO,CAACC,GAAR,CAAY2I,QAAZ,CAAN;AACA,WAAOQ,aAAP;AACD;;AAEOrB,EAAAA,+BAA+B,CAACX,oBAAD,EAAqD;AAAA;;AAC1F,UAAMiC,SAAS,GAAG,6BAAKjR,MAAL,CAAYkR,MAAZ,4EAAoBC,SAApB,KAAiCvR,kBAAnD;;AACA,QAAI,2BAAaoP,oBAAb,EAAmCiC,SAAnC,CAAJ,EAAmD;AACjD,aAAO,IAAP;AACD,KAJyF,CAK1F;;;AACA,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;;;AACmC,QAAnBzF,mBAAmB,CAACnI,EAAD,EAA4D;AAC3F,UAAM2L,oBAAoB,GAAG,KAAK1D,YAAL,CAAkBjI,EAAlB,EAAsB;AAAEkI,MAAAA,aAAa,EAAE;AAAjB,KAAtB,EAA+C;AAAEoD,MAAAA,QAAQ,EAAE;AAAZ,KAA/C,CAA7B;AACA,WAAO,KAAKW,0CAAL,CAAgDN,oBAAhD,EAAsE3L,EAAE,CAACiC,QAAzE,CAAP;AACD;;AAEuD,QAA1CgK,0CAA0C,CACtDN,oBADsD,EAEtDvM,IAFsD,EAGZ;AAC1C,QAAI+I,mBAAJ;;AACA,QAAIwD,oBAAJ,EAA0B;AACxB,YAAMoC,eAAe,GAAG,KAAKjC,sBAAL,CAA4BH,oBAA5B,CAAxB;AACA,YAAMqC,4BAA4B,GAAG,MAAM,KAAK9B,6DAAL,CACzCP,oBADyC,EAEzCvM,IAFyC,CAA3C;AAIA+I,MAAAA,mBAAmB,GAAG,MAAMC,2CAAoB/E,IAApB,CAC1B0K,eAD0B,EAE1B,KAAK/J,gBAAL,CAAsBiK,IAAtB,CAA2B,IAA3B,CAF0B,EAG1BD,4BAH0B,CAA5B;AAKD;;AAED,WAAO7F,mBAAP;AACD;;AAEwB,QAAnB+F,mBAAmB,CAAC9K,UAAD,EAA0B;AACjD,UAAMlC,GAAG,GAAGkC,UAAU,CAACb,GAAX,CAAgB7C,SAAD,IAAeA,SAAS,CAACM,EAAV,CAAaE,OAA3C,CAAZ;AACA,UAAMiO,oBAAoB,GAAG,KAAKjR,YAAL,CAAkBkR,gBAAlB,EAA7B;AACA,UAAMC,uBAAuB,GAAGF,oBAAoB,CAAC5L,GAArB,CAA0BvC,EAAD,IAAQsO,qBAAMC,KAAN,CAAYvO,EAAZ,EAAgB,IAAhB,CAAjC,CAAhC;;AACA,UAAMwO,iBAAiB,GAAGC,gBAAOC,SAAP,CAAiBL,uBAAuB,CAAC9L,GAAxB,CAA6BvC,EAAD,IAAQA,EAAE,CAAC2O,WAAH,CAAe,IAAf,CAApC,CAAjB,CAA1B,CAJiD,CAKjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,UAAMC,UAAU,GAAGJ,iBAAiB,CAACK,MAAlB,CAAyB,EAAzB,CAAnB;AACA,WAAO,mDAA2B3N,GAA3B,EAAgC,KAAKtE,QAArC,EAA+C4M,SAA/C,EAA0DiF,gBAAOC,SAAP,CAAiBE,UAAjB,CAA1D,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACmB,QAAXE,WAAW,CAAC5N,GAAa,GAAG,EAAjB,EAAqB6N,YAAY,GAAG,KAApC,EAA0D;AACzE,SAAK5R,MAAL,CAAY4H,KAAZ,CAAmB,WAAU7D,GAAG,CAAC3B,MAAO,UAAxC;AACA,UAAMyP,YAAY,GAAG9N,GAAG,CAACJ,MAAJ,CAAYd,EAAD,IAAQ,CAAC,KAAK9C,YAAL,CAAkB+R,cAAlB,CAAiCjP,EAAjC,CAApB,CAArB;AACA,QAAI,CAACgP,YAAY,CAACzP,MAAlB,EAA0B;AAC1B,UAAM4O,oBAAoB,GAAG,KAAKjR,YAAL,CAAkBkR,gBAAlB,EAA7B;AACA,UAAMc,cAAwB,GAAG,0BAAWF,YAAX,EAAyBb,oBAAzB,CAAjC;AACA,UAAM7L,YAAY,GAAG,MAAM,KAAKnB,2BAAL,CAAiC+N,cAAjC,CAA3B;AACA,UAAM9L,UAAU,GAAG,MAAM,KAAK+L,mBAAL,CAAyB7M,YAAzB,CAAzB;AACA,UAAM8M,KAAK,GAAG,MAAM,KAAKlB,mBAAL,CAAyB9K,UAAzB,CAApB;AACA,UAAMiM,OAAO,GAAGD,KAAK,CAACE,KAAN,GAAc/M,GAAd,CAAkB,MAAOvC,EAAP,IAAc;AAC9C,aAAO,KAAKqE,kBAAL,CAAwBrE,EAAxB,CAAP;AACD,KAFe,CAAhB;AAGA,UAAMuP,MAAM,GAAG,MAAMhL,OAAO,CAACC,GAAR,CAAY6K,OAAZ,CAArB;AACA,UAAMG,aAAa,GAAG,MAAM,KAAKpO,OAAL,CAAamO,MAAb,CAA5B;AAEA,UAAMxH,OAAO,GAAGyH,aAAa,CAAC1O,MAAd,CAAsBpB,SAAD,IAA0B;AAAA;;AAC7D,UAAI+P,IAAI,4BAAG/P,SAAS,CAAC/C,MAAV,CAAiB+K,UAAjB,CAA4BwF,aAA5B,CAA0CwC,mBAAW1P,EAArD,CAAH,0DAAG,sBAA0DyP,IAArE;;AACA,UAAI,CAACA,IAAL,EAAW;AACT;AACAA,QAAAA,IAAI,GAAG/P,SAAS,CAACU,KAAV,CAAgB2H,OAAhB,CAAwBrD,GAAxB,CAA4B,6BAA5B,CAAP;AACD;;AAED,UAAI,CAAC+K,IAAL,EAAW,OAAO,KAAP;;AACX,UAAIA,IAAI,CAAChK,IAAL,KAAc,QAAd,IAA0ByJ,cAAc,CAACS,QAAf,CAAwBjQ,SAAS,CAACM,EAAV,CAAa8D,QAAb,EAAxB,CAA9B,EAAgF;AAC9E,cAAM8L,GAAG,GAAG,KAAIC,wCAAJ,EAAuBnQ,SAAS,CAACM,EAAV,CAAa8D,QAAb,EAAvB,EAAgD2L,IAAI,CAAChK,IAArD,EAA2DgK,IAAI,CAACzP,EAAhE,CAAZ;;AACA,YAAIyP,IAAI,CAACzP,EAAL,KAAY8P,mBAAhB,EAA6B;AAC3B;AACA;AACA;AACA,eAAK3S,MAAL,CAAY4S,KAAZ,CAAkBH,GAAG,CAACI,OAAtB;AACD,SALD,MAKO;AACL,gBAAMJ,GAAN;AACD;AACF;;AACD,aAAOH,IAAI,CAAChK,IAAL,KAAc,QAArB;AACD,KApBe,CAAhB,CAfyE,CAoCzE;AACA;;AACA,UAAM;AAAEwK,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,QAAiC,MAAM,KAAKC,kCAAL,CAAwCpI,OAAxC,CAA7C,CAtCyE,CAuCzE;;AACA,UAAMqI,QAAQ,GAAGF,UAAU,CAAC3N,GAAX,CAAgB8N,MAAD,IAAYA,MAAM,CAACrQ,EAAP,CAAU8D,QAAV,EAA3B,CAAjB;AACA,UAAM,KAAKjH,KAAL,CAAWiS,WAAX,CAAuBsB,QAAvB,EAAiCrB,YAAjC,CAAN;AAEA,UAAMuB,gBAAgB,GAAG,MAAM,KAAKC,iBAAL,CAAuBN,cAAvB,CAA/B;AACA,UAAM,KAAK/S,YAAL,CAAkBsT,yBAAlB,CAA4CF,gBAA5C,EAA8DvB,YAA9D,CAAN;AACD;;AAEmB,QAAd0B,cAAc,CAACC,WAAD,EAAuBpO,YAAvB,EAAkF;AACpG,QAAIqO,YAAY,GAAG,KAAnB;AACA,UAAMC,SAAmB,GAAG,EAA5B;AACA,UAAMC,YAAY,GAAGvO,YAAY,GAAGA,YAAY,CAACC,GAAb,CAAkBvC,EAAD,IAAQA,EAAE,CAAC8D,QAAH,EAAzB,CAAH,GAA6C,KAAKxG,OAAL,CAAawT,aAA3F;AACA,UAAMC,cAAc,GAAG,KAAK7T,YAAL,CAAkBkR,gBAAlB,EAAvB;AACA,UAAM4C,cAAwB,GAAG,0BAAWH,YAAX,EAAyBE,cAAzB,CAAjC;AACA,UAAME,qBAAqB,GAAG,MAAM,KAAK9P,2BAAL,CAAiC6P,cAAjC,CAApC;AACA,UAAM;AAAEE,MAAAA,YAAF;AAAgBd,MAAAA;AAAhB,QAA6B,MAAM,KAAKe,2BAAL,CAAiCF,qBAAjC,CAAzC;AACA,UAAMG,YAAY,GAAG,MAAM,KAAKhQ,OAAL,CAAa8P,YAAb,CAA3B;AACA,UAAMG,UAAU,GAAG,MAAM,KAAKnU,YAAL,CAAkBuT,cAAlB,CAAiCW,YAAjC,EAA+C,MAAO1R,SAAP,IAAqB;AAC3FkR,MAAAA,SAAS,CAACrK,IAAV,CAAe7G,SAAS,CAACM,EAAV,CAAaE,OAAb,CAAqB4D,QAArB,EAAf;AACA,YAAMwN,SAAS,GAAG,KAAKC,uBAAL,CAA6B7R,SAAS,CAACU,KAAV,CAAgBC,SAA7C,CAAlB;AACA,YAAMmR,OAAO,GAAG,MAAMtG,mBAAGuG,UAAH,CAAcH,SAAd,CAAtB;;AACA,UAAI,CAACE,OAAL,EAAc;AACZb,QAAAA,YAAY,GAAG,IAAf;AACD;;AAED,aAAO;AACLe,QAAAA,UAAU,EAAEJ,SADP;AAELK,QAAAA,WAAW,EAAEjB,WAAW,GAAG,MAAM,KAAKxT,YAAL,CAAkB0U,cAAlB,CAAiClS,SAAjC,EAA4C4R,SAA5C,EAAuDZ,WAAvD,CAAT,GAA+E;AAFlG,OAAP;AAID,KAZwB,CAAzB;AAcA,QAAImB,eAAmC,GAAG,EAA1C;;AACA,QAAIzB,QAAQ,CAAC7Q,MAAb,EAAqB;AACnBsS,MAAAA,eAAe,GAAG,MAAM,KAAKhV,KAAL,CAAW4T,cAAX,CAA0BC,WAA1B,EAAuCN,QAAvC,CAAxB;AACD;;AAED,QAAI0B,cAAc,GAAG,MAAMvN,OAAO,CAACC,GAAR,CACzBuM,cAAc,CAACxO,GAAf,CAAmB,MAAOwP,MAAP,IAAkB;AACnC,YAAMC,MAAM,GAAG,MAAM,kCAAaD,MAAb,EAAqBrB,WAArB,CAArB;AACA,aAAO,KAAKxT,YAAL,CAAkB+U,cAAlB,CAAiCD,MAAjC,CAAP;AACD,KAHD,CADyB,CAA3B,CA5BoG,CAmCpG;;AACA,QAAItB,WAAJ,EAAiB;AACfoB,MAAAA,cAAc,GAAGA,cAAc,CAAChR,MAAf,CAAuBoR,UAAD,IAAgB;AACrD,eAAOA,UAAU,CAACP,WAAlB;AACD,OAFgB,CAAjB;AAGD;;AAED,QAAIhB,YAAJ,EAAkB;AAChB,YAAM,sBAAKC,SAAL,EAAgB,KAAhB,CAAN;AACD;;AAED,UAAMuB,OAAO,GAAGd,UAAU,CAACxC,MAAX,CAAkBiD,cAAlB,EAAkCjD,MAAlC,CAAyCgD,eAAzC,CAAhB;AACA,UAAMO,QAAQ,GAAG,sBAAOD,OAAP,EAAiBE,GAAD,IAAU,GAAEA,GAAG,CAACX,UAAW,IAAGW,GAAG,CAACV,WAAY,EAA9D,CAAjB;AACA,QAAIW,IAAI,GAAGF,QAAX;;AACA,QAAI1B,WAAJ,EAAiB;AACf4B,MAAAA,IAAI,GAAGA,IAAI,CAACxR,MAAL,CAAauR,GAAD,IAASA,GAAG,CAACV,WAAzB,CAAP;AACD;;AAED,WAAOW,IAAP;AACD;;AAEwC,QAA3BnB,2BAA2B,CACvCjQ,GADuC,EAE4B;AACnE,UAAMgQ,YAA2B,GAAG,EAApC;AACA,UAAMd,QAAuB,GAAG,EAAhC;AACA,UAAM7L,OAAO,CAACC,GAAR,CACJtD,GAAG,CAACqB,GAAJ,CAAQ,MAAOvC,EAAP,IAAc;AACpB,YAAMuS,gBAAgB,GAAG,MAAM,KAAK5Q,KAAL,CAAW3B,EAAX,CAA/B;AACAuS,MAAAA,gBAAgB,GAAGrB,YAAY,CAAC3K,IAAb,CAAkBvG,EAAlB,CAAH,GAA2BoQ,QAAQ,CAAC7J,IAAT,CAAcvG,EAAd,CAA3C;AACD,KAHD,CADI,CAAN;AAMA,WAAO;AAAEkR,MAAAA,YAAF;AAAgBd,MAAAA;AAAhB,KAAP;AACD;;AAE+C,QAAlCD,kCAAkC,CAC9C/M,UAD8C,EAEqB;AACnE,UAAM6M,cAA2B,GAAG,EAApC;AACA,UAAMC,UAAuB,GAAG,EAAhC;AACA,UAAM3L,OAAO,CAACC,GAAR,CACJpB,UAAU,CAACb,GAAX,CAAe,MAAO7C,SAAP,IAAqB;AAClC,YAAM6S,gBAAgB,GAAG,MAAM,KAAK5Q,KAAL,CAAWjC,SAAS,CAACM,EAArB,CAA/B;AACAuS,MAAAA,gBAAgB,GAAGtC,cAAc,CAAC1J,IAAf,CAAoB7G,SAApB,CAAH,GAAoCwQ,UAAU,CAAC3J,IAAX,CAAgB7G,SAAhB,CAApD;AACD,KAHD,CADI,CAAN;AAMA,WAAO;AAAEuQ,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,KAAP;AACD;AAED;AACF;AACA;AACA;;;AACsB,QAAdsC,cAAc,CAAC9K,UAAD,EAAgCqH,YAAY,GAAG,KAA/C,EAAqE;AACvF,UAAM0D,cAAc,GAAG/K,UAAU,CAACnF,GAAX,CAAe,MAAOmQ,cAAP,IAA0B;AAC9D;AACA,UAAI,CAACA,cAAc,CAAClM,WAApB,EAAiC;AAC/B,eAAOkM,cAAc,CAACC,QAAtB;AACD;;AAED,YAAM3S,EAAE,GAAG,MAAM,KAAKqE,kBAAL,CAAwBqO,cAAc,CAAClM,WAAvC,CAAjB,CAN8D,CAO9D;;AACA,aAAOxG,EAAE,CAAC8D,QAAH,EAAP;AACD,KATsB,CAAvB;AAUA,UAAMgN,aAAuB,GAAG,MAAMvM,OAAO,CAACC,GAAR,CAAYiO,cAAZ,CAAtC;AACA,UAAMG,gBAAgB,GAAG,KAAKtV,OAAL,CAAawT,aAAtC;AACA,UAAM+B,gBAAgB,GAAG,0BAAW/B,aAAX,EAA0B8B,gBAA1B,CAAzB;AACA,QAAI,CAACC,gBAAgB,CAACtT,MAAtB,EAA8B;AAC9B,UAAM,KAAKuP,WAAL,CAAiB+D,gBAAjB,EAAmC9D,YAAnC,CAAN;AACD;AAED;AACF;AACA;AACA;;;AACE+D,EAAAA,UAAU;AACR;AACJ;AACA;AACI9S,EAAAA,EAJQ,EAKR;AACA,UAAM+S,MAAM,GAAG,KAAf;;AACA,UAAMC,QAAQ,GAAGzU,gBAAKG,IAAL,CAAU,KAAKD,WAAf,EAA4B,QAA5B,EAAsCsU,MAAtC,EAA8C/S,EAA9C,CAAjB,CAFA,CAIA;;;AACA,QAAI,CAACkL,mBAAG+H,UAAH,CAAcD,QAAd,CAAL,EAA8B;AAC5B9H,yBAAGgI,SAAH,CAAaF,QAAb,EAAuB;AAAEG,QAAAA,SAAS,EAAE;AAAb,OAAvB;AACD;;AAED,WAAOH,QAAP;AACD;;AAEsB,QAAjBzC,iBAAiB,CAACnN,UAAD,EAA2D;AAChF,QAAIuN,YAAY,GAAG,KAAnB;AACA,UAAMC,SAAmB,GAAG,EAA5B;AACA,UAAMwC,QAAQ,GAAGhQ,UAAU,CAACb,GAAX,CAAe,MAAO7C,SAAP,IAAqB;AACnDkR,MAAAA,SAAS,CAACrK,IAAV,CAAe7G,SAAS,CAACM,EAAV,CAAaE,OAAb,CAAqB4D,QAArB,EAAf;AACA,YAAMwN,SAAS,GAAG,KAAKC,uBAAL,CAA6B7R,SAA7B,CAAlB;AACA,YAAM8R,OAAO,GAAG,MAAMtG,mBAAGuG,UAAH,CAAcH,SAAd,CAAtB;;AACA,UAAI,CAACE,OAAL,EAAc;AACZb,QAAAA,YAAY,GAAG,IAAf;AACD;;AAED,YAAM0C,WAAW,GAAG,YAAY;AAC9B;AACA,cAAMhD,MAAM,GAAGiD,OAAO,CAAChC,SAAD,CAAtB,CAF8B,CAG9B;;;AACA,cAAMK,WAAW,GAAG,MAAM,KAAKzU,YAAL,CAAkB0U,cAAlB,CAAiClS,SAAjC,EAA4C4R,SAA5C,EAAuDiC,mBAAYnU,IAAnE,CAA1B,CAJ8B,CAK9B;;AACA,YAAIuS,WAAJ,EAAiB2B,OAAO,CAAC3B,WAAD,CAAP;AACjB,eAAOtB,MAAP;AACD,OARD;;AASA,aAAO,KAAImD,sCAAJ,EAAyB9T,SAAzB,EAAoC2T,WAApC,CAAP;AACD,KAlBgB,CAAjB;AAmBA,UAAMI,QAAQ,GAAG,MAAMlP,OAAO,CAACC,GAAR,CAAY4O,QAAZ,CAAvB,CAtBgF,CAuBhF;;AACA,QAAIzC,YAAJ,EAAkB;AAChB,YAAM,sBAAKC,SAAL,EAAgB,KAAhB,CAAN;AACD;;AACD,WAAO6C,QAAP;AACD;;AAEmC,QAAtBC,sBAAsB,CAACxS,GAAD,EAAqB;AACvD,UAAMkC,UAAU,GAAGlC,GAAG,CAAC3B,MAAJ,GAAa,MAAM,KAAK6B,OAAL,CAAaF,GAAb,CAAnB,GAAuC,MAAM,KAAKL,IAAL,EAAhE;AACA,WAAO8S,0BAAaC,EAAb,CAAwBxQ,UAAxB,EAAqC1D,SAAD,IAAe,KAAKuI,YAAL,CAAkBvI,SAAS,CAACM,EAA5B,CAAnD,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACe,QAAP6T,OAAO,CAACC,QAAD,EAAsBhM,OAAtB,EAAyD;AAAA;;AACpE,QAAIgM,QAAQ,IAAIA,QAAQ,CAACvU,MAAzB,EAAiC;AAC/B,UAAI,EAACuI,OAAD,aAACA,OAAD,eAACA,OAAO,CAAE7K,QAAV,KAAsB,CAAA6K,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEiM,aAAT,MAA2B,KAArD,EAA4D;AAC1D,cAAM,KAAIC,iDAAJ,EAAuClM,OAAvC,aAAuCA,OAAvC,uBAAuCA,OAAO,CAAEiM,aAAhD,CAAN;AACD;;AACD,WAAK5W,MAAL,CAAY4H,KAAZ,CAAmB,sCAAqC+O,QAAQ,CAACpV,IAAT,EAAgB,EAAxE;AACA,YAAMuV,QAAQ,GAAG,KAAKjX,kBAAL,CAAwBkX,kBAAxB,EAAjB;AACA,YAAMC,iBAAiB,GAAGL,QAAQ,CAACvR,GAAT,CAAc6R,WAAD,IACrCH,QAAQ,CAACI,oBAAT,CAA8BD,WAA9B,EAA2C;AACzChK,QAAAA,OAAO,EAAE,KAAK7L;AAD2B,OAA3C,CADwB,CAA1B;AAKA,YAAM+V,gBAAgB,GAAG,MAAM/P,OAAO,CAACC,GAAR,CAAY2P,iBAAZ,CAA/B;AACA,YAAMI,yBAAiD,GAAG,EAA1D;AACAD,MAAAA,gBAAgB,CAACE,OAAjB,CAA0BC,eAAD,IAAqB;AAC5C,YAAIA,eAAe,CAACC,OAApB,EAA6B;AAC3B,gBAAMC,iBAAiB,GAAG,KAAK3X,kBAAL,CAAwB4X,wBAAxB,CACxBH,eAAe,CAACC,OADQ,EAExB5M,OAFwB,aAExBA,OAFwB,uBAExBA,OAAO,CAAE+M,UAFe,CAA1B;AAIAN,UAAAA,yBAAyB,CAAChO,IAA1B,CAA+B;AAC7BuO,YAAAA,YAAY,EAAEL,eAAe,CAACL,WADD;AAE7BW,YAAAA,KAAK,EAAE;AACLL,cAAAA,OAAO,EAAEC;AADJ,aAFsB;AAK7BZ,YAAAA,aAAa,EAAE,CAAAjM,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEiM,aAAT,KAA0B;AALZ,WAA/B;AAOD;AACF,OAdD;;AAeA,UAAI,EAACjM,OAAD,aAACA,OAAD,eAACA,OAAO,CAAE7K,QAAV,CAAJ,EAAwB;AAAA;;AACtB,aAAKD,kBAAL,CAAwBgY,eAAxB,CAAwCT,yBAAxC,EAAmE;AACjEU,UAAAA,cAAc,2BAAEnN,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEmN,cAAX,yEAA6B;AADsB,SAAnE;AAGD,OAJD,MAIO,CACL;AACD;;AACD,YAAM,KAAKjY,kBAAL,CAAwBkY,aAAxB,CAAsC,KAAK3W,IAA3C,CAAN;AACD;;AACD,QAAIuJ,OAAJ,aAAIA,OAAJ,eAAIA,OAAO,CAAE4B,MAAb,EAAqB;AACnB,WAAKvM,MAAL,CAAYgY,aAAZ,CAA0B,2BAA1B;AACA,YAAM,KAAKC,aAAL,EAAN;AACA,WAAKjY,MAAL,CAAYkY,cAAZ;AACD;;AACD,SAAKlY,MAAL,CAAYmY,OAAZ,CACG,8CAA6CC,iBAAMC,IAAN,CAAW,KAAKxY,kBAAL,CAAwByY,qBAAxB,EAAX,CAA4D,EAD5G;AAGA,SAAKtY,MAAL,CAAY4H,KAAZ,CAAmB,mDAAnB,EAAuE+C,OAAvE;AACA,SAAKlC,UAAL,GA/CoE,CAgDpE;;AACA,UAAM8P,SAAS,GAAG,KAAK1Y,kBAAL,CAAwB2Y,YAAxB,CAAqC,EAArC,CAAlB;AACA,UAAMC,UAAU,GAAG,MAAM,KAAKlC,sBAAL,CAA4B,EAA5B,CAAzB;AACA,UAAMmC,gBAAgB,GAAG,KAAK7Y,kBAAL,CAAwB8Y,kBAAxB,EAAzB;AAEA,UAAMC,YAAY,GAAG,MAAM,KAAKC,sCAAL,EAA3B;AAEA,UAAMC,gBAA8C,GAAG;AACrDC,MAAAA,MAAM,EAAEpO,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEoO,MADoC;AAErDC,MAAAA,uBAAuB,2BAAErO,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEqO,uBAAX,yEAAsC,IAFR;AAGrDC,MAAAA,6BAA6B,4BAAEtO,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEsO,6BAAX,2EAA4C,KAHpB;AAIrDC,MAAAA,kBAAkB,EAAEN;AAJiC,KAAvD;AAMA,UAAML,SAAS,CAAC7B,OAAV,CAAkB,KAAKtV,IAAvB,EAA6BsX,gBAA7B,EAA+CD,UAA/C,EAA2D;AAAEU,MAAAA,iBAAiB,EAAE;AAArB,KAA3D,EAAyFL,gBAAzF,CAAN,CA7DoE,CA8DpE;AACA;AACA;;AACA,UAAM,KAAKM,IAAL,CAAU;AACdC,MAAAA,cAAc,EAAE,IADF;AAEdC,MAAAA,UAAU,EAAE,IAFE;AAGdC,MAAAA,eAAe,EAAE,IAHH;AAIdC,MAAAA,kBAAkB,EAAE,CAAC,KAAKvY;AAJZ,KAAV,CAAN;AAMA,UAAM,KAAKxB,QAAL,CAAcqN,gBAAd,CAA+B2M,8BAA/B,EAAN;AACA,WAAOhB,UAAP;AACD;;AAES,QAAJW,IAAI,CAACzO,OAAD,EAAuD;AAC/D,UAAM8N,UAAU,GAAG,MAAM,KAAKlC,sBAAL,CAA4B,EAA5B,CAAzB;AACA,UAAMmC,gBAAgB,GAAG,KAAK7Y,kBAAL,CAAwB8Y,kBAAxB,EAAzB;AACA,UAAMe,MAAM,GAAG,KAAK7Z,kBAAL,CAAwB8Z,SAAxB,CAAkC;AAC/C1M,MAAAA,OAAO,EAAE,KAAK7L,IADiC;AAE/CwY,MAAAA,cAAc,EAAEjP;AAF+B,KAAlC,CAAf;AAIA,UAAMkP,GAAG,GAAG,MAAMH,MAAM,CAACN,IAAP,CAAY,KAAKhY,IAAjB,EAAuBsX,gBAAvB,EAAyCD,UAAzC,EAAqD9N,OAArD,CAAlB;AACA,WAAOkP,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACsD,QAAtChB,sCAAsC,GAAG;AACrD;AACA,UAAMiB,OAAO,GAAG,MAAM,KAAKpa,KAAL,CAAWqa,cAAX,EAAtB;AACA,WAAQC,cAAD,IAAoD;AACzD,YAAMC,QAAQ,GAAGD,cAAc,CAACrW,MAAf,CAAuBuW,GAAD,IAAS;AAC9C,YAAI,EAAEA,GAAG,YAAYC,yCAAjB,CAAJ,EAA2C;AACzC,iBAAO,IAAP;AACD;;AACD,YAAIL,OAAO,CAACM,KAAR,CAAcF,GAAG,CAACzV,WAAJ,CAAgB/E,KAA9B,CAAJ,EAA0C;AACxC,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD,OARgB,CAAjB;AASA,aAAOua,QAAP;AACD,KAXD;AAYD;AAED;AACF;AACA;;;AACmC,QAAnBjI,mBAAmB,CAAC7M,YAAD,EAAoD;AACnF,QAAI;AACF,aAAO,MAAM,KAAKmH,gBAAL,CAAsBnH,YAAtB,CAAb;AACD,KAFD,CAEE,OAAOsN,GAAP,EAAiB;AACjB,UAAIA,GAAG,YAAY4H,gCAAnB,EAAsC;AAAA;;AACpC,cAAM7a,MAAM,GAAG,KAAKW,OAAL,CAAaoH,GAAb,CAAyB,wBAAzB,CAAf;AACA,cAAM+S,SAAS,GAAGC,IAAI,CAACC,SAAL,CAAe,0BAAAhb,MAAM,CAACib,eAAP,gFAAwBC,GAAxB,KAA+B,EAA9C,CAAlB;;AACA,YAAIJ,SAAS,CAAC9H,QAAV,CAAmBC,GAAG,CAAC5P,EAAvB,CAAJ,EAAgC;AAC9B,gBAAM,KAAI8X,oBAAJ,EAAc,uBAAsBlI,GAAG,CAAC5P,EAAG;AAC3D,oFADgB,CAAN;AAED;AACF;;AAED,YAAM4P,GAAN;AACD;AACF,GAjlCgD,CAmlCjD;;;AAC2B,QAAbwF,aAAa,GAAG;AAC5B,UAAM2C,aAA4B,GAAG;AACnC7W,MAAAA,GAAG,EAAE,EAD8B;AAEnC8W,MAAAA,OAAO,EAAE,KAF0B;AAGnCC,MAAAA,KAAK,EAAE,KAH4B;AAInCC,MAAAA,WAAW,EAAE,IAJsB;AAKnCC,MAAAA,gBAAgB,EAAE,KALiB;AAMnC5P,MAAAA,QAAQ,EAAE,KANyB;AAOnC6P,MAAAA,UAAU,EAAE,KAPuB;AAQnCC,MAAAA,WAAW,EAAE,KARsB;AASnCC,MAAAA,kBAAkB,EAAE,KATe;AAUnCC,MAAAA,gBAAgB,EAAE,KAViB;AAWnCC,MAAAA,0BAA0B,EAAE,KAXO;AAYnCC,MAAAA,gBAAgB,EAAE;AAZiB,KAArC;;AAcA,QAAI;AACF,YAAMzB,GAAG,GAAG,MAAM,8BAAa;AAAE0B,QAAAA,MAAM,EAAE,KAAV;AAAiBC,QAAAA,QAAQ,EAAE;AAA3B,OAAb,EAAiDZ,aAAjD,EAAgE,EAAhE,CAAlB;AACA,aAAOf,GAAP;AACD,KAHD,CAGE,OAAOpH,GAAP,EAAiB;AACjB;AACA,UAAIA,GAAG,YAAYgJ,6BAAnB,EAAoC;AAClC;AACA,eAAOpP,SAAP;AACD;;AACD,YAAMoG,GAAN;AACD;AACF;AAED;AACF;AACA;AACA;;;AACuB,QAAfiJ,eAAe,GAAG;AACtB,SAAKjc,QAAL,GAAgB,MAAM,+BAAa,KAAK2B,IAAlB,EAAwB,IAAxB,CAAtB;AACA,SAAKqH,UAAL;AACD;;AAED2L,EAAAA,uBAAuB,CAAC7R,SAAD,EAA2C;AAChE,UAAM0U,WAAW,GAAG,yCAClB1U,SAAS,YAAYoZ,qBAArB,GAAyCpZ,SAAzC,GAAqDA,SAAS,CAACU,KAAV,CAAgBC,SADnD,CAApB;AAGA,WAAO9B,gBAAKG,IAAL,CAAU,KAAKD,WAAf,EAA4B2V,WAA5B,CAAP;AACD,GA9nCgD,CAgoCjD;;;AACoB,MAAhB2E,gBAAgB,GAAW;AAC7B,WAAO,KAAKpc,MAAL,CAAYoc,gBAAnB;AACD;;AAEyB,MAAtBC,sBAAsB,GAAW;AACnC,QAAI,KAAKD,gBAAL,IAAyB,CAAC,KAAKA,gBAAL,CAAsBpJ,QAAtB,CAA+B,QAA/B,CAA9B,EAAwE;AACtE,aAAQ,GAAE,KAAKoJ,gBAAiB,SAAhC;AACD;;AACD,WAAO,KAAKA,gBAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAC0B,QAAlB1U,kBAAkB,CAACrE,EAAD,EAAyD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,KAAK9C,YAAL,CAAkB+b,YAAlB,CAA+BjZ,EAAE,CAAC8D,QAAH,EAA/B,CAAJ,EAAmD;AACjD,aAAOtB,yBAAY0W,UAAZ,CAAuBlZ,EAAE,CAAC8D,QAAH,EAAvB,CAAP;AACD;;AACD,QAAIqV,QAAQ,GAAG,KAAKvc,QAAL,CAAcwc,kBAAd,CAAiCpZ,EAAE,CAAC8D,QAAH,EAAjC,EAAgD,IAAhD,EAAsD,IAAtD,CAAf;;AACA,QAAI,CAACqV,QAAL,EAAe;AACb,UAAI;AACF,cAAME,aAAa,GAAGrZ,EAAE,CAAC8D,QAAH,EAAtB;AACA,cAAM,CAACwV,gBAAD,EAAmB5E,OAAnB,IAA8B1U,EAAE,CAAC8D,QAAH,GAAcxE,KAAd,CAAoB,GAApB,CAApC;;AACA,cAAMia,SAAS,GAAG,KAAK3c,QAAL,CAAcwc,kBAAd,CAAiCE,gBAAjC,EAAmD,KAAnD,EAA0D,IAA1D,CAAlB,CAHE,CAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,YAAI,CAACC,SAAL,EAAgB;AACd,iBAAO,MAAM,KAAK1c,KAAL,CAAWwH,kBAAX,CAA8BrE,EAAE,CAAC8D,QAAH,EAA9B,CAAb;AACD;;AACD,cAAM0V,uBAAuB,GAAGD,SAAS,CAAClQ,sBAAV,EAAhC;;AACA,cAAMoQ,oBAAoB,GAAGF,SAAS,CAACG,aAAV,CAAwBhF,OAAxB,EAAiC5Q,QAAjC,EAA7B,CApCE,CAqCF;AACA;;;AACA,YAAI0V,uBAAuB,CAACG,QAAxB,CAAiCL,gBAAjC,KAAsDE,uBAAuB,KAAKF,gBAAtF,EAAwG;AACtG,iBAAO,MAAM,KAAKzc,KAAL,CAAWwH,kBAAX,CAA8BoV,oBAA9B,CAAb;AACD,SAzCC,CA0CF;AACA;;;AACA,YAAIH,gBAAgB,CAACK,QAAjB,CAA0BH,uBAA1B,KAAsDA,uBAAuB,KAAKF,gBAAtF,EAAwG;AACtG,cAAItZ,EAAE,CAAC8D,QAAH,GAAc8V,UAAd,CAAyB,KAAK/c,KAAL,CAAWuC,IAApC,CAAJ,EAA+C;AAC7C;AACA;AACA,mBAAO,MAAM,KAAKvC,KAAL,CAAWwH,kBAAX,CAA8BoV,oBAA9B,CAAb;AACD,WALqG,CAMtG;AACA;;;AACA,iBAAO,MAAM,KAAK5c,KAAL,CAAWwH,kBAAX,CAA8BgV,aAA9B,CAAb;AACD,SArDC,CAsDF;;;AACA,eAAO,MAAM,KAAKxc,KAAL,CAAWwH,kBAAX,CAA8BgV,aAA9B,CAAb;AACD,OAxDD,CAwDE,OAAOtJ,KAAP,EAAmB;AACnBoJ,QAAAA,QAAQ,GAAG7K,qBAAMC,KAAN,CAAYvO,EAAE,CAAC8D,QAAH,EAAZ,EAA2B,IAA3B,CAAX;AACA,eAAOtB,yBAAY7B,UAAZ,CAAuBwY,QAAvB,CAAP;AACD;AACF;;AACD,UAAMxN,oBAAoB,GAAG,KAAKJ,wBAAL,CAA8B4N,QAA9B,EAAwC3P,SAAxC,EAAmD;AAAE8B,MAAAA,QAAQ,EAAE;AAAZ,KAAnD,CAA7B;AACA,UAAMnN,YAAY,GAAG,MAAM,KAAK6N,4CAAL,CACzBL,oBADyB,EAEzBwN,QAAQ,CAAC1L,8BAAT,EAFyB,CAA3B;AAIA,WAAOjL,yBAAY7B,UAAZ,CAAuBwY,QAAvB,EAAiChb,YAAjC,CAAP;AACD;;AAEgC,QAA3BgD,2BAA2B,CAACD,GAAD,EAAmE;AAClG,WAAOqD,OAAO,CAACC,GAAR,CAAYtD,GAAG,CAACqB,GAAJ,CAAQ,MAAOvC,EAAP,IAAc,KAAKqE,kBAAL,CAAwBrE,EAAxB,CAAtB,CAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE6Z,EAAAA,qBAAqB,CAACnS,UAAD,EAAiD;AACpE,UAAMoS,wBAAwB,GAAGpS,UAAU,CAACnF,GAAX,CAAe,MAAOmQ,cAAP,IAA0B;AACxE,UAAIA,cAAc,CAAClM,WAAnB,EAAgC;AAC9B;AACA;AACA;AAEA;AACA,cAAMuT,UAAU,GAAG,MAAM,KAAK1V,kBAAL,CAAwBqO,cAAc,CAAClM,WAAvC,CAAzB;AACAkM,QAAAA,cAAc,CAAClM,WAAf,GAA6BuT,UAAU,CAAC7Z,OAAxC;AACD;AACF,KAVgC,CAAjC;AAWA,WAAOqE,OAAO,CAACC,GAAR,CAAYsV,wBAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,+BAA+B,CAACtS,UAAD,EAAiD;AAC9E,UAAMoS,wBAAwB,GAAGpS,UAAU,CAACnF,GAAX,CAAe,MAAOmQ,cAAP,IAA0B;AACxE,UAAIA,cAAc,CAAClM,WAAf,IAA8B,CAACkM,cAAc,CAAClM,WAAf,CAA2ByT,QAA3B,EAAnC,EAA0E;AACxE,cAAMrY,WAAW,GAAGY,yBAAY7B,UAAZ,CAAuB+R,cAAc,CAAClM,WAAtC,CAApB;;AACA,cAAMrI,YAAY,GAAG,MAAM,KAAK4N,qBAAL,CAA2BnK,WAA3B,CAA3B;AACA8Q,QAAAA,cAAc,CAAClM,WAAf,GAA6BkM,cAAc,CAAClM,WAAf,CAA2BmI,WAA3B,CAAuCxQ,YAAvC,CAA7B;AACD;AACF,KANgC,CAAjC;AAOA,WAAOoG,OAAO,CAACC,GAAR,CAAYsV,wBAAZ,CAAP;AACD;;AA9wCgD;;;eAixCpCtd,S","sourcesContent":["import chalk from 'chalk';\nimport mapSeries from 'p-map-series';\nimport type { PubsubMain } from '@teambit/pubsub';\nimport { IssuesList } from '@teambit/component-issues';\nimport type { AspectLoaderMain, AspectDefinition } from '@teambit/aspect-loader';\nimport { getAspectDef } from '@teambit/aspect-loader';\nimport { MainRuntime } from '@teambit/cli';\nimport {\n  AspectEntry,\n  ComponentMain,\n  Component,\n  ComponentFactory,\n  ComponentID,\n  ComponentMap,\n  AspectList,\n  AspectData,\n  InvalidComponent,\n} from '@teambit/component';\nimport { ComponentScopeDirMap, Config } from '@teambit/config';\nimport {\n  DependencyLifecycleType,\n  DependencyResolverMain,\n  PackageManagerInstallOptions,\n  ComponentDependency,\n  WorkspacePolicyEntry,\n  LinkingOptions,\n  LinkResults,\n  DependencyList,\n} from '@teambit/dependency-resolver';\nimport { EnvsMain, EnvsAspect, EnvServiceList, DEFAULT_ENV } from '@teambit/envs';\nimport { GraphqlMain } from '@teambit/graphql';\nimport { Harmony } from '@teambit/harmony';\nimport { IsolatorMain } from '@teambit/isolator';\nimport { Logger } from '@teambit/logger';\nimport type { ScopeMain } from '@teambit/scope';\nimport { isMatchNamespacePatternItem } from '@teambit/workspace.modules.match-pattern';\nimport { RequireableComponent } from '@teambit/harmony.modules.requireable-component';\nimport { ResolvedComponent } from '@teambit/harmony.modules.resolved-component';\nimport type { VariantsMain } from '@teambit/variants';\nimport { link, importAction } from '@teambit/legacy/dist/api/consumer';\nimport LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';\nimport { ImportOptions } from '@teambit/legacy/dist/consumer/component-ops/import-components';\nimport { NothingToImport } from '@teambit/legacy/dist/consumer/exceptions';\nimport { BitIds } from '@teambit/legacy/dist/bit-id';\nimport { BitId, InvalidScopeName, isValidScopeName } from '@teambit/legacy-bit-id';\nimport { LocalLaneId } from '@teambit/legacy/dist/lane-id/lane-id';\nimport { Consumer, loadConsumer } from '@teambit/legacy/dist/consumer';\nimport { GetBitMapComponentOptions } from '@teambit/legacy/dist/consumer/bit-map/bit-map';\nimport AddComponents from '@teambit/legacy/dist/consumer/component-ops/add-components';\nimport type {\n  AddActionResults,\n  Warnings,\n} from '@teambit/legacy/dist/consumer/component-ops/add-components/add-components';\nimport { ComponentNotFound } from '@teambit/legacy/dist/scope/exceptions';\nimport ComponentsList from '@teambit/legacy/dist/consumer/component/components-list';\nimport { NoComponentDir } from '@teambit/legacy/dist/consumer/component/exceptions/no-component-dir';\nimport { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';\nimport { buildOneGraphForComponents } from '@teambit/legacy/dist/scope/graph/components-graph';\nimport { pathIsInside } from '@teambit/legacy/dist/utils';\nimport componentIdToPackageName from '@teambit/legacy/dist/utils/bit/component-id-to-package-name';\nimport { PathOsBased, PathOsBasedRelative, PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';\nimport { BitError } from '@teambit/bit-error';\nimport fs from 'fs-extra';\nimport { slice, uniqBy, difference } from 'lodash';\nimport path from 'path';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport type { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';\nimport { ComponentConfigFile } from './component-config-file';\nimport { DependencyTypeNotSupportedInPolicy } from './exceptions';\nimport {\n  OnComponentAdd,\n  OnComponentChange,\n  OnComponentEventResult,\n  OnComponentLoad,\n  OnComponentRemove,\n  SerializableResults,\n} from './on-component-events';\nimport { WorkspaceExtConfig } from './types';\nimport { Watcher } from './watch/watcher';\nimport { ComponentStatus } from './workspace-component/component-status';\nimport {\n  OnComponentAddSlot,\n  OnComponentChangeSlot,\n  OnComponentLoadSlot,\n  OnComponentRemoveSlot,\n} from './workspace.provider';\nimport { WorkspaceComponentLoader } from './workspace-component/workspace-component-loader';\nimport { IncorrectEnvAspect } from './exceptions/incorrect-env-aspect';\n\nexport type EjectConfResult = {\n  configPath: string;\n};\n\nexport const ComponentAdded = 'componentAdded';\nexport const ComponentChanged = 'componentChanged';\nexport const ComponentRemoved = 'componentRemoved';\n\nexport interface EjectConfOptions {\n  propagate?: boolean;\n  override?: boolean;\n}\n\nexport type WorkspaceInstallOptions = {\n  variants?: string;\n  lifecycleType?: DependencyLifecycleType;\n  dedupe: boolean;\n  import: boolean;\n  copyPeerToRuntimeOnRoot?: boolean;\n  copyPeerToRuntimeOnComponents?: boolean;\n  updateExisting: boolean;\n  savePrefix?: string;\n};\n\nexport type WorkspaceLinkOptions = LinkingOptions;\n\nexport type TrackData = {\n  rootDir: PathOsBasedRelative; // path relative to the workspace\n  componentName?: string; // if empty, it'll be generated from the path\n  mainFile?: string; // if empty, attempts will be made to guess the best candidate\n};\n\nexport type TrackResult = { componentName: string; files: string[]; warnings: Warnings };\n\nconst DEFAULT_VENDOR_DIR = 'vendor';\n\n/**\n * API of the Bit Workspace\n */\nexport class Workspace implements ComponentFactory {\n  priority = true;\n  owner?: string;\n  componentsScopeDirsMap: ComponentScopeDirMap;\n  componentLoader: WorkspaceComponentLoader;\n  constructor(\n    /**\n     * private pubsub.\n     */\n    private pubsub: PubsubMain,\n\n    private config: WorkspaceExtConfig,\n    /**\n     * private access to the legacy consumer instance.\n     */\n    public consumer: Consumer,\n\n    /**\n     * access to the workspace `Scope` instance\n     */\n    readonly scope: ScopeMain,\n\n    /**\n     * access to the `ComponentProvider` instance\n     */\n    private componentAspect: ComponentMain,\n\n    private isolator: IsolatorMain,\n\n    private dependencyResolver: DependencyResolverMain,\n\n    private variants: VariantsMain,\n\n    private aspectLoader: AspectLoaderMain,\n\n    private logger: Logger,\n\n    private componentList: ComponentsList = new ComponentsList(consumer),\n\n    /**\n     * private reference to the instance of Harmony.\n     */\n    private harmony: Harmony,\n\n    /**\n     * on component load slot.\n     */\n    public onComponentLoadSlot: OnComponentLoadSlot,\n\n    /**\n     * on component change slot.\n     */\n    private onComponentChangeSlot: OnComponentChangeSlot,\n\n    private envs: EnvsMain,\n\n    /**\n     * on component add slot.\n     */\n    private onComponentAddSlot: OnComponentAddSlot,\n\n    private onComponentRemoveSlot: OnComponentRemoveSlot,\n\n    private graphql: GraphqlMain\n  ) {\n    // TODO: refactor - prefer to avoid code inside the constructor.\n    this.owner = this.config?.defaultOwner;\n    this.componentLoader = new WorkspaceComponentLoader(this, logger, dependencyResolver, envs);\n    this.validateConfig();\n  }\n\n  private validateConfig() {\n    const defaultScope = this.config.defaultScope;\n    if (this.consumer.isLegacy) return;\n    if (!defaultScope) throw new Error('defaultScope is missing');\n    if (!isValidScopeName(defaultScope)) throw new InvalidScopeName(defaultScope);\n  }\n\n  /**\n   * watcher api.\n   */\n  readonly watcher = new Watcher(this, this.pubsub);\n\n  /**\n   * root path of the Workspace.\n   */\n  get path() {\n    return this.consumer.getPath();\n  }\n\n  /** get the `node_modules` folder of this workspace */\n  private get modulesPath() {\n    return path.join(this.path, 'node_modules');\n  }\n\n  get isLegacy(): boolean {\n    return this.consumer.isLegacy;\n  }\n\n  onComponentLoad(loadFn: OnComponentLoad) {\n    this.onComponentLoadSlot.register(loadFn);\n    return this;\n  }\n\n  registerOnComponentChange(onComponentChangeFunc: OnComponentChange) {\n    this.onComponentChangeSlot.register(onComponentChangeFunc);\n    return this;\n  }\n\n  registerOnComponentAdd(onComponentAddFunc: OnComponentAdd) {\n    this.onComponentAddSlot.register(onComponentAddFunc);\n    return this;\n  }\n\n  registerOnComponentRemove(onComponentRemoveFunc: OnComponentRemove) {\n    this.onComponentRemoveSlot.register(onComponentRemoveFunc);\n    return this;\n  }\n\n  /**\n   * name of the workspace as configured in either `workspace.json`.\n   * defaults to workspace root directory name.\n   */\n  get name() {\n    if (this.config.name) return this.config.name;\n    const tokenizedPath = this.path.split('/');\n    return tokenizedPath[tokenizedPath.length - 1];\n  }\n\n  get icon() {\n    return this.config.icon;\n  }\n\n  async hasModifiedDependencies(component: Component) {\n    const componentsList = new ComponentsList(this.consumer);\n    const listAutoTagPendingComponents = await componentsList.listAutoTagPendingComponents();\n    const isAutoTag = listAutoTagPendingComponents.find((consumerComponent) =>\n      consumerComponent.id.isEqualWithoutVersion(component.id._legacy)\n    );\n    if (isAutoTag) return true;\n    return false;\n  }\n\n  /**\n   * get Component issues\n   */\n  getComponentIssues(component: Component): IssuesList | null {\n    return component.state._consumer.issues || null;\n  }\n\n  /**\n   * provides status of all components in the workspace.\n   */\n  async getComponentStatus(component: Component): Promise<ComponentStatus> {\n    const status = await this.consumer.getComponentStatusById(component.id._legacy);\n    const hasModifiedDependencies = await this.hasModifiedDependencies(component);\n    return ComponentStatus.fromLegacy(status, hasModifiedDependencies, component.isOutdated());\n  }\n\n  /**\n   * list all workspace components.\n   */\n  async list(filter?: { offset: number; limit: number }): Promise<Component[]> {\n    const legacyIds = this.consumer.bitMap.getAllIdsAvailableOnLane();\n    const ids = await this.resolveMultipleComponentIds(legacyIds);\n    return this.getMany(filter && filter.limit ? slice(ids, filter.offset, filter.offset + filter.limit) : ids);\n  }\n\n  /**\n   * list all invalid components.\n   * (see the invalid criteria in ConsumerComponent.isComponentInvalidByErrorType())\n   */\n  async listInvalid(): Promise<InvalidComponent[]> {\n    const legacyIds = this.consumer.bitMap.getAllIdsAvailableOnLane();\n    const ids = await this.resolveMultipleComponentIds(legacyIds);\n    return this.componentLoader.getInvalid(ids);\n  }\n\n  /**\n   * get ids of all workspace components.\n   */\n  async listIds(): Promise<ComponentID[]> {\n    return this.resolveMultipleComponentIds(this.consumer.bitmapIdsFromCurrentLane);\n  }\n\n  /**\n   * Check if a specific id exist in the workspace\n   * @param componentId\n   */\n  async hasId(componentId: ComponentID): Promise<boolean> {\n    const ids = await this.listIds();\n    const found = ids.find((id) => {\n      return id.isEqual(componentId);\n    });\n    return !!found;\n  }\n\n  /**\n   * whether or not a workspace has a component with the given name\n   */\n  async hasName(name: string): Promise<boolean> {\n    const ids = await this.listIds();\n    return Boolean(ids.find((id) => id.fullName === name));\n  }\n\n  /**\n   * Check if a specific id exist in the workspace or in the scope\n   * @param componentId\n   */\n  async hasIdNested(componentId: ComponentID, includeCache = true): Promise<boolean> {\n    const found = await this.hasId(componentId);\n    if (found) return found;\n    return this.scope.hasIdNested(componentId, includeCache);\n  }\n\n  /**\n   * list all modified components in the workspace.\n   */\n  async modified() {\n    const ids: any = await this.componentList.listModifiedComponents(false);\n    const componentIds = ids.map(ComponentID.fromLegacy);\n    return this.getMany(componentIds);\n  }\n\n  /**\n   * list all new components in the workspace.\n   */\n  async newComponents() {\n    const ids: any = await this.componentList.listNewComponents(false);\n    const componentIds = ids.map(ComponentID.fromLegacy);\n    return this.getMany(componentIds);\n  }\n\n  /**\n   * get all workspace component-ids, include vendor components.\n   * (exclude nested dependencies in case dependencies are saved as components and not packages)\n   */\n  getAllComponentIds(): Promise<ComponentID[]> {\n    const bitIds = this.consumer.bitMap.getAuthoredAndImportedBitIds();\n    return this.resolveMultipleComponentIds(bitIds);\n  }\n\n  async getNewAndModifiedIds(): Promise<ComponentID[]> {\n    const ids = await this.componentList.listTagPendingComponents();\n    return this.resolveMultipleComponentIds(ids);\n  }\n\n  async getLogs(id: ComponentID): Promise<ComponentLog[]> {\n    return this.scope.getLogs(id);\n  }\n\n  async getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph> {\n    if (!ids || ids.length < 1) ids = await this.listIds();\n\n    const legacyIds = ids.map((id) => id._legacy);\n\n    const legacyGraph = await buildOneGraphForComponents(legacyIds, this.consumer);\n    return legacyGraph;\n  }\n\n  async loadCapsules(bitIds: string[]) {\n    // throw new Error(\"Method not implemented.\");\n    const components = await this.load(bitIds);\n    return components.map((comp) => comp.capsule);\n  }\n  /**\n   * fully load components, including dependency resolution and prepare them for runtime.\n   * @todo: remove the string option, use only BitId\n   */\n  async load(ids: Array<BitId | string>): Promise<ResolvedComponent[]> {\n    const componentIds = await this.resolveMultipleComponentIds(ids);\n    const components = await this.getMany(componentIds);\n    const network = await this.isolator.isolateComponents(components.map((c) => c.id));\n    const resolvedComponents = components.map((component) => {\n      const capsule = network.graphCapsules.getCapsule(component.id);\n      if (!capsule) throw new Error(`unable to find capsule for ${component.id.toString()}`);\n      return new ResolvedComponent(component, capsule);\n    });\n    return resolvedComponents;\n  }\n\n  public async createAspectList(extensionDataList: ExtensionDataList) {\n    const entiresP = extensionDataList.map(async (entry) => {\n      return new AspectEntry(await this.resolveComponentId(entry.id), entry);\n    });\n\n    const entries: AspectEntry[] = await Promise.all(entiresP);\n    return this.componentAspect.createAspectListFromEntries(entries);\n  }\n\n  /**\n   * get a component from workspace\n   * @param id component ID\n   */\n  async get(\n    componentId: ComponentID,\n    forCapsule = false,\n    legacyComponent?: ConsumerComponent,\n    useCache = true,\n    storeInCache = true\n  ): Promise<Component> {\n    this.logger.debug(`get ${componentId.toString()}`);\n    return this.componentLoader.get(componentId, forCapsule, legacyComponent, useCache, storeInCache);\n  }\n\n  // TODO: @gilad we should refactor this asap into to the envs aspect.\n  async getEnvSystemDescriptor(component: Component): Promise<AspectData> {\n    const env = this.envs.calculateEnv(component);\n    if (env.env.__getDescriptor && typeof env.env.__getDescriptor === 'function') {\n      const systemDescriptor = await env.env.__getDescriptor();\n      // !important persist services only on the env itself.\n      let services: undefined | EnvServiceList;\n      if (this.envs.isEnvRegistered(component.id.toString())) services = this.envs.getServices(env);\n      const icon = this.aspectLoader.getDescriptor(env.id).icon || env.env.icon;\n\n      return {\n        type: systemDescriptor.type,\n        id: env.id,\n        name: env.name,\n        icon,\n        description: env.description,\n        services: services?.toObject(),\n      };\n    }\n\n    return {};\n  }\n\n  clearCache() {\n    this.logger.debug('clearing the workspace and scope caches');\n    this.componentLoader.clearCache();\n    this.scope.clearCache();\n    this.componentList = new ComponentsList(this.consumer);\n  }\n\n  clearComponentCache(id: ComponentID) {\n    this.componentLoader.clearComponentCache(id);\n    this.consumer.componentLoader.clearOneComponentCache(id._legacy);\n    this.componentList = new ComponentsList(this.consumer);\n  }\n\n  async triggerOnComponentChange(id: ComponentID): Promise<OnComponentEventResult[]> {\n    const component = await this.get(id);\n    // if a new file was added, upon component-load, its .bitmap entry is updated to include the\n    // new file. write these changes to the .bitmap file so then other processes have access to\n    // this new file. If the .bitmap wasn't change, it won't do anything.\n    await this.writeBitMap();\n    const onChangeEntries = this.onComponentChangeSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]\n    const results: Array<{ extensionId: string; results: SerializableResults }> = [];\n    await mapSeries(onChangeEntries, async ([extension, onChangeFunc]) => {\n      const onChangeResult = await onChangeFunc(component);\n      results.push({ extensionId: extension, results: onChangeResult });\n    });\n\n    // TODO: find way to standardize event names.\n    await this.graphql.pubsub.publish(ComponentChanged, { componentChanged: { component } });\n    return results;\n  }\n\n  async triggerOnComponentAdd(id: ComponentID): Promise<OnComponentEventResult[]> {\n    const component = await this.get(id);\n    const onAddEntries = this.onComponentAddSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]\n    const results: Array<{ extensionId: string; results: SerializableResults }> = [];\n    await mapSeries(onAddEntries, async ([extension, onAddFunc]) => {\n      const onAddResult = await onAddFunc(component);\n      results.push({ extensionId: extension, results: onAddResult });\n    });\n\n    await this.graphql.pubsub.publish(ComponentAdded, { componentAdded: { component } });\n    return results;\n  }\n\n  async triggerOnComponentRemove(id: ComponentID): Promise<OnComponentEventResult[]> {\n    const onRemoveEntries = this.onComponentRemoveSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onComponentChange] ] ]\n    const results: Array<{ extensionId: string; results: SerializableResults }> = [];\n    await mapSeries(onRemoveEntries, async ([extension, onRemoveFunc]) => {\n      const onRemoveResult = await onRemoveFunc(id);\n      results.push({ extensionId: extension, results: onRemoveResult });\n    });\n\n    await this.graphql.pubsub.publish(ComponentRemoved, { componentRemoved: { componentIds: [id.toObject()] } });\n    return results;\n  }\n\n  getState(id: ComponentID, hash: string) {\n    return this.scope.getState(id, hash);\n  }\n\n  getSnap(id: ComponentID, hash: string) {\n    return this.scope.getSnap(id, hash);\n  }\n\n  getCurrentLaneId(): LocalLaneId {\n    return this.consumer.getCurrentLaneId();\n  }\n\n  getDefaultExtensions(): ExtensionDataList {\n    if (!this.config.extensions) {\n      return new ExtensionDataList();\n    }\n    return ExtensionDataList.fromConfigObject(this.config.extensions);\n  }\n\n  async ejectConfig(id: ComponentID, options: EjectConfOptions): Promise<EjectConfResult> {\n    const componentId = await this.resolveComponentId(id);\n    const component = await this.scope.get(componentId);\n    const aspects = component?.state.aspects\n      ? await this.resolveScopeAspectListIds(component?.state.aspects)\n      : await this.createAspectList(new ExtensionDataList());\n\n    const componentDir = this.componentDir(id, { ignoreVersion: true });\n    const componentConfigFile = new ComponentConfigFile(componentId, aspects, options.propagate);\n    await componentConfigFile.write(componentDir, { override: options.override });\n    return {\n      configPath: ComponentConfigFile.composePath(componentDir),\n    };\n  }\n\n  private async resolveScopeAspectListIds(aspectListFromScope: AspectList): Promise<AspectList> {\n    const resolvedList = await aspectListFromScope.pmap(async (entry) => {\n      if (entry.id.scope !== this.scope.name) {\n        return entry;\n      }\n      const newId = await this.resolveComponentId(entry.id.fullName);\n      const newEntry = new AspectEntry(newId, entry.legacy);\n      return newEntry;\n    });\n    return resolvedList;\n  }\n\n  /**\n   * load components into the workspace through a variants pattern.\n   * @param pattern variants.\n   * @param scope scope name.\n   */\n  async byPattern(pattern: string, scope = '**'): Promise<Component[]> {\n    const ids = await this.listIds();\n    const finalPattern = `${scope}/${pattern || '**'}`;\n    const targetIds = ids.filter((id) => {\n      const spec = isMatchNamespacePatternItem(id.toStringWithoutVersion(), finalPattern);\n      return spec.match;\n    });\n\n    const components = await this.getMany(targetIds);\n    return components;\n  }\n\n  async getMany(ids: Array<ComponentID>, forCapsule = false): Promise<Component[]> {\n    return this.componentLoader.getMany(ids, forCapsule);\n  }\n\n  getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]> {\n    return mapSeries(components, async (component) => {\n      const id = await this.resolveComponentId(component.id);\n      return this.get(id, undefined, component);\n    });\n  }\n\n  /**\n   * This will make sure to fetch the objects prior to load them\n   * do not use it if you are not sure you need it.\n   * It will influence the performance\n   * currently it used only for get many of aspects\n   * @param ids\n   * @param forCapsule\n   */\n  async importAndGetMany(ids: Array<ComponentID>, forCapsule = false): Promise<Component[]> {\n    await this.scope.import(ids);\n    return this.componentLoader.getMany(ids, forCapsule);\n  }\n\n  /**\n   * @deprecated use this.track() instead\n   * track a new component. (practically, add it to .bitmap).\n   *\n   * @param componentPaths component paths relative to the workspace dir\n   * @param id if not set, will be concluded from the filenames\n   * @param main if not set, will try to guess according to some strategies and throws if failed\n   * @param override whether add details to an existing component or re-define it\n   */\n  async add(\n    componentPaths: PathOsBasedRelative[],\n    id?: string,\n    main?: string,\n    override = false\n  ): Promise<AddActionResults> {\n    const addComponent = new AddComponents({ consumer: this.consumer }, { componentPaths, id, main, override });\n    const addResults = await addComponent.add();\n    // @todo: the legacy commands have `consumer.onDestroy()` on command completion, it writes the\n    //  .bitmap file. workspace needs a similar mechanism. once done, remove the next line.\n    await this.consumer.bitMap.write(this.consumer.componentFsCache);\n    return addResults;\n  }\n\n  /**\n   * add a new component to the .bitmap file.\n   * this method only adds the records in memory but doesn't persist to the filesystem.\n   * to write the .bitmap file once completed, run \"await this.writeBitMap();\"\n   */\n  async track(trackData: TrackData): Promise<TrackResult> {\n    const addComponent = new AddComponents(\n      { consumer: this.consumer },\n      { componentPaths: [trackData.rootDir], id: trackData.componentName, main: trackData.mainFile, override: false }\n    );\n    const result = await addComponent.add();\n    const addedComponent = result.addedComponents[0];\n    const componentName = addedComponent?.id.name || (trackData.componentName as string);\n    const files = addedComponent?.files.map((f) => f.relativePath) || [];\n    return { componentName, files, warnings: result.warnings };\n  }\n\n  async write(rootPath: string, component: Component) {\n    await Promise.all(\n      component.filesystem.files.map(async (file) => {\n        const pathToWrite = path.join(this.path, rootPath, file.path);\n        await fs.outputFile(pathToWrite, file.contents);\n      })\n    );\n  }\n\n  async writeBitMap() {\n    await this.consumer.writeBitMap();\n  }\n\n  /**\n   * Get the component root dir in the file system (relative to workspace or full)\n   * @param componentId\n   * @param relative return the path relative to the workspace or full path\n   */\n  componentDir(\n    componentId: ComponentID,\n    bitMapOptions?: GetBitMapComponentOptions,\n    options = { relative: false }\n  ): PathOsBased {\n    return this.componentDirFromLegacyId(componentId._legacy, bitMapOptions, options);\n  }\n\n  private componentDirFromLegacyId(\n    bitId: BitId,\n    bitMapOptions?: GetBitMapComponentOptions,\n    options = { relative: false }\n  ): PathOsBased {\n    const componentMap = this.consumer.bitMap.getComponent(bitId, bitMapOptions);\n    const relativeComponentDir = componentMap.getComponentDir();\n    if (!relativeComponentDir) {\n      throw new NoComponentDir(bitId.toString());\n    }\n    if (options.relative) {\n      return relativeComponentDir;\n    }\n\n    return path.join(this.path, relativeComponentDir);\n  }\n\n  componentDirToAbsolute(relativeComponentDir: PathOsBasedRelative): PathOsBasedAbsolute {\n    return path.join(this.path, relativeComponentDir);\n  }\n\n  async componentDefaultScope(componentId: ComponentID): Promise<string | undefined> {\n    const relativeComponentDir = this.componentDir(componentId, { ignoreVersion: true }, { relative: true });\n    return this.componentDefaultScopeFromComponentDirAndName(relativeComponentDir, componentId.fullName);\n  }\n\n  async componentDefaultScopeFromComponentDirAndName(\n    relativeComponentDir: PathOsBasedRelative,\n    name: string\n  ): Promise<string | undefined> {\n    const componentConfigFile = await this.componentConfigFileFromComponentDirAndName(relativeComponentDir, name);\n    if (componentConfigFile && componentConfigFile.defaultScope) {\n      return componentConfigFile.defaultScope;\n    }\n    return this.componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(relativeComponentDir, name);\n  }\n\n  get defaultScope() {\n    return this.config.defaultScope;\n  }\n\n  private async componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(\n    relativeComponentDir: PathOsBasedRelative,\n    name: string\n  ): Promise<string | undefined> {\n    const variantConfig = this.variants.byRootDirAndName(relativeComponentDir, name);\n    if (variantConfig && variantConfig.defaultScope) {\n      return variantConfig.defaultScope;\n    }\n    const isVendor = this.isVendorComponentByComponentDir(relativeComponentDir);\n    if (!isVendor) {\n      return this.config.defaultScope;\n    }\n    return undefined;\n  }\n\n  /**\n   * Calculate the component config based on:\n   * the component.json file in the component folder\n   * matching pattern in the variants config\n   * defaults extensions from workspace config\n   *\n   * @param {ComponentID} componentId\n   * @param {Component} [componentFromScope]\n   * @returns {Promise<ExtensionDataList>}\n   * @memberof Workspace\n   */\n  async componentExtensions(componentId: ComponentID, componentFromScope?: Component): Promise<ExtensionDataList> {\n    // TODO: consider caching this result\n    let configFileExtensions;\n    let variantsExtensions;\n    let wsDefaultExtensions;\n    const mergeFromScope = true;\n    const scopeExtensions = componentFromScope?.config?.extensions || new ExtensionDataList();\n\n    const componentConfigFile = await this.componentConfigFile(componentId);\n    if (componentConfigFile) {\n      configFileExtensions = componentConfigFile.aspects.toLegacy();\n      // do not merge from scope data when there is component config file\n      // mergeFromScope = false;\n    }\n    const relativeComponentDir = this.componentDir(componentId, { ignoreVersion: true }, { relative: true });\n    const variantConfig = this.variants.byRootDirAndName(relativeComponentDir, componentId.fullName);\n    if (variantConfig) {\n      variantsExtensions = variantConfig.extensions;\n      // Do not merge from scope when there is specific variant (which is not *) that match the component\n      // if (variantConfig.maxSpecificity > 0) {\n      //   mergeFromScope = false;\n      // }\n    }\n    const isVendor = this.isVendorComponentByComponentDir(relativeComponentDir);\n    if (!isVendor) {\n      wsDefaultExtensions = this.getDefaultExtensions();\n    }\n    // We don't stop on each step because we want to merge the default scope even if propagate=false but the default scope is not defined\n    const extensionsToMerge: ExtensionDataList[] = [];\n    if (configFileExtensions) {\n      extensionsToMerge.push(configFileExtensions);\n    }\n    let continuePropagating = componentConfigFile?.propagate ?? true;\n    if (variantsExtensions && continuePropagating) {\n      // Put it in the start to make sure the config file is stronger\n      extensionsToMerge.push(variantsExtensions);\n    }\n    continuePropagating = continuePropagating && (variantConfig?.propagate ?? true);\n    // Do not apply default extensions on the default extensions (it will create infinite loop when loading them)\n    const isDefaultExtension = wsDefaultExtensions.findExtension(componentId.toString(), true, true);\n    if (wsDefaultExtensions && continuePropagating && !isDefaultExtension) {\n      // Put it in the start to make sure the config file is stronger\n      extensionsToMerge.push(wsDefaultExtensions);\n    }\n\n    // It's before the scope extensions, since there is no need to resolve extensions from scope they are already resolved\n    // await Promise.all(extensionsToMerge.map((extensions) => this.resolveExtensionsList(extensions)));\n\n    if (mergeFromScope && continuePropagating) {\n      extensionsToMerge.push(scopeExtensions);\n    }\n\n    // It's important to do this resolution before the merge, otherwise we have issues with extensions\n    // coming from scope with local scope name, as opposed to the same extension comes from the workspace with default scope name\n    const promises = extensionsToMerge.map((list) => this.resolveExtensionListIds(list));\n    await Promise.all(promises);\n\n    let mergedExtensions = ExtensionDataList.mergeConfigs(extensionsToMerge).filterRemovedExtensions();\n\n    // remove self from merged extensions\n    const selfInMergedExtensions = mergedExtensions.findExtension(\n      componentId._legacy.toStringWithoutScopeAndVersion(),\n      true,\n      true\n    );\n    if (selfInMergedExtensions && selfInMergedExtensions.extensionId) {\n      mergedExtensions = mergedExtensions.remove(selfInMergedExtensions.extensionId);\n    }\n\n    return mergedExtensions;\n  }\n\n  /**\n   * This will mutate the entries with extensionId prop to have resolved legacy id\n   * This should be worked on the extension data list not the new aspect list\n   * @param extensionList\n   */\n  private async resolveExtensionListIds(extensionList: ExtensionDataList): Promise<ExtensionDataList> {\n    const promises = extensionList.map(async (entry) => {\n      if (entry.extensionId) {\n        const id = await this.resolveComponentId(entry.extensionId);\n        entry.extensionId = id._legacy;\n      }\n\n      return entry;\n    });\n    await Promise.all(promises);\n    return extensionList;\n  }\n\n  private isVendorComponentByComponentDir(relativeComponentDir: PathOsBasedRelative): boolean {\n    const vendorDir = this.config.vendor?.directory || DEFAULT_VENDOR_DIR;\n    if (pathIsInside(relativeComponentDir, vendorDir)) {\n      return true;\n    }\n    // TODO: implement\n    return false;\n  }\n\n  /**\n   * return the component config from its folder (component.json)\n   * @param componentId\n   */\n  private async componentConfigFile(id: ComponentID): Promise<ComponentConfigFile | undefined> {\n    const relativeComponentDir = this.componentDir(id, { ignoreVersion: true }, { relative: true });\n    return this.componentConfigFileFromComponentDirAndName(relativeComponentDir, id.fullName);\n  }\n\n  private async componentConfigFileFromComponentDirAndName(\n    relativeComponentDir: PathOsBasedRelative,\n    name: string\n  ): Promise<ComponentConfigFile | undefined> {\n    let componentConfigFile;\n    if (relativeComponentDir) {\n      const absComponentDir = this.componentDirToAbsolute(relativeComponentDir);\n      const defaultScopeFromVariantsOrWs = await this.componentDefaultScopeFromComponentDirAndNameWithoutConfigFile(\n        relativeComponentDir,\n        name\n      );\n      componentConfigFile = await ComponentConfigFile.load(\n        absComponentDir,\n        this.createAspectList.bind(this),\n        defaultScopeFromVariantsOrWs\n      );\n    }\n\n    return componentConfigFile;\n  }\n\n  async getGraphWithoutCore(components: Component[]) {\n    const ids = components.map((component) => component.id._legacy);\n    const coreAspectsStringIds = this.aspectLoader.getCoreAspectIds();\n    const coreAspectsComponentIds = coreAspectsStringIds.map((id) => BitId.parse(id, true));\n    const coreAspectsBitIds = BitIds.fromArray(coreAspectsComponentIds.map((id) => id.changeScope(null)));\n    // const aspectsIds = components.reduce((acc, curr) => {\n    //   const currIds = curr.state.aspects.ids;\n    //   acc = acc.concat(currIds);\n    //   return acc;\n    // }, [] as any);\n    // const otherDependenciesMap = components.reduce((acc, curr) => {\n    //   // const currIds = curr.state.dependencies.dependencies.map(dep => dep.id.toString());\n    //   const currMap = curr.state.dependencies.getIdsMap();\n    //   Object.assign(acc, currMap);\n    //   return acc;\n    // }, {});\n\n    // const depsWhichAreNotAspects = difference(Object.keys(otherDependenciesMap), aspectsIds);\n    // const depsWhichAreNotAspectsBitIds = depsWhichAreNotAspects.map((strId) => otherDependenciesMap[strId]);\n    // We only want to load into the graph components which are aspects and not regular dependencies\n    // This come to solve a circular loop when an env aspect use an aspect (as regular dep) and the aspect use the env aspect as its env\n    // TODO: @gilad it causes many issues we need to find a better solution. removed for now.\n    const ignoredIds = coreAspectsBitIds.concat([]);\n    return buildOneGraphForComponents(ids, this.consumer, undefined, BitIds.fromArray(ignoredIds));\n  }\n\n  /**\n   * load aspects from the workspace and if not exists in the workspace, load from the scope.\n   * keep in mind that the graph may have circles.\n   */\n  async loadAspects(ids: string[] = [], throwOnError = false): Promise<void> {\n    this.logger.debug(`loading ${ids.length} aspects`);\n    const notLoadedIds = ids.filter((id) => !this.aspectLoader.isAspectLoaded(id));\n    if (!notLoadedIds.length) return;\n    const coreAspectsStringIds = this.aspectLoader.getCoreAspectIds();\n    const idsWithoutCore: string[] = difference(notLoadedIds, coreAspectsStringIds);\n    const componentIds = await this.resolveMultipleComponentIds(idsWithoutCore);\n    const components = await this.importAndGetAspects(componentIds);\n    const graph = await this.getGraphWithoutCore(components);\n    const allIdsP = graph.nodes().map(async (id) => {\n      return this.resolveComponentId(id);\n    });\n    const allIds = await Promise.all(allIdsP);\n    const allComponents = await this.getMany(allIds as ComponentID[]);\n\n    const aspects = allComponents.filter((component: Component) => {\n      let data = component.config.extensions.findExtension(EnvsAspect.id)?.data;\n      if (!data) {\n        // TODO: remove this once we re-export old components used to store the data here\n        data = component.state.aspects.get('teambit.workspace/workspace');\n      }\n\n      if (!data) return false;\n      if (data.type !== 'aspect' && idsWithoutCore.includes(component.id.toString())) {\n        const err = new IncorrectEnvAspect(component.id.toString(), data.type, data.id);\n        if (data.id === DEFAULT_ENV) {\n          // when cloning a project, or when the node-modules dir is deleted, nothing works and all\n          // components are default to the DEFAULT_ENV, which is node-env. we must allow \"bit\n          // install\" to prepare the workspace and let the proper the envs to be loaded\n          this.logger.error(err.message);\n        } else {\n          throw err;\n        }\n      }\n      return data.type === 'aspect';\n    });\n    // no need to filter core aspects as they are not included in the graph\n    // here we are trying to load extensions from the workspace.\n    const { workspaceComps, scopeComps } = await this.groupComponentsByWorkspaceAndScope(aspects);\n    // load the scope first because we might need it for custom envs that extend external aspects\n    const scopeIds = scopeComps.map((aspect) => aspect.id.toString());\n    await this.scope.loadAspects(scopeIds, throwOnError);\n\n    const workspaceAspects = await this.requireComponents(workspaceComps);\n    await this.aspectLoader.loadRequireableExtensions(workspaceAspects, throwOnError);\n  }\n\n  async resolveAspects(runtimeName?: string, componentIds?: ComponentID[]): Promise<AspectDefinition[]> {\n    let missingPaths = false;\n    const stringIds: string[] = [];\n    const idsToResolve = componentIds ? componentIds.map((id) => id.toString()) : this.harmony.extensionsIds;\n    const coreAspectsIds = this.aspectLoader.getCoreAspectIds();\n    const userAspectsIds: string[] = difference(idsToResolve, coreAspectsIds);\n    const componentIdsToResolve = await this.resolveMultipleComponentIds(userAspectsIds);\n    const { workspaceIds, scopeIds } = await this.groupIdsByWorkspaceAndScope(componentIdsToResolve);\n    const wsComponents = await this.getMany(workspaceIds);\n    const aspectDefs = await this.aspectLoader.resolveAspects(wsComponents, async (component) => {\n      stringIds.push(component.id._legacy.toString());\n      const localPath = this.getComponentPackagePath(component.state._consumer);\n      const isExist = await fs.pathExists(localPath);\n      if (!isExist) {\n        missingPaths = true;\n      }\n\n      return {\n        aspectPath: localPath,\n        runtimePath: runtimeName ? await this.aspectLoader.getRuntimePath(component, localPath, runtimeName) : null,\n      };\n    });\n\n    let scopeAspectDefs: AspectDefinition[] = [];\n    if (scopeIds.length) {\n      scopeAspectDefs = await this.scope.resolveAspects(runtimeName, scopeIds);\n    }\n\n    let coreAspectDefs = await Promise.all(\n      coreAspectsIds.map(async (coreId) => {\n        const rawDef = await getAspectDef(coreId, runtimeName);\n        return this.aspectLoader.loadDefinition(rawDef);\n      })\n    );\n\n    // due to lack of workspace and scope runtimes. TODO: fix after adding them.\n    if (runtimeName) {\n      coreAspectDefs = coreAspectDefs.filter((coreAspect) => {\n        return coreAspect.runtimePath;\n      });\n    }\n\n    if (missingPaths) {\n      await link(stringIds, false);\n    }\n\n    const allDefs = aspectDefs.concat(coreAspectDefs).concat(scopeAspectDefs);\n    const uniqDefs = uniqBy(allDefs, (def) => `${def.aspectPath}-${def.runtimePath}`);\n    let defs = uniqDefs;\n    if (runtimeName) {\n      defs = defs.filter((def) => def.runtimePath);\n    }\n\n    return defs;\n  }\n\n  private async groupIdsByWorkspaceAndScope(\n    ids: ComponentID[]\n  ): Promise<{ workspaceIds: ComponentID[]; scopeIds: ComponentID[] }> {\n    const workspaceIds: ComponentID[] = [];\n    const scopeIds: ComponentID[] = [];\n    await Promise.all(\n      ids.map(async (id) => {\n        const existOnWorkspace = await this.hasId(id);\n        existOnWorkspace ? workspaceIds.push(id) : scopeIds.push(id);\n      })\n    );\n    return { workspaceIds, scopeIds };\n  }\n\n  private async groupComponentsByWorkspaceAndScope(\n    components: Component[]\n  ): Promise<{ workspaceComps: Component[]; scopeComps: Component[] }> {\n    const workspaceComps: Component[] = [];\n    const scopeComps: Component[] = [];\n    await Promise.all(\n      components.map(async (component) => {\n        const existOnWorkspace = await this.hasId(component.id);\n        existOnWorkspace ? workspaceComps.push(component) : scopeComps.push(component);\n      })\n    );\n    return { workspaceComps, scopeComps };\n  }\n\n  /**\n   * Load all unloaded extensions from a list\n   * @param extensions list of extensions with config to load\n   */\n  async loadExtensions(extensions: ExtensionDataList, throwOnError = false): Promise<void> {\n    const extensionsIdsP = extensions.map(async (extensionEntry) => {\n      // Core extension\n      if (!extensionEntry.extensionId) {\n        return extensionEntry.stringId as string;\n      }\n\n      const id = await this.resolveComponentId(extensionEntry.extensionId);\n      // return this.resolveComponentId(extensionEntry.extensionId);\n      return id.toString();\n    });\n    const extensionsIds: string[] = await Promise.all(extensionsIdsP);\n    const loadedExtensions = this.harmony.extensionsIds;\n    const extensionsToLoad = difference(extensionsIds, loadedExtensions);\n    if (!extensionsToLoad.length) return;\n    await this.loadAspects(extensionsToLoad, throwOnError);\n  }\n\n  /**\n   * Provides a cache folder, unique per key.\n   * Return value may be undefined, if workspace folder is unconventional (bare-scope, no node_modules, etc)\n   */\n  getTempDir(\n    /*\n     * unique key, i.e. aspect or component id\n     */\n    id: string\n  ) {\n    const PREFIX = 'bit';\n    const cacheDir = path.join(this.modulesPath, '.cache', PREFIX, id);\n\n    // maybe should also check it's a folder and has write permissions\n    if (!fs.existsSync(cacheDir)) {\n      fs.mkdirSync(cacheDir, { recursive: true });\n    }\n\n    return cacheDir;\n  }\n\n  async requireComponents(components: Component[]): Promise<RequireableComponent[]> {\n    let missingPaths = false;\n    const stringIds: string[] = [];\n    const resolveP = components.map(async (component) => {\n      stringIds.push(component.id._legacy.toString());\n      const localPath = this.getComponentPackagePath(component);\n      const isExist = await fs.pathExists(localPath);\n      if (!isExist) {\n        missingPaths = true;\n      }\n\n      const requireFunc = async () => {\n        // eslint-disable-next-line global-require, import/no-dynamic-require\n        const aspect = require(localPath);\n        // require aspect runtimes\n        const runtimePath = await this.aspectLoader.getRuntimePath(component, localPath, MainRuntime.name);\n        // eslint-disable-next-line global-require, import/no-dynamic-require\n        if (runtimePath) require(runtimePath);\n        return aspect;\n      };\n      return new RequireableComponent(component, requireFunc);\n    });\n    const resolved = await Promise.all(resolveP);\n    // Make sure to link missing components\n    if (missingPaths) {\n      await link(stringIds, false);\n    }\n    return resolved;\n  }\n\n  private async getComponentsDirectory(ids: ComponentID[]) {\n    const components = ids.length ? await this.getMany(ids) : await this.list();\n    return ComponentMap.as<string>(components, (component) => this.componentDir(component.id));\n  }\n\n  /**\n   * Install dependencies for all components in the workspace\n   *\n   * @returns\n   * @memberof Workspace\n   */\n  async install(packages?: string[], options?: WorkspaceInstallOptions) {\n    if (packages && packages.length) {\n      if (!options?.variants && options?.lifecycleType === 'dev') {\n        throw new DependencyTypeNotSupportedInPolicy(options?.lifecycleType);\n      }\n      this.logger.debug(`installing the following packages: ${packages.join()}`);\n      const resolver = this.dependencyResolver.getVersionResolver();\n      const resolvedPackagesP = packages.map((packageName) =>\n        resolver.resolveRemoteVersion(packageName, {\n          rootDir: this.path,\n        })\n      );\n      const resolvedPackages = await Promise.all(resolvedPackagesP);\n      const newWorkspacePolicyEntries: WorkspacePolicyEntry[] = [];\n      resolvedPackages.forEach((resolvedPackage) => {\n        if (resolvedPackage.version) {\n          const versionWithPrefix = this.dependencyResolver.getVersionWithSavePrefix(\n            resolvedPackage.version,\n            options?.savePrefix\n          );\n          newWorkspacePolicyEntries.push({\n            dependencyId: resolvedPackage.packageName,\n            value: {\n              version: versionWithPrefix,\n            },\n            lifecycleType: options?.lifecycleType || 'runtime',\n          });\n        }\n      });\n      if (!options?.variants) {\n        this.dependencyResolver.addToRootPolicy(newWorkspacePolicyEntries, {\n          updateExisting: options?.updateExisting ?? false,\n        });\n      } else {\n        // TODO: implement\n      }\n      await this.dependencyResolver.persistConfig(this.path);\n    }\n    if (options?.import) {\n      this.logger.setStatusLine('importing missing objects');\n      await this.importObjects();\n      this.logger.consoleSuccess();\n    }\n    this.logger.console(\n      `installing dependencies in workspace using ${chalk.cyan(this.dependencyResolver.getPackageManagerName())}`\n    );\n    this.logger.debug(`installing dependencies in workspace with options`, options);\n    this.clearCache();\n    // TODO: pass get install options\n    const installer = this.dependencyResolver.getInstaller({});\n    const compDirMap = await this.getComponentsDirectory([]);\n    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();\n\n    const depsFilterFn = await this.generateFilterFnForDepsFromLocalRemote();\n\n    const pmInstallOptions: PackageManagerInstallOptions = {\n      dedupe: options?.dedupe,\n      copyPeerToRuntimeOnRoot: options?.copyPeerToRuntimeOnRoot ?? true,\n      copyPeerToRuntimeOnComponents: options?.copyPeerToRuntimeOnComponents ?? false,\n      dependencyFilterFn: depsFilterFn,\n    };\n    await installer.install(this.path, mergedRootPolicy, compDirMap, { installTeambitBit: false }, pmInstallOptions);\n    // TODO: this make duplicate\n    // this.logger.consoleSuccess();\n    // TODO: add the links results to the output\n    await this.link({\n      linkTeambitBit: true,\n      legacyLink: true,\n      linkCoreAspects: true,\n      linkNestedDepsInNM: !this.isLegacy,\n    });\n    await this.consumer.componentFsCache.deleteAllDependenciesDataCache();\n    return compDirMap;\n  }\n\n  async link(options?: WorkspaceLinkOptions): Promise<LinkResults> {\n    const compDirMap = await this.getComponentsDirectory([]);\n    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();\n    const linker = this.dependencyResolver.getLinker({\n      rootDir: this.path,\n      linkingOptions: options,\n    });\n    const res = await linker.link(this.path, mergedRootPolicy, compDirMap, options);\n    return res;\n  }\n\n  /**\n   * Generate a filter to pass to the installer\n   * This will filter deps which are come from remotes which defined in scope.json\n   * those components comes from local remotes, usually doesn't have a package in a registry\n   * so no reason to try to install them (it will fail)\n   */\n  private async generateFilterFnForDepsFromLocalRemote() {\n    // TODO: once scope create a new API for this, replace it with the new one\n    const remotes = await this.scope._legacyRemotes();\n    return (dependencyList: DependencyList): DependencyList => {\n      const filtered = dependencyList.filter((dep) => {\n        if (!(dep instanceof ComponentDependency)) {\n          return true;\n        }\n        if (remotes.isHub(dep.componentId.scope)) {\n          return true;\n        }\n        return false;\n      });\n      return filtered;\n    };\n  }\n\n  /**\n   * same as `this.importAndGetMany()` with a specific error handling of ComponentNotFound\n   */\n  private async importAndGetAspects(componentIds: ComponentID[]): Promise<Component[]> {\n    try {\n      return await this.importAndGetMany(componentIds);\n    } catch (err: any) {\n      if (err instanceof ComponentNotFound) {\n        const config = this.harmony.get<Config>('teambit.harmony/config');\n        const configStr = JSON.stringify(config.workspaceConfig?.raw || {});\n        if (configStr.includes(err.id)) {\n          throw new BitError(`error: a component \"${err.id}\" was not found\nyour workspace.jsonc has this component-id set. you might want to remove/change it.`);\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  // TODO: replace with a proper import API on the workspace\n  private async importObjects() {\n    const importOptions: ImportOptions = {\n      ids: [],\n      verbose: false,\n      merge: false,\n      objectsOnly: true,\n      withEnvironments: false,\n      override: false,\n      writeDists: false,\n      writeConfig: false,\n      installNpmPackages: false,\n      writePackageJson: false,\n      importDependenciesDirectly: false,\n      importDependents: false,\n    };\n    try {\n      const res = await importAction({ tester: false, compiler: false }, importOptions, []);\n      return res;\n    } catch (err: any) {\n      // TODO: this is a hack since the legacy throw an error, we should provide a way to not throw this error from the legacy\n      if (err instanceof NothingToImport) {\n        // Do not write nothing to import warning\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * this should be rarely in-use.\n   * it's currently used by watch extension as a quick workaround to load .bitmap and the components\n   */\n  async _reloadConsumer() {\n    this.consumer = await loadConsumer(this.path, true);\n    this.clearCache();\n  }\n\n  getComponentPackagePath(component: ConsumerComponent | Component) {\n    const packageName = componentIdToPackageName(\n      component instanceof ConsumerComponent ? component : component.state._consumer\n    );\n    return path.join(this.modulesPath, packageName);\n  }\n\n  // TODO: should we return here the dir as it defined (aka components) or with /{name} prefix (as it used in legacy)\n  get defaultDirectory(): string {\n    return this.config.defaultDirectory;\n  }\n\n  get legacyDefaultDirectory(): string {\n    if (this.defaultDirectory && !this.defaultDirectory.includes('{name}')) {\n      return `${this.defaultDirectory}/{name}`;\n    }\n    return this.defaultDirectory;\n  }\n\n  /**\n   * Transform the id to ComponentId and get the exact id as appear in bitmap\n   *\n   * @param {(string | ComponentID | BitId)} id\n   * @returns {Promise<ComponentID>}\n   * @memberof Workspace\n   */\n  async resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID> {\n    // This is required in case where you have in your workspace a component with the same name as a core aspect\n    // let's say you have component called react-native (which is eventually my-org.my-scope/react-native)\n    // and you set teambit.react/react-native as your env\n    // bit will get here with the string teambit.react/react-native and will try to resolve it from the workspace\n    // during this it will find the my-org.my-scope/react-native which is incorrect as the core one doesn't exist in the\n    // workspace\n    if (this.aspectLoader.isCoreAspect(id.toString())) {\n      return ComponentID.fromString(id.toString());\n    }\n    let legacyId = this.consumer.getParsedIdIfExist(id.toString(), true, true);\n    if (!legacyId) {\n      try {\n        const idWithVersion = id.toString();\n        const [idWithoutVersion, version] = id.toString().split('@');\n        const _bitMapId = this.consumer.getParsedIdIfExist(idWithoutVersion, false, true);\n        // This logic is very specific, and very sensitive for changes please do not touch this without consulting with @ran or @gilad\n        // example (partial list) cases which should be handled are:\n        // use case 1 - ws component provided with the local scope name:\n        // source id        : my-scope1/my-name1\n        // bitmap res (_id) : my-name1 (comp is tagged but not exported)\n        // local scope name : my-scope1\n        // scope content    : my-name1\n        // expected result  : my-name1\n        // use case 2 - component with same name exist in ws and scope (but with different scope name)\n        // source id        : my-scope2/my-name1\n        // bitmap res (_id) : my-name1 (comp exist in ws but it's actually different component)\n        // local scope name : my-scope1\n        // scope content    : my-scope2/my-name1\n        // expected result  : my-scope2/my-name1\n        // use case 3 - component with same name exist in ws and scope (but with different scope name) - source provided without scope name\n        // source id        : my-name1\n        // bitmap res (_id) : my-name1 (comp exist in ws but it's actually different component)\n        // local scope name : my-scope1\n        // scope content    : my-scope1/my-name1 and my-scope2/my-name1\n        // expected result  : my-name1 (get the name from the bitmap)\n        // use case 4 - component with the same name and different scope are imported into the ws\n        // source id        : my-name1\n        // bitmap res (_id) : my-scope2/my-name1 (comp exist in ws from different scope (imported))\n        // local scope name : my-scope1\n        // scope content    : my-scope2/my-name1\n        // expected result  : my-scope2/my-name1 (get the name from the bitmap)\n\n        // No entry in bitmap at all, search for the original input id\n        if (!_bitMapId) {\n          return await this.scope.resolveComponentId(id.toString());\n        }\n        const _bitMapIdWithoutVersion = _bitMapId.toStringWithoutVersion();\n        const _bitMapIdWithVersion = _bitMapId.changeVersion(version).toString();\n        // The id in the bitmap has prefix which is not in the source id - the bitmap entry has scope name\n        // Handle use case 4\n        if (_bitMapIdWithoutVersion.endsWith(idWithoutVersion) && _bitMapIdWithoutVersion !== idWithoutVersion) {\n          return await this.scope.resolveComponentId(_bitMapIdWithVersion);\n        }\n        // The id in the bitmap doesn't have scope, the source id has scope\n        // Handle use case 2 and use case 1\n        if (idWithoutVersion.endsWith(_bitMapIdWithoutVersion) && _bitMapIdWithoutVersion !== idWithoutVersion) {\n          if (id.toString().startsWith(this.scope.name)) {\n            // Handle use case 1 - the provided id has scope name same as the local scope name\n            // we want to send it as it appear in the bitmap\n            return await this.scope.resolveComponentId(_bitMapIdWithVersion);\n          }\n          // Handle use case 2 - the provided id has scope which is not the local scope\n          // we want to search by the source id\n          return await this.scope.resolveComponentId(idWithVersion);\n        }\n        // Handle use case 3\n        return await this.scope.resolveComponentId(idWithVersion);\n      } catch (error: any) {\n        legacyId = BitId.parse(id.toString(), true);\n        return ComponentID.fromLegacy(legacyId);\n      }\n    }\n    const relativeComponentDir = this.componentDirFromLegacyId(legacyId, undefined, { relative: true });\n    const defaultScope = await this.componentDefaultScopeFromComponentDirAndName(\n      relativeComponentDir,\n      legacyId.toStringWithoutScopeAndVersion()\n    );\n    return ComponentID.fromLegacy(legacyId, defaultScope);\n  }\n\n  async resolveMultipleComponentIds(ids: Array<string | ComponentID | BitId>): Promise<ComponentID[]> {\n    return Promise.all(ids.map(async (id) => this.resolveComponentId(id)));\n  }\n\n  /**\n   * This will mutate the original extensions list and resolve it's ids\n   *\n   * @param {ExtensionDataList} extensions\n   * @returns {Promise<void[]>}\n   * @memberof Workspace\n   */\n  resolveExtensionsList(extensions: ExtensionDataList): Promise<void[]> {\n    const resolveMergedExtensionsP = extensions.map(async (extensionEntry) => {\n      if (extensionEntry.extensionId) {\n        // const hasVersion = extensionEntry.extensionId.hasVersion();\n        // const useBitmapVersion = !hasVersion;\n        // const resolvedId = await this.resolveComponentId(extensionEntry.extensionId, true, useBitmapVersion);\n\n        // Assuming extensionId always has scope - do not allow extension id without scope\n        const resolvedId = await this.resolveComponentId(extensionEntry.extensionId);\n        extensionEntry.extensionId = resolvedId._legacy;\n      }\n    });\n    return Promise.all(resolveMergedExtensionsP);\n  }\n\n  /**\n   * This will mutate the original extensions list and make sure all extensions has the ids with the scope / default scope\n   *\n   * @param {ExtensionDataList} extensions\n   * @returns {Promise<void[]>}\n   * @memberof Workspace\n   */\n  addDefaultScopeToExtensionsList(extensions: ExtensionDataList): Promise<void[]> {\n    const resolveMergedExtensionsP = extensions.map(async (extensionEntry) => {\n      if (extensionEntry.extensionId && !extensionEntry.extensionId.hasScope()) {\n        const componentId = ComponentID.fromLegacy(extensionEntry.extensionId);\n        const defaultScope = await this.componentDefaultScope(componentId);\n        extensionEntry.extensionId = extensionEntry.extensionId.changeScope(defaultScope);\n      }\n    });\n    return Promise.all(resolveMergedExtensionsP);\n  }\n}\n\nexport default Workspace;\n"]}