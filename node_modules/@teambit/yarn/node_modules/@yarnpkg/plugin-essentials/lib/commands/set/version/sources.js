"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareRepo = exports.runWorkflow = void 0;
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const os_1 = require("os");
const sources_1 = require("../../plugin/import/sources");
const list_1 = require("../../plugin/list");
const version_1 = require("../version");
const PR_REGEXP = /^[0-9]+$/;
function getBranchRef(branch) {
    if (PR_REGEXP.test(branch)) {
        return `pull/${branch}/head`;
    }
    else {
        return branch;
    }
}
const cloneWorkflow = ({ repository, branch }, target) => [
    [`git`, `init`, fslib_1.npath.fromPortablePath(target)],
    [`git`, `remote`, `add`, `origin`, repository],
    [`git`, `fetch`, `origin`, getBranchRef(branch)],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
];
const updateWorkflow = ({ branch }) => [
    [`git`, `fetch`, `origin`, getBranchRef(branch), `--force`],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
    [`git`, `clean`, `-dfx`],
];
const buildWorkflow = ({ plugins, noMinify }, target) => [
    [`yarn`, `build:cli`, ...new Array().concat(...plugins.map(plugin => [`--plugin`, fslib_1.ppath.resolve(target, plugin)])), ...noMinify ? [`--no-minify`] : [], `|`],
];
// eslint-disable-next-line arca/no-default-export
class SetVersionSourcesCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.installPath = clipanion_1.Option.String(`--path`, {
            description: `The path where the repository should be cloned to`,
        });
        this.repository = clipanion_1.Option.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
            description: `The repository that should be cloned`,
        });
        this.branch = clipanion_1.Option.String(`--branch`, `master`, {
            description: `The branch of the repository that should be cloned`,
        });
        this.plugins = clipanion_1.Option.Array(`--plugin`, [], {
            description: `An array of additional plugins that should be included in the bundle`,
        });
        this.noMinify = clipanion_1.Option.Boolean(`--no-minify`, false, {
            description: `Build a bundle for development (debugging) - non-minified and non-mangled`,
        });
        this.force = clipanion_1.Option.Boolean(`-f,--force`, false, {
            description: `Always clone the repository instead of trying to fetch the latest commits`,
        });
        this.skipPlugins = clipanion_1.Option.Boolean(`--skip-plugins`, false, {
            description: `Skip updating the contrib plugins`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project } = await core_1.Project.find(configuration, this.context.cwd);
        const target = typeof this.installPath !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.installPath))
            : fslib_1.ppath.resolve(fslib_1.npath.toPortablePath(os_1.tmpdir()), `yarnpkg-sources`, core_1.hashUtils.makeHash(this.repository).slice(0, 6));
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            await prepareRepo(this, { configuration, report, target });
            report.reportSeparator();
            report.reportInfo(core_1.MessageName.UNNAMED, `Building a fresh bundle`);
            report.reportSeparator();
            await runWorkflow(buildWorkflow(this, target), { configuration, context: this.context, target });
            report.reportSeparator();
            const bundlePath = fslib_1.ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
            const bundleBuffer = await fslib_1.xfs.readFilePromise(bundlePath);
            await version_1.setVersion(configuration, `sources`, bundleBuffer, {
                report,
            });
            if (!this.skipPlugins) {
                await updatePlugins(this, { project, report, target });
            }
        });
        return report.exitCode();
    }
}
exports.default = SetVersionSourcesCommand;
SetVersionSourcesCommand.paths = [
    [`set`, `version`, `from`, `sources`],
];
SetVersionSourcesCommand.usage = clipanion_1.Command.Usage({
    description: `build Yarn from master`,
    details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.

      By default, it also updates all contrib plugins to the same commit the bundle is built from. This behavior can be disabled by using the \`--skip-plugins\` flag.
    `,
    examples: [[
            `Build Yarn from master`,
            `$0 set version from sources`,
        ]],
});
async function runWorkflow(workflow, { configuration, context, target }) {
    for (const [fileName, ...args] of workflow) {
        const usePipe = args[args.length - 1] === `|`;
        if (usePipe)
            args.pop();
        if (usePipe) {
            await core_1.execUtils.pipevp(fileName, args, {
                cwd: target,
                stdin: context.stdin,
                stdout: context.stdout,
                stderr: context.stderr,
                strict: true,
            });
        }
        else {
            context.stdout.write(`${core_1.formatUtils.pretty(configuration, `  $ ${[fileName, ...args].join(` `)}`, `grey`)}\n`);
            try {
                await core_1.execUtils.execvp(fileName, args, {
                    cwd: target,
                    strict: true,
                });
            }
            catch (error) {
                context.stdout.write(error.stdout || error.stack);
                throw error;
            }
        }
    }
}
exports.runWorkflow = runWorkflow;
async function prepareRepo(spec, { configuration, report, target }) {
    let ready = false;
    if (!spec.force && fslib_1.xfs.existsSync(fslib_1.ppath.join(target, `.git`))) {
        report.reportInfo(core_1.MessageName.UNNAMED, `Fetching the latest commits`);
        report.reportSeparator();
        try {
            await runWorkflow(updateWorkflow(spec), { configuration, context: spec.context, target });
            ready = true;
        }
        catch (error) {
            report.reportSeparator();
            report.reportWarning(core_1.MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
        }
    }
    if (!ready) {
        report.reportInfo(core_1.MessageName.UNNAMED, `Cloning the remote repository`);
        report.reportSeparator();
        await fslib_1.xfs.removePromise(target);
        await fslib_1.xfs.mkdirPromise(target, { recursive: true });
        await runWorkflow(cloneWorkflow(spec, target), { configuration, context: spec.context, target });
    }
}
exports.prepareRepo = prepareRepo;
async function updatePlugins(context, { project, report, target }) {
    const data = await list_1.getAvailablePlugins(project.configuration);
    const contribPlugins = new Set(Object.keys(data));
    for (const name of project.configuration.plugins.keys()) {
        if (!contribPlugins.has(name))
            continue;
        await sources_1.buildAndSavePlugin(name, context, { project, report, target });
    }
}
