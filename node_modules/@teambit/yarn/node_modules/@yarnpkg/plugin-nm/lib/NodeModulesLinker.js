"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalHardlinksStore = exports.NodeModulesLinker = exports.NodeModulesMode = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const core_4 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const fslib_2 = require("@yarnpkg/fslib");
const libzip_1 = require("@yarnpkg/libzip");
const nm_1 = require("@yarnpkg/nm");
const nm_2 = require("@yarnpkg/nm");
const parsers_1 = require("@yarnpkg/parsers");
const plugin_pnp_1 = require("@yarnpkg/plugin-pnp");
const cmd_shim_1 = tslib_1.__importDefault(require("@zkochan/cmd-shim"));
const clipanion_1 = require("clipanion");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const STATE_FILE_VERSION = 1;
const NODE_MODULES = `node_modules`;
const DOT_BIN = `.bin`;
const INSTALL_STATE_FILE = `.yarn-state.yml`;
var NodeModulesMode;
(function (NodeModulesMode) {
    NodeModulesMode["CLASSIC"] = "classic";
    NodeModulesMode["HARDLINKS_LOCAL"] = "hardlinks-local";
    NodeModulesMode["HARDLINKS_GLOBAL"] = "hardlinks-global";
})(NodeModulesMode = exports.NodeModulesMode || (exports.NodeModulesMode = {}));
class NodeModulesLinker {
    constructor() {
        this.installStateCache = new Map();
    }
    supportsPackage(pkg, opts) {
        return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
    }
    async findPackageLocation(locator, opts) {
        const workspace = opts.project.tryWorkspaceByLocator(locator);
        if (workspace)
            return workspace.cwd;
        const installState = await core_1.miscUtils.getFactoryWithDefault(this.installStateCache, opts.project.cwd, async () => {
            return await findInstallState(opts.project, { unrollAliases: true });
        });
        if (installState === null)
            throw new clipanion_1.UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
        const locatorInfo = installState.locatorMap.get(core_1.structUtils.stringifyLocator(locator));
        if (!locatorInfo) {
            const err = new clipanion_1.UsageError(`Couldn't find ${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
            err.code = `LOCATOR_NOT_INSTALLED`;
            throw err;
        }
        const startingCwd = opts.project.configuration.startingCwd;
        return locatorInfo.locations.find(location => fslib_1.ppath.contains(startingCwd, location)) || locatorInfo.locations[0];
    }
    async findPackageLocator(location, opts) {
        const installState = await core_1.miscUtils.getFactoryWithDefault(this.installStateCache, opts.project.cwd, async () => {
            return await findInstallState(opts.project, { unrollAliases: true });
        });
        if (installState === null)
            return null;
        const { locationRoot, segments } = parseLocation(fslib_1.ppath.resolve(location), { skipPrefix: opts.project.cwd });
        let locationNode = installState.locationTree.get(locationRoot);
        if (!locationNode)
            return null;
        let locator = locationNode.locator;
        for (const segment of segments) {
            locationNode = locationNode.children.get(segment);
            if (!locationNode)
                break;
            locator = locationNode.locator || locator;
        }
        return core_1.structUtils.parseLocator(locator);
    }
    makeInstaller(opts) {
        return new NodeModulesInstaller(opts);
    }
}
exports.NodeModulesLinker = NodeModulesLinker;
class NodeModulesInstaller {
    constructor(opts) {
        this.opts = opts;
        // Stores data that we need to extract in the `installPackage` step but use
        // in the `finalizeInstall` step. Contrary to custom data this isn't persisted
        // anywhere - we literally just use it for the lifetime of the installer then
        // discard it.
        this.localStore = new Map();
        this.realLocatorChecksums = new Map();
        this.customData = {
            store: new Map(),
        };
        // Nothing to do
    }
    getCustomDataKey() {
        return JSON.stringify({
            name: `NodeModulesInstaller`,
            version: 1,
        });
    }
    attachCustomData(customData) {
        this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
        var _a;
        const packageLocation = fslib_1.ppath.resolve(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
        let customPackageData = this.customData.store.get(pkg.locatorHash);
        if (typeof customPackageData === `undefined`) {
            customPackageData = await extractCustomPackageData(pkg, fetchResult);
            if (pkg.linkType === core_3.LinkType.HARD) {
                this.customData.store.set(pkg.locatorHash, customPackageData);
            }
        }
        // We don't link the package at all if it's for an unsupported platform
        if (!plugin_pnp_1.jsInstallUtils.checkAndReportManifestCompatibility(pkg, customPackageData, `link`, { configuration: this.opts.project.configuration, report: this.opts.report }))
            return { packageLocation: null, buildDirective: null };
        const packageDependencies = new Map();
        const packagePeers = new Set();
        if (!packageDependencies.has(core_1.structUtils.stringifyIdent(pkg)))
            packageDependencies.set(core_1.structUtils.stringifyIdent(pkg), pkg.reference);
        let realLocator = pkg;
        // Only virtual packages should have effective peer dependencies, but the
        // workspaces are a special case because the original packages are kept in
        // the dependency tree even after being virtualized; so in their case we
        // just ignore their declared peer dependencies.
        if (core_1.structUtils.isVirtualLocator(pkg)) {
            realLocator = core_1.structUtils.devirtualizeLocator(pkg);
            for (const descriptor of pkg.peerDependencies.values()) {
                packageDependencies.set(core_1.structUtils.stringifyIdent(descriptor), null);
                packagePeers.add(core_1.structUtils.stringifyIdent(descriptor));
            }
        }
        const pnpNode = {
            packageLocation: `${fslib_1.npath.fromPortablePath(packageLocation)}/`,
            packageDependencies,
            packagePeers,
            linkType: pkg.linkType,
            discardFromLookup: (_a = fetchResult.discardFromLookup) !== null && _a !== void 0 ? _a : false,
        };
        this.localStore.set(pkg.locatorHash, {
            pkg,
            customPackageData,
            dependencyMeta: this.opts.project.getDependencyMeta(pkg, pkg.version),
            pnpNode,
        });
        // We need ZIP contents checksum for CAS addressing purposes, so we need to strip cache key from checksum here
        const checksum = fetchResult.checksum ? fetchResult.checksum.substring(fetchResult.checksum.indexOf(`/`) + 1) : null;
        this.realLocatorChecksums.set(realLocator.locatorHash, checksum);
        return {
            packageLocation,
            buildDirective: null,
        };
    }
    async attachInternalDependencies(locator, dependencies) {
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`)
            throw new Error(`Assertion failed: Expected information object to have been registered`);
        for (const [descriptor, locator] of dependencies) {
            const target = !core_1.structUtils.areIdentsEqual(descriptor, locator)
                ? [core_1.structUtils.stringifyIdent(locator), locator.reference]
                : locator.reference;
            slot.pnpNode.packageDependencies.set(core_1.structUtils.stringifyIdent(descriptor), target);
        }
    }
    async attachExternalDependents(locator, dependentPaths) {
        throw new Error(`External dependencies haven't been implemented for the node-modules linker`);
    }
    async finalizeInstall() {
        if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`)
            return undefined;
        const defaultFsLayer = new fslib_2.VirtualFS({
            baseFs: new fslib_2.ZipOpenFS({
                libzip: await libzip_1.getLibzipPromise(),
                maxOpenFiles: 80,
                readOnlyArchives: true,
            }),
        });
        let preinstallState = await findInstallState(this.opts.project);
        const nmMode = this.opts.project.configuration.get(`nmMode`);
        // Remove build state as well, to force rebuild of all the packages
        if (preinstallState === null || nmMode !== preinstallState.nmMode) {
            this.opts.project.storedBuildState.clear();
            preinstallState = { locatorMap: new Map(), binSymlinks: new Map(), locationTree: new Map(), nmMode };
        }
        const hoistingLimitsByCwd = new Map(this.opts.project.workspaces.map(workspace => {
            var _a, _b;
            let hoistingLimits = this.opts.project.configuration.get(`nmHoistingLimits`);
            try {
                hoistingLimits = core_1.miscUtils.validateEnum(nm_2.NodeModulesHoistingLimits, (_b = (_a = workspace.manifest.installConfig) === null || _a === void 0 ? void 0 : _a.hoistingLimits) !== null && _b !== void 0 ? _b : hoistingLimits);
            }
            catch (e) {
                const workspaceName = core_1.structUtils.prettyWorkspace(this.opts.project.configuration, workspace);
                this.opts.report.reportWarning(core_4.MessageName.INVALID_MANIFEST, `${workspaceName}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values(nm_2.NodeModulesHoistingLimits).join(`, `)}, using default: "${hoistingLimits}"`);
            }
            return [workspace.relativeCwd, hoistingLimits];
        }));
        const pnpApi = {
            VERSIONS: {
                std: 1,
            },
            topLevel: {
                name: null,
                reference: null,
            },
            getLocator: (name, referencish) => {
                if (Array.isArray(referencish)) {
                    return { name: referencish[0], reference: referencish[1] };
                }
                else {
                    return { name, reference: referencish };
                }
            },
            getDependencyTreeRoots: () => {
                return this.opts.project.workspaces.map(workspace => {
                    const anchoredLocator = workspace.anchoredLocator;
                    return { name: core_1.structUtils.stringifyIdent(workspace.locator), reference: anchoredLocator.reference };
                });
            },
            getPackageInformation: pnpLocator => {
                const locator = pnpLocator.reference === null
                    ? this.opts.project.topLevelWorkspace.anchoredLocator
                    : core_1.structUtils.makeLocator(core_1.structUtils.parseIdent(pnpLocator.name), pnpLocator.reference);
                const slot = this.localStore.get(locator.locatorHash);
                if (typeof slot === `undefined`)
                    throw new Error(`Assertion failed: Expected the package reference to have been registered`);
                return slot.pnpNode;
            },
            findPackageLocator: location => {
                const workspace = this.opts.project.tryWorkspaceByCwd(fslib_1.npath.toPortablePath(location));
                if (workspace !== null) {
                    const anchoredLocator = workspace.anchoredLocator;
                    return { name: core_1.structUtils.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference };
                }
                throw new Error(`Assertion failed: Unimplemented`);
            },
            resolveToUnqualified: () => {
                throw new Error(`Assertion failed: Unimplemented`);
            },
            resolveUnqualified: () => {
                throw new Error(`Assertion failed: Unimplemented`);
            },
            resolveRequest: () => {
                throw new Error(`Assertion failed: Unimplemented`);
            },
            resolveVirtual: path => {
                return fslib_1.npath.fromPortablePath(fslib_2.VirtualFS.resolveVirtual(fslib_1.npath.toPortablePath(path)));
            },
        };
        const { tree, errors, preserveSymlinksRequired } = nm_1.buildNodeModulesTree(pnpApi, { pnpifyFs: false, validateExternalSoftLinks: true, hoistingLimitsByCwd, project: this.opts.project });
        if (!tree) {
            for (const { messageName, text } of errors)
                this.opts.report.reportError(messageName, text);
            return undefined;
        }
        const locatorMap = nm_2.buildLocatorMap(tree);
        await persistNodeModules(preinstallState, locatorMap, {
            baseFs: defaultFsLayer,
            project: this.opts.project,
            report: this.opts.report,
            realLocatorChecksums: this.realLocatorChecksums,
            loadManifest: async (locatorKey) => {
                const locator = core_1.structUtils.parseLocator(locatorKey);
                const slot = this.localStore.get(locator.locatorHash);
                if (typeof slot === `undefined`)
                    throw new Error(`Assertion failed: Expected the slot to exist`);
                return slot.customPackageData.manifest;
            },
        });
        const installStatuses = [];
        for (const [locatorKey, installRecord] of locatorMap.entries()) {
            if (isLinkLocator(locatorKey))
                continue;
            const locator = core_1.structUtils.parseLocator(locatorKey);
            const slot = this.localStore.get(locator.locatorHash);
            if (typeof slot === `undefined`)
                throw new Error(`Assertion failed: Expected the slot to exist`);
            // Workspaces are built by the core
            if (this.opts.project.tryWorkspaceByLocator(slot.pkg))
                continue;
            const buildScripts = plugin_pnp_1.jsInstallUtils.extractBuildScripts(slot.pkg, slot.customPackageData, slot.dependencyMeta, { configuration: this.opts.project.configuration, report: this.opts.report });
            if (buildScripts.length === 0)
                continue;
            installStatuses.push({
                buildLocations: installRecord.locations,
                locatorHash: locator.locatorHash,
                buildDirective: buildScripts,
            });
        }
        if (preserveSymlinksRequired)
            this.opts.report.reportWarning(core_4.MessageName.NM_PRESERVE_SYMLINKS_REQUIRED, `The application uses portals and that's why ${core_1.formatUtils.pretty(this.opts.project.configuration, `--preserve-symlinks`, core_1.formatUtils.Type.CODE)} Node option is required for launching it`);
        return {
            customData: this.customData,
            records: installStatuses,
        };
    }
}
async function extractCustomPackageData(pkg, fetchResult) {
    var _a;
    const manifest = (_a = await core_1.Manifest.tryFind(fetchResult.prefixPath, { baseFs: fetchResult.packageFs })) !== null && _a !== void 0 ? _a : new core_1.Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
        if (!preservedScripts.has(scriptName))
            manifest.scripts.delete(scriptName);
    return {
        manifest: {
            bin: manifest.bin,
            os: manifest.os,
            cpu: manifest.cpu,
            scripts: manifest.scripts,
        },
        misc: {
            extractHint: plugin_pnp_1.jsInstallUtils.getExtractHint(fetchResult),
            hasBindingGyp: plugin_pnp_1.jsInstallUtils.hasBindingGyp(fetchResult),
        },
    };
}
async function writeInstallState(project, locatorMap, binSymlinks, nmMode) {
    let locatorState = ``;
    locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will\n`;
    locatorState += `# cause your node_modules installation to become invalidated.\n`;
    locatorState += `\n`;
    locatorState += `__metadata:\n`;
    locatorState += `  version: ${STATE_FILE_VERSION}\n`;
    locatorState += `  nmMode: ${nmMode}\n`;
    const locators = Array.from(locatorMap.keys()).sort();
    const topLevelLocator = core_1.structUtils.stringifyLocator(project.topLevelWorkspace.anchoredLocator);
    for (const locator of locators) {
        const installRecord = locatorMap.get(locator);
        locatorState += `\n`;
        locatorState += `${JSON.stringify(locator)}:\n`;
        locatorState += `  locations:\n`;
        for (const location of installRecord.locations) {
            const internalPath = fslib_1.ppath.contains(project.cwd, location);
            if (internalPath === null)
                throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
            locatorState += `    - ${JSON.stringify(internalPath)}\n`;
        }
        if (installRecord.aliases.length > 0) {
            locatorState += `  aliases:\n`;
            for (const alias of installRecord.aliases) {
                locatorState += `    - ${JSON.stringify(alias)}\n`;
            }
        }
        if (locator === topLevelLocator && binSymlinks.size > 0) {
            locatorState += `  bin:\n`;
            for (const [location, symlinks] of binSymlinks) {
                const internalPath = fslib_1.ppath.contains(project.cwd, location);
                if (internalPath === null)
                    throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
                locatorState += `    ${JSON.stringify(internalPath)}:\n`;
                for (const [name, target] of symlinks) {
                    const relativePath = fslib_1.ppath.relative(fslib_1.ppath.join(location, NODE_MODULES), target);
                    locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}\n`;
                }
            }
        }
    }
    const rootPath = project.cwd;
    const installStatePath = fslib_1.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
    await fslib_2.xfs.changeFilePromise(installStatePath, locatorState, {
        automaticNewlines: true,
    });
}
async function findInstallState(project, { unrollAliases = false } = {}) {
    const rootPath = project.cwd;
    const installStatePath = fslib_1.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
    if (!fslib_2.xfs.existsSync(installStatePath))
        return null;
    const locatorState = parsers_1.parseSyml(await fslib_2.xfs.readFilePromise(installStatePath, `utf8`));
    // If we have a higher serialized version than we can handle, ignore the state alltogether
    if (locatorState.__metadata.version > STATE_FILE_VERSION)
        return null;
    const nmMode = locatorState.__metadata.nmMode || NodeModulesMode.CLASSIC;
    const locatorMap = new Map();
    const binSymlinks = new Map();
    delete locatorState.__metadata;
    for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
        const locations = installRecord.locations.map((location) => {
            return fslib_1.ppath.join(rootPath, location);
        });
        const recordSymlinks = installRecord.bin;
        if (recordSymlinks) {
            for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
                const location = fslib_1.ppath.join(rootPath, fslib_1.npath.toPortablePath(relativeLocation));
                const symlinks = core_1.miscUtils.getMapWithDefault(binSymlinks, location);
                for (const [name, target] of Object.entries(locationSymlinks)) {
                    symlinks.set(fslib_1.toFilename(name), fslib_1.npath.toPortablePath([location, NODE_MODULES, target].join(fslib_1.ppath.delimiter)));
                }
            }
        }
        locatorMap.set(locatorStr, {
            target: fslib_1.PortablePath.dot,
            linkType: core_3.LinkType.HARD,
            locations,
            aliases: installRecord.aliases || [],
        });
        if (unrollAliases && installRecord.aliases) {
            for (const reference of installRecord.aliases) {
                const { scope, name } = core_1.structUtils.parseLocator(locatorStr);
                const alias = core_1.structUtils.makeLocator(core_1.structUtils.makeIdent(scope, name), reference);
                const aliasStr = core_1.structUtils.stringifyLocator(alias);
                locatorMap.set(aliasStr, {
                    target: fslib_1.PortablePath.dot,
                    linkType: core_3.LinkType.HARD,
                    locations,
                    aliases: [],
                });
            }
        }
    }
    return { locatorMap, binSymlinks, locationTree: buildLocationTree(locatorMap, { skipPrefix: project.cwd }), nmMode };
}
const removeDir = async (dir, options) => {
    if (dir.split(fslib_1.ppath.sep).indexOf(NODE_MODULES) < 0)
        throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);
    try {
        if (!options.innerLoop) {
            const stats = await fslib_2.xfs.lstatPromise(dir);
            if (stats.isSymbolicLink()) {
                await fslib_2.xfs.unlinkPromise(dir);
                return;
            }
        }
        const entries = await fslib_2.xfs.readdirPromise(dir, { withFileTypes: true });
        for (const entry of entries) {
            const targetPath = fslib_1.ppath.join(dir, fslib_1.toFilename(entry.name));
            if (entry.isDirectory()) {
                if (entry.name !== NODE_MODULES || (options && options.innerLoop)) {
                    await removeDir(targetPath, { innerLoop: true, contentsOnly: false });
                }
            }
            else {
                await fslib_2.xfs.unlinkPromise(targetPath);
            }
        }
        if (!options.contentsOnly) {
            await fslib_2.xfs.rmdirPromise(dir);
        }
    }
    catch (e) {
        if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
            throw e;
        }
    }
};
const CONCURRENT_OPERATION_LIMIT = 4;
const parseLocation = (location, { skipPrefix }) => {
    const projectRelativePath = fslib_1.ppath.contains(skipPrefix, location);
    if (projectRelativePath === null)
        throw new Error(`Assertion failed: Writing attempt prevented to ${location} which is outside project root: ${skipPrefix}`);
    const allSegments = projectRelativePath
        .split(fslib_1.ppath.sep)
        // Ignore empty segments (after trailing slashes)
        .filter(segment => segment !== ``);
    const nmIndex = allSegments.indexOf(NODE_MODULES);
    // Project path, up until the first node_modules segment
    const relativeRoot = allSegments.slice(0, nmIndex).join(fslib_1.ppath.sep);
    const locationRoot = fslib_1.ppath.join(skipPrefix, relativeRoot);
    // All segments that follow
    const segments = allSegments.slice(nmIndex);
    return { locationRoot, segments };
};
const buildLocationTree = (locatorMap, { skipPrefix }) => {
    const locationTree = new Map();
    if (locatorMap === null)
        return locationTree;
    const makeNode = () => ({
        children: new Map(),
        linkType: core_3.LinkType.HARD,
    });
    for (const [locator, info] of locatorMap.entries()) {
        if (info.linkType === core_3.LinkType.SOFT) {
            const internalPath = fslib_1.ppath.contains(skipPrefix, info.target);
            if (internalPath !== null) {
                const node = core_1.miscUtils.getFactoryWithDefault(locationTree, info.target, makeNode);
                node.locator = locator;
                node.linkType = info.linkType;
            }
        }
        for (const location of info.locations) {
            const { locationRoot, segments } = parseLocation(location, { skipPrefix });
            let node = core_1.miscUtils.getFactoryWithDefault(locationTree, locationRoot, makeNode);
            for (let idx = 0; idx < segments.length; ++idx) {
                const segment = segments[idx];
                // '.' segment exists only for top-level locator, skip it
                if (segment !== `.`) {
                    const nextNode = core_1.miscUtils.getFactoryWithDefault(node.children, segment, makeNode);
                    node.children.set(segment, nextNode);
                    node = nextNode;
                }
                if (idx === segments.length - 1) {
                    node.locator = locator;
                    node.linkType = info.linkType;
                }
            }
        }
    }
    return locationTree;
};
const symlinkPromise = async (srcPath, dstPath) => {
    let stats;
    try {
        if (process.platform === `win32`) {
            stats = await fslib_2.xfs.lstatPromise(srcPath);
        }
    }
    catch (e) {
    }
    if (process.platform == `win32` && (!stats || stats.isDirectory())) {
        await fslib_2.xfs.symlinkPromise(srcPath, dstPath, `junction`);
    }
    else {
        await fslib_2.xfs.symlinkPromise(fslib_1.ppath.relative(fslib_1.ppath.dirname(dstPath), srcPath), dstPath);
    }
};
async function atomicFileWrite(tmpDir, dstPath, content) {
    const tmpPath = fslib_1.ppath.join(tmpDir, fslib_1.toFilename(`${crypto_1.default.randomBytes(16).toString(`hex`)}.tmp`));
    try {
        await fslib_2.xfs.writeFilePromise(tmpPath, content);
        try {
            await fslib_2.xfs.linkPromise(tmpPath, dstPath);
        }
        catch (e) {
        }
    }
    finally {
        await fslib_2.xfs.unlinkPromise(tmpPath);
    }
}
async function copyFilePromise({ srcPath, dstPath, srcMode, globalHardlinksStore, baseFs, nmMode, digest }) {
    if (nmMode === NodeModulesMode.HARDLINKS_GLOBAL && globalHardlinksStore && digest) {
        const contentFilePath = fslib_1.ppath.join(globalHardlinksStore, digest.substring(0, 2), `${digest.substring(2)}.dat`);
        let doesContentFileExist;
        try {
            const contentDigest = await core_2.hashUtils.checksumFile(contentFilePath, { baseFs: fslib_2.xfs, algorithm: `sha1` });
            if (contentDigest !== digest) {
                // If file content was modified by the user, or corrupted, we first move it out of the way
                const tmpPath = fslib_1.ppath.join(globalHardlinksStore, fslib_1.toFilename(`${crypto_1.default.randomBytes(16).toString(`hex`)}.tmp`));
                await fslib_2.xfs.renamePromise(contentFilePath, tmpPath);
                // Then we overwrite the temporary file, thus restorting content of original file in all the linked projects
                const content = await baseFs.readFilePromise(srcPath);
                await fslib_2.xfs.writeFilePromise(tmpPath, content);
                try {
                    // Then we try to move content file back on its place, if its still free
                    // If we fail here, it means that some other process or thread has created content file
                    // And this is okay, we will end up with two content files, but both with original content, unlucky files will have `.tmp` extension
                    await fslib_2.xfs.linkPromise(tmpPath, contentFilePath);
                    await fslib_2.xfs.unlinkPromise(tmpPath);
                }
                catch (e) {
                }
            }
            await fslib_2.xfs.linkPromise(contentFilePath, dstPath);
            doesContentFileExist = true;
        }
        catch (e) {
            doesContentFileExist = false;
        }
        if (!doesContentFileExist) {
            const content = await baseFs.readFilePromise(srcPath);
            await atomicFileWrite(globalHardlinksStore, contentFilePath, content);
            await fslib_2.xfs.linkPromise(contentFilePath, dstPath);
        }
    }
    else {
        await baseFs.copyFilePromise(srcPath, dstPath);
    }
    const mode = srcMode & 0o777;
    // An optimization - files will have rw-r-r permissions (0o644) by default, we can skip chmod for them
    if (mode !== 0o644) {
        await fslib_2.xfs.chmodPromise(dstPath, mode);
    }
}
var DirEntryKind;
(function (DirEntryKind) {
    DirEntryKind["FILE"] = "file";
    DirEntryKind["DIRECTORY"] = "directory";
    DirEntryKind["SYMLINK"] = "symlink";
})(DirEntryKind || (DirEntryKind = {}));
const copyPromise = async (dstDir, srcDir, { baseFs, globalHardlinksStore, nmMode, packageChecksum }) => {
    await fslib_2.xfs.mkdirPromise(dstDir, { recursive: true });
    const getEntriesRecursive = async (relativePath = fslib_1.PortablePath.dot) => {
        const srcPath = fslib_1.ppath.join(srcDir, relativePath);
        const entries = await baseFs.readdirPromise(srcPath, { withFileTypes: true });
        const entryMap = new Map();
        for (const entry of entries) {
            const relativeEntryPath = fslib_1.ppath.join(relativePath, entry.name);
            let entryValue;
            const srcEntryPath = fslib_1.ppath.join(srcPath, entry.name);
            if (entry.isFile()) {
                entryValue = { kind: DirEntryKind.FILE, mode: (await baseFs.lstatPromise(srcEntryPath)).mode };
                if (nmMode === NodeModulesMode.HARDLINKS_GLOBAL) {
                    const digest = await core_2.hashUtils.checksumFile(srcEntryPath, { baseFs, algorithm: `sha1` });
                    entryValue.digest = digest;
                }
            }
            else if (entry.isDirectory()) {
                entryValue = { kind: DirEntryKind.DIRECTORY };
            }
            else if (entry.isSymbolicLink()) {
                entryValue = { kind: DirEntryKind.SYMLINK, symlinkTo: await baseFs.readlinkPromise(srcEntryPath) };
            }
            else {
                throw new Error(`Unsupported file type (file: ${srcEntryPath}, mode: 0o${await baseFs.statSync(srcEntryPath).mode.toString(8).padStart(6, `0`)})`);
            }
            entryMap.set(relativeEntryPath, entryValue);
            if (entry.isDirectory() && relativeEntryPath !== NODE_MODULES) {
                const childEntries = await getEntriesRecursive(relativeEntryPath);
                for (const [childRelativePath, childEntry] of childEntries) {
                    entryMap.set(childRelativePath, childEntry);
                }
            }
        }
        return entryMap;
    };
    let allEntries;
    if (nmMode === NodeModulesMode.HARDLINKS_GLOBAL && globalHardlinksStore && packageChecksum) {
        const entriesJsonPath = fslib_1.ppath.join(globalHardlinksStore, packageChecksum.substring(0, 2), `${packageChecksum.substring(2)}.json`);
        try {
            allEntries = new Map(Object.entries(JSON.parse(await fslib_2.xfs.readFilePromise(entriesJsonPath, `utf8`))));
        }
        catch (e) {
            allEntries = await getEntriesRecursive();
            await atomicFileWrite(globalHardlinksStore, entriesJsonPath, Buffer.from(JSON.stringify(Object.fromEntries(allEntries))));
        }
    }
    else {
        allEntries = await getEntriesRecursive();
    }
    for (const [relativePath, entry] of allEntries) {
        const srcPath = fslib_1.ppath.join(srcDir, relativePath);
        const dstPath = fslib_1.ppath.join(dstDir, relativePath);
        if (entry.kind === DirEntryKind.DIRECTORY) {
            await fslib_2.xfs.mkdirPromise(dstPath, { recursive: true });
        }
        else if (entry.kind === DirEntryKind.FILE) {
            await copyFilePromise({ srcPath, dstPath, srcMode: entry.mode, digest: entry.digest, nmMode, baseFs, globalHardlinksStore });
        }
        else if (entry.kind === DirEntryKind.SYMLINK) {
            await symlinkPromise(fslib_1.ppath.resolve(fslib_1.ppath.dirname(dstPath), entry.symlinkTo), dstPath);
        }
    }
};
/**
 * This function removes node_modules roots that do not exist on the filesystem from the location tree.
 *
 * This is needed to transparently support workflows on CI systems. When
 * user caches only top-level node_modules and forgets to cache node_modules
 * from deeper workspaces. By removing non-existent node_modules roots
 * we make our location tree to represent the real tree on the file system.
 *
 * Please note, that this function doesn't help with any other inconsistency
 * on a deeper level inside node_modules tree, it helps only when some node_modules roots
 * do not exist at all
 *
 * @param locationTree location tree
 *
 * @returns location tree with non-existent node_modules roots stripped
 */
function refineNodeModulesRoots(locationTree, binSymlinks) {
    const refinedLocationTree = new Map([...locationTree]);
    const refinedBinSymlinks = new Map([...binSymlinks]);
    for (const [workspaceRoot, node] of locationTree) {
        const nodeModulesRoot = fslib_1.ppath.join(workspaceRoot, NODE_MODULES);
        if (!fslib_2.xfs.existsSync(nodeModulesRoot)) {
            node.children.delete(NODE_MODULES);
            // O(m^2) complexity algorithm, but on a very few values, so not worth the trouble to optimize it
            for (const location of refinedBinSymlinks.keys()) {
                if (fslib_1.ppath.contains(nodeModulesRoot, location) !== null) {
                    refinedBinSymlinks.delete(location);
                }
            }
        }
    }
    return { locationTree: refinedLocationTree, binSymlinks: refinedBinSymlinks };
}
function isLinkLocator(locatorKey) {
    let descriptor = core_1.structUtils.parseDescriptor(locatorKey);
    if (core_1.structUtils.isVirtualDescriptor(descriptor))
        descriptor = core_1.structUtils.devirtualizeDescriptor(descriptor);
    return descriptor.range.startsWith(`link:`);
}
async function createBinSymlinkMap(installState, locationTree, projectRoot, { loadManifest }) {
    const locatorScriptMap = new Map();
    for (const [locatorKey, { locations }] of installState) {
        const manifest = !isLinkLocator(locatorKey)
            ? await loadManifest(locatorKey, locations[0])
            : null;
        const bin = new Map();
        if (manifest) {
            for (const [name, value] of manifest.bin) {
                const target = fslib_1.ppath.join(locations[0], value);
                if (value !== `` && fslib_2.xfs.existsSync(target)) {
                    bin.set(name, value);
                }
            }
        }
        locatorScriptMap.set(locatorKey, bin);
    }
    const binSymlinks = new Map();
    const getBinSymlinks = (location, parentLocatorLocation, node) => {
        const symlinks = new Map();
        const internalPath = fslib_1.ppath.contains(projectRoot, location);
        if (node.locator && internalPath !== null) {
            const binScripts = locatorScriptMap.get(node.locator);
            for (const [filename, scriptPath] of binScripts) {
                const symlinkTarget = fslib_1.ppath.join(location, fslib_1.npath.toPortablePath(scriptPath));
                symlinks.set(fslib_1.toFilename(filename), symlinkTarget);
            }
            for (const [childLocation, childNode] of node.children) {
                const absChildLocation = fslib_1.ppath.join(location, childLocation);
                const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);
                if (childSymlinks.size > 0) {
                    binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...childSymlinks]));
                }
            }
        }
        else {
            for (const [childLocation, childNode] of node.children) {
                const childSymlinks = getBinSymlinks(fslib_1.ppath.join(location, childLocation), parentLocatorLocation, childNode);
                for (const [name, symlinkTarget] of childSymlinks) {
                    symlinks.set(name, symlinkTarget);
                }
            }
        }
        return symlinks;
    };
    for (const [location, node] of locationTree) {
        const symlinks = getBinSymlinks(location, location, node);
        if (symlinks.size > 0) {
            binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...symlinks]));
        }
    }
    return binSymlinks;
}
const areRealLocatorsEqual = (locatorKey1, locatorKey2) => {
    if (!locatorKey1 || !locatorKey2)
        return locatorKey1 === locatorKey2;
    let locator1 = core_1.structUtils.parseLocator(locatorKey1);
    if (core_1.structUtils.isVirtualLocator(locator1))
        locator1 = core_1.structUtils.devirtualizeLocator(locator1);
    let locator2 = core_1.structUtils.parseLocator(locatorKey2);
    if (core_1.structUtils.isVirtualLocator(locator2))
        locator2 = core_1.structUtils.devirtualizeLocator(locator2);
    return core_1.structUtils.areLocatorsEqual(locator1, locator2);
};
function getGlobalHardlinksStore(configuration) {
    return fslib_1.ppath.join(configuration.get(`globalFolder`), `store`);
}
exports.getGlobalHardlinksStore = getGlobalHardlinksStore;
async function persistNodeModules(preinstallState, installState, { baseFs, project, report, loadManifest, realLocatorChecksums }) {
    const rootNmDirPath = fslib_1.ppath.join(project.cwd, NODE_MODULES);
    const { locationTree: prevLocationTree, binSymlinks: prevBinSymlinks } = refineNodeModulesRoots(preinstallState.locationTree, preinstallState.binSymlinks);
    const locationTree = buildLocationTree(installState, { skipPrefix: project.cwd });
    const addQueue = [];
    const addModule = async ({ srcDir, dstDir, linkType, globalHardlinksStore, nmMode, packageChecksum }) => {
        const promise = (async () => {
            try {
                if (linkType === core_3.LinkType.SOFT) {
                    await fslib_2.xfs.mkdirPromise(fslib_1.ppath.dirname(dstDir), { recursive: true });
                    await symlinkPromise(fslib_1.ppath.resolve(srcDir), dstDir);
                }
                else {
                    await copyPromise(dstDir, srcDir, { baseFs, globalHardlinksStore, nmMode, packageChecksum });
                }
            }
            catch (e) {
                e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
                throw e;
            }
            finally {
                progress.tick();
            }
        })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
        addQueue.push(promise);
        if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
            await Promise.race(addQueue);
        }
    };
    const cloneModule = async (srcDir, dstDir, options) => {
        const promise = (async () => {
            const cloneDir = async (srcDir, dstDir, options) => {
                try {
                    if (!options.innerLoop)
                        await fslib_2.xfs.mkdirPromise(dstDir, { recursive: true });
                    const entries = await fslib_2.xfs.readdirPromise(srcDir, { withFileTypes: true });
                    for (const entry of entries) {
                        if ((!options.innerLoop) && entry.name === DOT_BIN)
                            continue;
                        const src = fslib_1.ppath.join(srcDir, entry.name);
                        const dst = fslib_1.ppath.join(dstDir, entry.name);
                        if (entry.isDirectory()) {
                            if (entry.name !== NODE_MODULES || (options && options.innerLoop)) {
                                await fslib_2.xfs.mkdirPromise(dst, { recursive: true });
                                await cloneDir(src, dst, { ...options, innerLoop: true });
                            }
                        }
                        else {
                            if (nmMode === NodeModulesMode.HARDLINKS_LOCAL || nmMode === NodeModulesMode.HARDLINKS_GLOBAL) {
                                await fslib_2.xfs.linkPromise(src, dst);
                            }
                            else {
                                await fslib_2.xfs.copyFilePromise(src, dst, fs_1.default.constants.COPYFILE_FICLONE);
                            }
                        }
                    }
                }
                catch (e) {
                    if (!options.innerLoop)
                        e.message = `While cloning ${srcDir} -> ${dstDir} ${e.message}`;
                    throw e;
                }
                finally {
                    if (!options.innerLoop) {
                        progress.tick();
                    }
                }
            };
            await cloneDir(srcDir, dstDir, options);
        })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
        addQueue.push(promise);
        if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
            await Promise.race(addQueue);
        }
    };
    const removeOutdatedDirs = async (location, prevNode, node) => {
        if (!node) {
            if (prevNode.children.has(NODE_MODULES))
                await removeDir(fslib_1.ppath.join(location, NODE_MODULES), { contentsOnly: false });
            await removeDir(location, { contentsOnly: location === rootNmDirPath });
        }
        else {
            for (const [segment, prevChildNode] of prevNode.children) {
                const childNode = node.children.get(segment);
                await removeOutdatedDirs(fslib_1.ppath.join(location, segment), prevChildNode, childNode);
            }
        }
    };
    // Find locations that existed previously, but no longer exist
    for (const [location, prevNode] of prevLocationTree) {
        const node = locationTree.get(location);
        for (const [segment, prevChildNode] of prevNode.children) {
            // '.' segment exists only for top-level locator, skip it
            if (segment === `.`)
                continue;
            const childNode = node ? node.children.get(segment) : node;
            await removeOutdatedDirs(fslib_1.ppath.join(location, segment), prevChildNode, childNode);
        }
    }
    const cleanNewDirs = async (location, node, prevNode) => {
        if (!prevNode) {
            // We want to clean only contents of top-level node_modules dir, since we need these dirs to be present
            if (node.children.has(NODE_MODULES))
                await removeDir(fslib_1.ppath.join(location, NODE_MODULES), { contentsOnly: true });
            // 1. If old directory is a symlink removeDir will remove it, regardless contentsOnly value
            // 2. If old and new directories are hardlinks - we pass contentsOnly: true
            // so that removeDir cleared only contents
            // 3. If new directory is a symlink - we pass contentsOnly: false
            // so that removeDir removed the whole directory
            await removeDir(location, { contentsOnly: node.linkType === core_3.LinkType.HARD });
        }
        else {
            if (!areRealLocatorsEqual(node.locator, prevNode.locator))
                await removeDir(location, { contentsOnly: node.linkType === core_3.LinkType.HARD });
            for (const [segment, childNode] of node.children) {
                const prevChildNode = prevNode.children.get(segment);
                await cleanNewDirs(fslib_1.ppath.join(location, segment), childNode, prevChildNode);
            }
        }
    };
    // Find new locations that are being added/changed and need to be cleaned up first
    for (const [location, node] of locationTree) {
        const prevNode = prevLocationTree.get(location);
        for (const [segment, childNode] of node.children) {
            // '.' segment exists only for top-level locator, skip it
            if (segment === `.`)
                continue;
            const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
            await cleanNewDirs(fslib_1.ppath.join(location, segment), childNode, prevChildNode);
        }
    }
    const persistedLocations = new Map();
    // Update changed locations
    const addList = [];
    for (const [prevLocator, { locations }] of preinstallState.locatorMap.entries()) {
        for (const location of locations) {
            const { locationRoot, segments } = parseLocation(location, {
                skipPrefix: project.cwd,
            });
            let node = locationTree.get(locationRoot);
            let curLocation = locationRoot;
            if (node) {
                for (const segment of segments) {
                    curLocation = fslib_1.ppath.join(curLocation, segment);
                    node = node.children.get(segment);
                    if (!node) {
                        break;
                    }
                }
                if (node) {
                    const areLocatorsEqual = areRealLocatorsEqual(node.locator, prevLocator);
                    const info = installState.get(node.locator);
                    const srcDir = info.target;
                    const dstDir = curLocation;
                    const linkType = info.linkType;
                    if (areLocatorsEqual) {
                        // Remember the first location for each locator which is already persisted and is not going to be updated
                        if (!persistedLocations.has(srcDir)) {
                            persistedLocations.set(srcDir, dstDir);
                        }
                    }
                    else if (srcDir !== dstDir) {
                        let realLocator = core_1.structUtils.parseLocator(node.locator);
                        if (core_1.structUtils.isVirtualLocator(realLocator))
                            realLocator = core_1.structUtils.devirtualizeLocator(realLocator);
                        addList.push({ srcDir, dstDir, linkType, realLocatorHash: realLocator.locatorHash });
                    }
                }
            }
        }
    }
    // Add new locations
    for (const [locator, { locations }] of installState.entries()) {
        for (const location of locations) {
            const { locationRoot, segments } = parseLocation(location, {
                skipPrefix: project.cwd,
            });
            let prevTreeNode = prevLocationTree.get(locationRoot);
            let node = locationTree.get(locationRoot);
            let curLocation = locationRoot;
            const info = installState.get(locator);
            let realLocator = core_1.structUtils.parseLocator(locator);
            if (core_1.structUtils.isVirtualLocator(realLocator))
                realLocator = core_1.structUtils.devirtualizeLocator(realLocator);
            const realLocatorHash = realLocator.locatorHash;
            const srcDir = info.target;
            const dstDir = location;
            if (srcDir === dstDir)
                continue;
            const linkType = info.linkType;
            for (const segment of segments)
                node = node.children.get(segment);
            if (!prevTreeNode) {
                addList.push({ srcDir, dstDir, linkType, realLocatorHash });
            }
            else {
                for (const segment of segments) {
                    curLocation = fslib_1.ppath.join(curLocation, segment);
                    prevTreeNode = prevTreeNode.children.get(segment);
                    if (!prevTreeNode) {
                        addList.push({ srcDir, dstDir, linkType, realLocatorHash });
                        break;
                    }
                }
            }
        }
    }
    const progress = core_1.Report.progressViaCounter(addList.length);
    const reportedProgress = report.reportProgress(progress);
    const nmMode = project.configuration.get(`nmMode`);
    try {
        // For the first pass we'll only want to install a single copy for each
        // source directory. We'll later use the resulting install directories for
        // the other instances of the same package (this will avoid us having to
        // crawl the zip archives for each package).
        const globalHardlinksStore = nmMode === NodeModulesMode.HARDLINKS_GLOBAL ? `${getGlobalHardlinksStore(project.configuration)}/v1` : null;
        if (globalHardlinksStore) {
            if (!await fslib_2.xfs.existsPromise(globalHardlinksStore)) {
                await fslib_2.xfs.mkdirpPromise(globalHardlinksStore);
                for (let idx = 0; idx < 256; idx++) {
                    await fslib_2.xfs.mkdirPromise(fslib_1.ppath.join(globalHardlinksStore, idx.toString(16).padStart(2, `0`)));
                }
            }
        }
        for (const entry of addList) {
            if (entry.linkType === core_3.LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
                persistedLocations.set(entry.srcDir, entry.dstDir);
                await addModule({ ...entry, globalHardlinksStore, nmMode, packageChecksum: realLocatorChecksums.get(entry.realLocatorHash) || null });
            }
        }
        await Promise.all(addQueue);
        addQueue.length = 0;
        // Second pass: clone module duplicates
        for (const entry of addList) {
            const persistedDir = persistedLocations.get(entry.srcDir);
            if (entry.linkType !== core_3.LinkType.SOFT && entry.dstDir !== persistedDir) {
                await cloneModule(persistedDir, entry.dstDir, { nmMode });
            }
        }
        await Promise.all(addQueue);
        await fslib_2.xfs.mkdirPromise(rootNmDirPath, { recursive: true });
        const binSymlinks = await createBinSymlinkMap(installState, locationTree, project.cwd, { loadManifest });
        await persistBinSymlinks(prevBinSymlinks, binSymlinks, project.cwd);
        await writeInstallState(project, installState, binSymlinks, nmMode);
    }
    finally {
        reportedProgress.stop();
    }
}
async function persistBinSymlinks(previousBinSymlinks, binSymlinks, projectCwd) {
    // Delete outdated .bin folders
    for (const location of previousBinSymlinks.keys()) {
        if (fslib_1.ppath.contains(projectCwd, location) === null)
            throw new Error(`Assertion failed. Excepted bin symlink location to be inside project dir, instead it was at ${location}`);
        if (!binSymlinks.has(location)) {
            const binDir = fslib_1.ppath.join(location, NODE_MODULES, DOT_BIN);
            await fslib_2.xfs.removePromise(binDir);
        }
    }
    for (const [location, symlinks] of binSymlinks) {
        if (fslib_1.ppath.contains(projectCwd, location) === null)
            throw new Error(`Assertion failed. Excepted bin symlink location to be inside project dir, instead it was at ${location}`);
        const binDir = fslib_1.ppath.join(location, NODE_MODULES, DOT_BIN);
        const prevSymlinks = previousBinSymlinks.get(location) || new Map();
        await fslib_2.xfs.mkdirPromise(binDir, { recursive: true });
        for (const name of prevSymlinks.keys()) {
            if (!symlinks.has(name)) {
                // Remove outdated symlinks
                await fslib_2.xfs.removePromise(fslib_1.ppath.join(binDir, name));
                if (process.platform === `win32`) {
                    await fslib_2.xfs.removePromise(fslib_1.ppath.join(binDir, fslib_1.toFilename(`${name}.cmd`)));
                }
            }
        }
        for (const [name, target] of symlinks) {
            const prevTarget = prevSymlinks.get(name);
            const symlinkPath = fslib_1.ppath.join(binDir, name);
            // Skip unchanged .bin symlinks
            if (prevTarget === target)
                continue;
            if (process.platform === `win32`) {
                await cmd_shim_1.default(fslib_1.npath.fromPortablePath(target), fslib_1.npath.fromPortablePath(symlinkPath), { createPwshFile: false });
            }
            else {
                await fslib_2.xfs.removePromise(symlinkPath);
                await symlinkPromise(target, symlinkPath);
                if (fslib_1.ppath.contains(projectCwd, await fslib_2.xfs.realpathPromise(target)) !== null) {
                    await fslib_2.xfs.chmodPromise(target, 0o755);
                }
            }
        }
    }
}
