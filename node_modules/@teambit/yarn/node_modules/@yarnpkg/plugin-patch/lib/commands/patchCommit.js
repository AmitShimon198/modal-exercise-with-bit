"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const patchUtils = tslib_1.__importStar(require("../patchUtils"));
// eslint-disable-next-line arca/no-default-export
class PatchCommitCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.save = clipanion_1.Option.Boolean(`-s,--save`, false, {
            description: `Add the patch to your resolution entries`,
        });
        this.patchFolder = clipanion_1.Option.String();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const folderPath = fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.patchFolder));
        const sourcePath = fslib_1.ppath.join(folderPath, `../source`);
        const metaPath = fslib_1.ppath.join(folderPath, `../.yarn-patch.json`);
        if (!fslib_1.xfs.existsSync(sourcePath))
            throw new clipanion_1.UsageError(`The argument folder didn't get created by 'yarn patch'`);
        const diff = await patchUtils.diffFolders(sourcePath, folderPath);
        const meta = await fslib_1.xfs.readJsonPromise(metaPath);
        const locator = core_1.structUtils.parseLocator(meta.locator, true);
        if (!project.storedPackages.has(locator.locatorHash))
            throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
        if (!this.save) {
            this.context.stdout.write(diff);
            return;
        }
        const patchFolder = configuration.get(`patchFolder`);
        const patchPath = fslib_1.ppath.join(patchFolder, core_1.structUtils.slugifyLocator(locator));
        await fslib_1.xfs.mkdirPromise(patchFolder, { recursive: true });
        await fslib_1.xfs.writeFilePromise(patchPath, diff);
        const relPath = fslib_1.ppath.relative(project.cwd, patchPath);
        project.topLevelWorkspace.manifest.resolutions.push({
            pattern: { descriptor: { fullName: core_1.structUtils.stringifyIdent(locator), description: meta.version } },
            reference: `patch:${core_1.structUtils.stringifyLocator(locator)}#${relPath}`,
        });
        await project.persist();
    }
}
exports.default = PatchCommitCommand;
PatchCommitCommand.paths = [
    [`patch-commit`],
];
PatchCommitCommand.usage = clipanion_1.Command.Usage({
    description: `generate a patch out of a directory`,
    details: `
      This will print a patchfile on stdout based on the diff between the folder passed in and the original version of the package. Such file is suitable for consumption with the \`patch:\` protocol.

      Only folders generated by \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `,
});
