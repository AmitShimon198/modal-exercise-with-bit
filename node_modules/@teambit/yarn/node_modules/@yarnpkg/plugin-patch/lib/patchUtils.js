"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffFolders = exports.extractPackageToDisk = exports.loadPatchFiles = exports.isParentRequired = exports.extractPatchFlags = exports.makeLocator = exports.makeDescriptor = exports.parseLocator = exports.parseDescriptor = exports.parsePatchFile = exports.applyPatchFile = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
var apply_1 = require("./tools/apply");
Object.defineProperty(exports, "applyPatchFile", { enumerable: true, get: function () { return apply_1.applyPatchFile; } });
var parse_1 = require("./tools/parse");
Object.defineProperty(exports, "parsePatchFile", { enumerable: true, get: function () { return parse_1.parsePatchFile; } });
const BUILTIN_REGEXP = /^builtin<([^>]+)>$/;
function parseSpec(spec, sourceParser) {
    const { source, selector, params } = core_1.structUtils.parseRange(spec);
    if (source === null)
        throw new Error(`Patch locators must explicitly define their source`);
    const patchPaths = selector
        ? selector.split(/&/).map(path => fslib_1.npath.toPortablePath(path))
        : [];
    const parentLocator = params && typeof params.locator === `string`
        ? core_1.structUtils.parseLocator(params.locator)
        : null;
    const sourceVersion = params && typeof params.version === `string`
        ? params.version
        : null;
    const sourceItem = sourceParser(source);
    return { parentLocator, sourceItem, patchPaths, sourceVersion };
}
function parseDescriptor(descriptor) {
    const { sourceItem, ...rest } = parseSpec(descriptor.range, core_1.structUtils.parseDescriptor);
    return { ...rest, sourceDescriptor: sourceItem };
}
exports.parseDescriptor = parseDescriptor;
function parseLocator(locator) {
    const { sourceItem, ...rest } = parseSpec(locator.reference, core_1.structUtils.parseLocator);
    return { ...rest, sourceLocator: sourceItem };
}
exports.parseLocator = parseLocator;
function makeSpec({ parentLocator, sourceItem, patchPaths, sourceVersion, patchHash }, sourceStringifier) {
    const parentLocatorSpread = parentLocator !== null
        ? { locator: core_1.structUtils.stringifyLocator(parentLocator) }
        : {};
    const sourceVersionSpread = typeof sourceVersion !== `undefined`
        ? { version: sourceVersion }
        : {};
    const patchHashSpread = typeof patchHash !== `undefined`
        ? { hash: patchHash }
        : {};
    return core_1.structUtils.makeRange({
        protocol: `patch:`,
        source: sourceStringifier(sourceItem),
        selector: patchPaths.join(`&`),
        params: {
            ...sourceVersionSpread,
            ...patchHashSpread,
            ...parentLocatorSpread,
        },
    });
}
function makeDescriptor(ident, { parentLocator, sourceDescriptor, patchPaths }) {
    return core_1.structUtils.makeLocator(ident, makeSpec({ parentLocator, sourceItem: sourceDescriptor, patchPaths }, core_1.structUtils.stringifyDescriptor));
}
exports.makeDescriptor = makeDescriptor;
function makeLocator(ident, { parentLocator, sourcePackage, patchPaths, patchHash }) {
    return core_1.structUtils.makeLocator(ident, makeSpec({ parentLocator, sourceItem: sourcePackage, sourceVersion: sourcePackage.version, patchPaths, patchHash }, core_1.structUtils.stringifyLocator));
}
exports.makeLocator = makeLocator;
function visitPatchPath({ onAbsolute, onRelative, onBuiltin }, patchPath) {
    const optional = patchPath.startsWith(`~`);
    if (optional)
        patchPath = patchPath.slice(1);
    const builtinMatch = patchPath.match(BUILTIN_REGEXP);
    if (builtinMatch !== null)
        return onBuiltin(builtinMatch[1]);
    if (fslib_1.ppath.isAbsolute(patchPath)) {
        return onAbsolute(patchPath);
    }
    else {
        return onRelative(patchPath);
    }
}
function extractPatchFlags(patchPath) {
    const optional = patchPath.startsWith(`~`);
    if (optional)
        patchPath = patchPath.slice(1);
    return { optional };
}
exports.extractPatchFlags = extractPatchFlags;
function isParentRequired(patchPath) {
    return visitPatchPath({
        onAbsolute: () => false,
        onRelative: () => true,
        onBuiltin: () => false,
    }, patchPath);
}
exports.isParentRequired = isParentRequired;
async function loadPatchFiles(parentLocator, patchPaths, opts) {
    // When the patch files use absolute paths we can directly access them via
    // their location on the disk. Otherwise we must go through the package fs.
    const parentFetch = parentLocator !== null
        ? await opts.fetcher.fetch(parentLocator, opts)
        : null;
    // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.
    const effectiveParentFetch = parentFetch && parentFetch.localPath
        ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.ppath.relative(fslib_1.PortablePath.root, parentFetch.localPath) }
        : parentFetch;
    // Discard the parent fs unless we really need it to access the files
    if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
    // First we obtain the specification for all the patches that we'll have to
    // apply to the original package.
    const patchFiles = await core_1.miscUtils.releaseAfterUseAsync(async () => {
        return await Promise.all(patchPaths.map(async (patchPath) => {
            const flags = extractPatchFlags(patchPath);
            const source = await visitPatchPath({
                onAbsolute: async () => {
                    return await fslib_1.xfs.readFilePromise(patchPath, `utf8`);
                },
                onRelative: async () => {
                    if (effectiveParentFetch === null)
                        throw new Error(`Assertion failed: The parent locator should have been fetched`);
                    return await effectiveParentFetch.packageFs.readFilePromise(fslib_1.ppath.join(effectiveParentFetch.prefixPath, patchPath), `utf8`);
                },
                onBuiltin: async (name) => {
                    return await opts.project.configuration.firstHook((hooks) => {
                        return hooks.getBuiltinPatch;
                    }, opts.project, name);
                },
            }, patchPath);
            return { ...flags, source };
        }));
    });
    // Normalizes the line endings to prevent mismatches when cloning a
    // repository on Windows systems (the default settings for Git are to
    // convert newlines back and forth, which would mess with the checksum)
    for (const spec of patchFiles)
        if (typeof spec.source === `string`)
            spec.source = spec.source.replace(/\r\n?/g, `\n`);
    return patchFiles;
}
exports.loadPatchFiles = loadPatchFiles;
async function extractPackageToDisk(locator, { cache, project }) {
    const pkg = project.storedPackages.get(locator.locatorHash);
    if (typeof pkg === `undefined`)
        throw new Error(`Assertion failed: Expected the package to be registered`);
    const checksums = project.storedChecksums;
    const report = new core_1.ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const fetchResult = await fetcher.fetch(locator, { cache, project, fetcher, checksums, report });
    const temp = await fslib_1.xfs.mktempPromise();
    const sourcePath = fslib_1.ppath.join(temp, `source`);
    const userPath = fslib_1.ppath.join(temp, `user`);
    const metaPath = fslib_1.ppath.join(temp, `.yarn-patch.json`);
    await Promise.all([
        fslib_1.xfs.copyPromise(sourcePath, fetchResult.prefixPath, {
            baseFs: fetchResult.packageFs,
        }),
        fslib_1.xfs.copyPromise(userPath, fetchResult.prefixPath, {
            baseFs: fetchResult.packageFs,
        }),
        fslib_1.xfs.writeJsonPromise(metaPath, {
            locator: core_1.structUtils.stringifyLocator(locator),
            version: pkg.version,
        }),
    ]);
    fslib_1.xfs.detachTemp(temp);
    return userPath;
}
exports.extractPackageToDisk = extractPackageToDisk;
async function diffFolders(folderA, folderB) {
    const folderAN = fslib_1.npath.fromPortablePath(folderA).replace(/\\/g, `/`);
    const folderBN = fslib_1.npath.fromPortablePath(folderB).replace(/\\/g, `/`);
    const { stdout, stderr } = await core_1.execUtils.execvp(`git`, [`-c`, `core.safecrlf=false`, `diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, `--text`, folderAN, folderBN], {
        cwd: fslib_1.npath.toPortablePath(process.cwd()),
        env: {
            ...process.env,
            //#region Predictable output
            // These variables aim to ignore the global git config so we get predictable output
            // https://git-scm.com/docs/git#Documentation/git.txt-codeGITCONFIGNOSYSTEMcode
            GIT_CONFIG_NOSYSTEM: `1`,
            HOME: ``,
            XDG_CONFIG_HOME: ``,
            USERPROFILE: ``,
            //#endregion
        },
    });
    // we cannot rely on exit code, because --no-index implies --exit-code
    // i.e. git diff will exit with 1 if there were differences
    if (stderr.length > 0)
        throw new Error(`Unable to diff directories. Make sure you have a recent version of 'git' available in PATH.\nThe following error was reported by 'git':\n${stderr}`);
    const normalizePath = folderAN.startsWith(`/`)
        ? (p) => p.slice(1)
        : (p) => p;
    return stdout
        .replace(new RegExp(`(a|b)(${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`)
        .replace(new RegExp(`(a|b)${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderAN}/`), `g`), ``)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderBN}/`), `g`), ``);
}
exports.diffFolders = diffFolders;
